This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
main/
  java/
    ca/
      fuwafuwa/
        gaku/
          Analysis/
            JitenSentenceParser.java
            JpdbSentenceParser.java
            LocalSentenceParser.java
            ParsedResult.kt
            ParsedWord.java
            SentenceParser.java
            SentenceParserFactory.java
            TextAnalyzer.java
          data/
            dao/
              DictionaryDaos.kt
            importer/
              YomitanImporter.kt
            parser/
              DictionaryParser.java
              JmDictLegacyParser.java
              XmlDictionaryParser.java
            AppDatabase.kt
            Converters.kt
            Definition.kt
            Dictionary.kt
            Kanji.kt
            MetaEntities.kt
            Term.kt
          Deinflictor/
            DeinflectionDTOs.kt
            Deinflector.kt
            PosMap.kt
          Dialogs/
            FeedbackDialogFragment.kt
            GrantPermissionDialogFragment.kt
            PlayStoreRatingDialogFragment.kt
            StarRatingDialogFragment.kt
            TutorialExplainDialogFragment.kt
          Exceptions/
            NotImplementedException.java
          interfaces/
            DictionaryViewModel.kt
          Interfaces/
            Stoppable.java
          legacy/
            core/
              DatabaseHelper.java
              IDatabaseHelper.java
            furigana/
              PitchAccent.java
              PitchAccentDatabaseHelper.java
            jmdict/
              models/
                EntryOptimized.java
              JmDatabaseHelper.java
            kanjidict/
              models/
                CharacterOptimized.java
            user/
              UserDatabaseHelper.java
              UserWord.java
          Logic/
            ReviewController.java
          Network/
            AnkiConnectApi.java
            AnkiConnectClient.java
            AnkiConnectDTOs.java
            JitenApi.java
            JitenApiClient.java
            JitenDTOs.java
            JpdbApi.java
            JpdbApiClient.java
            JpdbDTOs.java
          Ocr/
            BoxParams.java
            OcrCorrection.kt
            OcrParams.kt
            OcrResult.kt
            OcrRunnable.kt
          repository/
            DictionaryRepository.kt
          Search/
            JmSearchResult.kt
            JmTask.kt
            Kd2Task.kt
            Searcher.java
            SearchInfo.kt
          Windows/
            Data/
              DisplayData.kt
              SquareChar.kt
            Enums/
              ChoiceType.java
              LayoutPosition.kt
            Interfaces/
              ICopyText.kt
              IRecalculateKanjiViews.kt
              ISearchPerformer.kt
              WindowListener.java
            Views/
              ChoiceEditText.java
              ChoiceGridView.java
              ChoiceIconView.java
              KanjiCharacterView.kt
              KanjiGridView.kt
              KanjiImageView.kt
              PitchAccentGraphView.java
              ResizeView.java
              SquareGridView.kt
              WindowView.java
              WordOverlayView.java
            CaptureWindow.kt
            EditWindow.kt
            HistoryWindow.kt
            InformationWindow.java
            InstantInfoWindow.kt
            InstantKanjiWindow.kt
            KanjiChoiceWindow.kt
            Window.java
            WindowCoordinator.kt
            WordDetailWindow.java
          BetaActivity.kt
          Constants.kt
          GakuTools.kt
          LangUtils.kt
          MainActivity.kt
          MainService.java
          MainServiceHandler.java
          MainStartFragment.kt
          PassthroughActivity.kt
          SettingsActivity.kt
          SettingsFragment.kt
          TutorialActivity.kt
          TutorialEndFragment.kt
          TutorialFragment.kt
          TutorialWelcomeFragment.kt
    DictionaryActivity.kt
  res/
    anim/
      fade_repeat.xml
      slide_in.xml
    drawable/
      bg_solid_border_0_blue_black.xml
      bg_solid_border_0_nil_white.xml
      bg_solid_border_0_white_black.xml
      bg_solid_border_corners_0_white_black_round.xml
      bg_translucent_border_0_black_black.xml
      bg_translucent_border_0_blue_blue.xml
      bg_transparent_border_0_nil_black.xml
      bg_transparent_border_0_nil_default.xml
      bg_transparent_border_0_nil_ready.xml
      bg_word_selection.xml
    drawable-anydpi/
      icon_delete.xml
      icon_edit.xml
      icon_swap.xml
    drawable-hdpi/
      gaku_notification_icon.png
      icon_delete.png
      icon_edit.png
      icon_swap.png
    drawable-mdpi/
      gaku_notification_icon.png
      icon_delete.png
      icon_edit.png
      icon_swap.png
    drawable-xhdpi/
      gaku_notification_icon.png
      icon_delete.png
      icon_edit.png
      icon_swap.png
    drawable-xxhdpi/
      gaku_notification_icon.png
      icon_delete.png
      icon_edit.png
      icon_swap.png
    drawable-xxxhdpi/
      gaku_notification_icon.png
    layout/
      activity_beta.xml
      activity_dictionary.xml
      activity_main.xml
      activity_passthrough.xml
      activity_settings.xml
      activity_tutorial.xml
      dialog_rating_stars.xml
      fragment_end.xml
      fragment_start.xml
      fragment_tutorial.xml
      fragment_welcome.xml
      item_dictionary.xml
      view_popup_word.xml
      window_capture.xml
      window_edit.xml
      window_history.xml
      window_info.xml
      window_instant_info.xml
      window_instant_kanji.xml
      window_kanji_choice.xml
      window.xml
    mipmap-anydpi-v26/
      ic_launcher_round.xml
      ic_launcher.xml
    mipmap-hdpi/
      ic_launcher_foreground.png
      ic_launcher_round.png
      ic_launcher.png
    mipmap-mdpi/
      ic_launcher_foreground.png
      ic_launcher_round.png
      ic_launcher.png
    mipmap-xhdpi/
      ic_launcher_foreground.png
      ic_launcher_round.png
      ic_launcher.png
    mipmap-xxhdpi/
      ic_launcher_foreground.png
      ic_launcher_round.png
      ic_launcher.png
    mipmap-xxxhdpi/
      ic_launcher_foreground.png
      ic_launcher_round.png
      ic_launcher.png
    values/
      arrays.xml
      colors.xml
      dimens.xml
      strings.xml
      styles.xml
    values-w820dp/
      dimens.xml
    xml/
      preferences.xml
  android_head-web.png
  AndroidManifest.xml
  ic_launcher-web.png
test/
  java/
    ca/
      fuwafuwa/
        gaku/
          data/
            YomitanImporterTest.kt
        kaku/
          ExampleUnitTest.java
          GenerateDictionary.java
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="main/java/ca/fuwafuwa/gaku/Analysis/JitenSentenceParser.java">
package ca.fuwafuwa.gaku.Analysis;

import android.content.Context;
import android.util.Log;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ca.fuwafuwa.gaku.Network.JitenApiClient;
import ca.fuwafuwa.gaku.Network.JitenDTOs;

public class JitenSentenceParser implements SentenceParser {

    private static final String TAG = "JitenSentenceParser";
    private JitenApiClient apiClient;

    private static final android.util.LruCache<String, JitenDTOs.WordDto> wordCache = new android.util.LruCache<>(200);

    public JitenSentenceParser(Context context) {
        this.apiClient = JitenApiClient.getInstance(context);
    }

    @Override
    public List<ParsedWord> parse(String text) {
        List<ParsedWord> parsedWords = new ArrayList<>();
        try {
            List<JitenDTOs.DeckWordDto> deckWords = apiClient.parse(text);

            if (deckWords == null) {
                return parsedWords;
            }

            for (JitenDTOs.DeckWordDto deckWord : deckWords) {
                if (deckWord.wordId <= 0) {
                    parsedWords.add(new ParsedWord(deckWord.originalText, "", "", null));
                    continue;
                }

                String cacheKey = deckWord.wordId + "_" + deckWord.readingIndex;
                JitenDTOs.WordDto wordDetails = wordCache.get(cacheKey);

                if (wordDetails == null) {
                    wordDetails = apiClient.getWordDetails(deckWord.wordId, deckWord.readingIndex);
                    if (wordDetails != null) {
                        wordCache.put(cacheKey, wordDetails);
                    }
                }

                if (wordDetails != null) {
                    ParsedWord word = convertToParsedWord(deckWord, wordDetails);
                    parsedWords.add(word);
                } else {
                    parsedWords.add(new ParsedWord(deckWord.originalText, "", "", null));
                }
            }

        } catch (IOException e) {
            Log.e(TAG, "Failed to parse text via Jiten API", e);
        }
        return parsedWords;
    }

    private ParsedWord convertToParsedWord(JitenDTOs.DeckWordDto deckWord, JitenDTOs.WordDto wordDetails) {
        String surface = deckWord.originalText;
        String reading = "";

        if (wordDetails.mainReading != null) {
            reading = wordDetails.mainReading.text;
        }

        ParsedWord word = new ParsedWord(surface, reading, surface, null);

        word.putMetadata("wordId", wordDetails.wordId);
        word.putMetadata("readingIndex", deckWord.readingIndex);

        if (wordDetails.definitions != null) {
            List<String> meanings = new ArrayList<>();
            List<String> meaningPos = new ArrayList<>();
            for (JitenDTOs.DefinitionDto def : wordDetails.definitions) {
                if (def.meanings != null)
                    meanings.addAll(def.meanings);
                if (def.partsOfSpeech != null)
                    meaningPos.addAll(def.partsOfSpeech);
            }
            word.setMeanings(meanings);
            word.setMeaningPos(meaningPos);
        }

        // Convert Jiten numeric pitch accent to binary string "01001"
        if (wordDetails.pitchAccents != null && !wordDetails.pitchAccents.isEmpty()) {
            // Jiten usually returns the downstep location (mora index).
            // 0 = Heiban (Flat)
            // 1 = Atamadaka (Head high)
            // n = Nakadaka/Odaka (Downstep after nth mora)

            // We generally take the first pitch accent if multiple are listed
            int accent = wordDetails.pitchAccents.get(0);
            String pattern = convertPitchToBinary(accent, reading);
            word.setPitchPattern(pattern);
        }

        if (wordDetails.knownStates != null && !wordDetails.knownStates.isEmpty()) {
            int jitenState = wordDetails.knownStates.get(0);
            int mappedState = 0;

            switch (jitenState) {
                case 1:
                    mappedState = 1;
                    break; // Young -> Learning
                case 2:
                    mappedState = 3;
                    break; // Mature -> Mature
                case 3:
                    mappedState = 4;
                    break; // Blacklisted -> Dismissed
                case 4:
                    mappedState = 5;
                    break; // Due -> Due
                case 5:
                    mappedState = 6;
                    break; // Mastered -> Mastered
                default:
                    mappedState = 0;
                    break; // New -> Unknown
            }
            word.setStatus(mappedState);
        }

        word.setDictionary("Jiten.moe");
        return word;
    }

    private String convertPitchToBinary(int accent, String reading) {
        if (reading == null || reading.isEmpty())
            return "";

        // Remove small kana or prolonged sound marks if necessary for accurate mora
        // counting,
        // but for visualization mapping to the string, usually 1 char = 1 slot in the
        // graph.
        // Assuming simple 1-to-1 char mapping for now.

        int length = reading.length();
        StringBuilder sb = new StringBuilder();

        if (accent == 0) {
            // Heiban: L H H H ...
            sb.append("0");
            for (int i = 1; i < length; i++) {
                sb.append("1");
            }
        } else if (accent == 1) {
            // Atamadaka: H L L L ...
            sb.append("1");
            for (int i = 1; i < length; i++) {
                sb.append("0");
            }
        } else {
            // Nakadaka/Odaka: L H H ... (drop after accent) L ...
            sb.append("0"); // First is low
            for (int i = 1; i < length; i++) {
                if (i < accent) {
                    sb.append("1"); // High until downstep
                } else {
                    sb.append("0"); // Low after downstep
                }
            }
        }
        return sb.toString();
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Analysis/JpdbSentenceParser.java">
package ca.fuwafuwa.gaku.Analysis;

import android.content.Context;
import android.util.Log;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

import ca.fuwafuwa.gaku.legacy.user.UserWord;
import ca.fuwafuwa.gaku.Network.JpdbApiClient;
import ca.fuwafuwa.gaku.Network.JpdbDTOs;

public class JpdbSentenceParser implements SentenceParser {

    private static final String TAG = "JpdbSentenceParser";
    private JpdbApiClient apiClient;

    private android.content.SharedPreferences prefs;

    public JpdbSentenceParser(Context context) {
        this.apiClient = JpdbApiClient.getInstance(context);
        this.prefs = androidx.preference.PreferenceManager.getDefaultSharedPreferences(context);
    }

    @Override
    public List<ParsedWord> parse(String text) {
        List<ParsedWord> parsedWords = new ArrayList<>();
        try {
            JpdbDTOs.ParseResponse response = apiClient.parse(text);
            if (response == null || response.tokens == null || response.tokens.isEmpty()) {
                return parsedWords;
            }

            // Convert text to bytes once to handle UTF-8 offsets correctly
            byte[] textBytes = text.getBytes(StandardCharsets.UTF_8);

            // tokens[0] corresponds to the first string in the request input list
            List<List<Object>> tokensForText = response.tokens.get(0);

            for (List<Object> tokenTuple : tokensForText) {
                // [vocab_index, pos, length, furigana]
                int vocabIndex = ((Number) tokenTuple.get(0)).intValue();
                int position = ((Number) tokenTuple.get(1)).intValue(); // Byte offset
                int length = ((Number) tokenTuple.get(2)).intValue(); // Byte length

                if (vocabIndex >= response.vocabulary.size())
                    continue;

                List<Object> vocabTuple = response.vocabulary.get(vocabIndex);
                // Schema: [vid, sid, rid, spelling, reading, card_state, meanings_chunks,
                // meanings_pos, pitch_accent, due_at]

                int vid = ((Number) vocabTuple.get(0)).intValue();
                int sid = ((Number) vocabTuple.get(1)).intValue();

                // Extract actual surface text based on token position (Byte Slicing)
                String surface = "";
                if (position >= 0 && position + length <= textBytes.length) {
                    surface = new String(textBytes, position, length, StandardCharsets.UTF_8);
                } else {
                    surface = (String) vocabTuple.get(3); // Fallback to dictionary spelling
                }

                String lemma = (String) vocabTuple.get(3);
                String reading = (String) vocabTuple.get(4);

                ParsedWord word = new ParsedWord(surface, reading, lemma, null);
                word.putMetadata("vid", vid);
                word.putMetadata("sid", sid);

                // State
                Object stateObj = vocabTuple.get(5);
                Object dueAtObj = (vocabTuple.size() > 9) ? vocabTuple.get(9) : null;
                word.setStatus(mapJpdbStatus(stateObj, dueAtObj));

                // Meanings
                List<String> userMeanings = new ArrayList<>();
                List<String> userPos = new ArrayList<>();

                if (vocabTuple.get(6) instanceof List) {
                    List<?> meaningsChunks = (List<?>) vocabTuple.get(6);
                    for (Object chunk : meaningsChunks) {
                        if (chunk instanceof List) {
                            List<?> glosses = (List<?>) chunk;
                            for (Object gloss : glosses) {
                                userMeanings.add(gloss.toString());
                            }
                        }
                    }
                }
                word.setMeanings(userMeanings);

                if (vocabTuple.get(7) instanceof List) {
                    List<?> posChunks = (List<?>) vocabTuple.get(7);
                    for (Object chunk : posChunks) {
                        if (chunk instanceof List) {
                            List<?> poses = (List<?>) chunk;
                            for (Object pos : poses) {
                                if (!userPos.contains(pos.toString())) {
                                    userPos.add(pos.toString());
                                }
                            }
                        }
                    }
                }
                word.setMeaningPos(userPos);

                // Pitch Accent: Convert ["L", "H"] to "01"
                if (vocabTuple.get(8) instanceof List) {
                    List<?> pitches = (List<?>) vocabTuple.get(8);
                    StringBuilder pitchStr = new StringBuilder();
                    for (Object p : pitches) {
                        String pVal = p.toString();
                        if ("L".equals(pVal))
                            pitchStr.append("0");
                        else if ("H".equals(pVal))
                            pitchStr.append("1");
                        else
                            pitchStr.append("0"); // Default low if unknown
                    }
                    word.setPitchPattern(pitchStr.toString());
                }

                word.setDictionary("JPDB");
                parsedWords.add(word);
            }

        } catch (IOException e) {
            Log.e(TAG, "Failed to parse text via JPDB API", e);
        }
        return parsedWords;
    }

    private int mapJpdbStatus(Object stateObj, Object dueAtObj) {
        if (stateObj == null)
            return UserWord.STATUS_UNKNOWN;

        if (stateObj instanceof List) {
            List<?> stateList = (List<?>) stateObj;
            if (stateList.isEmpty())
                return UserWord.STATUS_UNKNOWN;

            String primaryState = stateList.get(0).toString();

            if (primaryState.equals("locked") || primaryState.equals("redundant")) {
                if (stateList.size() > 1) {
                    primaryState = stateList.get(1).toString();
                }
            }

            switch (primaryState) {
                case "new":
                    return UserWord.STATUS_UNKNOWN;
                case "learning":
                case "known":
                    return determineLearningOrMastered(dueAtObj);
                case "never-forget":
                    return UserWord.STATUS_MASTERED;
                case "due":
                case "failed":
                    return UserWord.STATUS_DUE;
                case "suspended":
                case "blacklisted":
                    return UserWord.STATUS_DISMISSED;
                default:
                    return UserWord.STATUS_UNKNOWN;
            }
        }

        return UserWord.STATUS_UNKNOWN;
    }

    private int determineLearningOrMastered(Object dueAtObj) {
        if (dueAtObj instanceof Number) {
            long dueAt = ((Number) dueAtObj).longValue();
            long now = System.currentTimeMillis() / 1000;
            long secondsUntilDue = dueAt - now;

            String thresholdStr = prefs.getString("pref_young_threshold", "21");
            int thresholdDays = 21;
            try {
                thresholdDays = Integer.parseInt(thresholdStr);
            } catch (NumberFormatException e) {
                // ignore
            }
            long thresholdSeconds = thresholdDays * 24L * 60L * 60L;

            if (secondsUntilDue >= thresholdSeconds) {
                return UserWord.STATUS_MASTERED;
            } else {
                return UserWord.STATUS_LEARNING;
            }
        }
        return UserWord.STATUS_LEARNING;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Analysis/LocalSentenceParser.java">
package ca.fuwafuwa.gaku.Analysis;

import android.content.Context;
import android.util.Log;

import com.atilika.kuromoji.ipadic.Token;
import com.atilika.kuromoji.ipadic.Tokenizer;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import ca.fuwafuwa.gaku.data.AppDatabase;
import ca.fuwafuwa.gaku.data.Definition;
import ca.fuwafuwa.gaku.data.Dictionary;
import ca.fuwafuwa.gaku.data.Term;
import ca.fuwafuwa.gaku.legacy.user.UserDatabaseHelper;
import ca.fuwafuwa.gaku.legacy.user.UserWord;
import ca.fuwafuwa.gaku.Deinflictor.DeinflectionInfo;
import ca.fuwafuwa.gaku.Deinflictor.Deinflector;
import ca.fuwafuwa.gaku.LangUtils;

public class LocalSentenceParser implements SentenceParser {

    private static final String TAG = "LocalSentenceParser";

    private Tokenizer tokenizer;
    private UserDatabaseHelper userDbHelper;
    private AppDatabase appDatabase;
    private Deinflector deinflector;

    public LocalSentenceParser(Context context) {
        this.tokenizer = new Tokenizer();
        this.userDbHelper = UserDatabaseHelper.instance(context);
        this.appDatabase = AppDatabase.Companion.getDatabase(context);
        this.deinflector = new Deinflector(context);
    }

    @Override
    public List<ParsedWord> parse(String text) {
        List<Token> tokens = tokenizer.tokenize(text);
        List<ParsedWord> words = new ArrayList<>();

        // Get IDs of enabled dictionaries
        List<Long> activeDictIds = appDatabase.dictionaryDao().getAllDictionaries().stream()
                .filter(Dictionary::isEnabled)
                .map(Dictionary::getId)
                .collect(Collectors.toList());

        for (Token token : tokens) {
            String surface = token.getSurface();
            String rawReading = token.getReading(); // This is Katakana usually or "*"
            String baseForm = token.getBaseForm();

            // Convert reading to Hiragana for better display
            String displayReading;
            if (rawReading == null || rawReading.equals("*")) {
                displayReading = surface; // Fallback if no reading
            } else {
                displayReading = LangUtils.Companion.ConvertKanatanaToHiragana(rawReading);
            }

            ParsedWord word = new ParsedWord(surface, displayReading, baseForm, null);
            word.setPos(token.getPartOfSpeechLevel1());

            // 1. Look up status in User DB (Legacy)
            // Keeping this legacy for now to preserve User Progress
            try {
                UserWord userWord = userDbHelper.getUserWordDao().queryBuilder()
                        .where().eq("text", surface).queryForFirst();
                if (userWord != null) {
                    word.setStatus(userWord.getStatus());
                } else {
                    word.setStatus(UserWord.STATUS_UNKNOWN);
                }
            } catch (SQLException e) {
                Log.e(TAG, "Failed to query user word", e);
            }

            // 2. Look up meaning in AppDatabase (Yomitan)
            if (!activeDictIds.isEmpty()) {
                Term bestTerm = findBestTerm(surface, baseForm, activeDictIds);

                if (bestTerm != null) {
                    word.setDictionary("Yomitan"); // Could query Dictionary name if needed

                    List<String> meanings = new ArrayList<>();
                    List<Definition> defs = bestTerm.getDefinitions();
                    if (defs != null) {
                        for (Definition def : defs) {
                            meanings.add(def.getContent());
                        }
                    }
                    word.setMeanings(meanings);

                    // Optional: Update reading from dictionary if available?
                    // For now keeping tokenizer reading as it matches context usually.
                }
            }

            words.add(word);
        }

        return words;
    }

    private Term findBestTerm(String surface, String baseForm, List<Long> dictIds) {
        // Collect all possible variants (Surface, Base, Deinflections)
        List<String> variants = new ArrayList<>();
        variants.add(surface);
        if (baseForm != null && !baseForm.equals(surface)) {
            variants.add(baseForm);
        }

        // Add deinflections (e.g. "ate" -> "eat")
        List<DeinflectionInfo> deinflections = deinflector.getPotentialDeinflections(surface);
        for (DeinflectionInfo info : deinflections) {
            variants.add(info.getWord());
        }

        // Bulk query database
        List<Term> candidates = appDatabase.termDao().findTermsByVariants(variants, dictIds);

        if (candidates.isEmpty())
            return null;

        // Rank candidates
        Term bestMatch = null;
        int bestScore = Integer.MAX_VALUE;

        for (Term term : candidates) {
            // Validate Logic:
            // If the term exactly matches surface/base, it's valid.
            // If the term matches a deinflection, check if the POS allows it.
            // For MVP, we will assume validity if it came back from the query,
            // but prioritize exact matches via score.

            int score = term.getScore();
            // In Yomitan, lower score is often better (rank), but sometimes 0 is unranked.
            // Let's normalize:
            if (score <= 0)
                score = 100000;

            // Massive boost for exact match to surface
            if (term.getExpression().equals(surface)) {
                score -= 10000;
            }
            // Boost for base form match
            else if (term.getExpression().equals(baseForm)) {
                score -= 5000;
            }

            if (score < bestScore) {
                bestScore = score;
                bestMatch = term;
            }
        }

        return bestMatch;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Analysis/ParsedResult.kt">
package ca.fuwafuwa.gaku.Analysis

import ca.fuwafuwa.gaku.Ocr.OcrResult
import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr

class ParsedLine(
    val text: String,
    val boundingBox: android.graphics.Rect
)

class ParsedResult(
    val words: List<ParsedWord>,
    val lines: List<ParsedLine>,
    val displayData: DisplayDataOcr,
    private val ocrTime: Long
) {
    val message: String get() = String.format("Analysis Time: %.2fs", ocrTime / 1000.0)

    override fun toString(): String {
        return "ParsedResult(words=${words.size}, time=$ocrTime)"
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Analysis/ParsedWord.java">
package ca.fuwafuwa.gaku.Analysis;

import android.graphics.Rect;

import java.util.List;

import ca.fuwafuwa.gaku.legacy.jmdict.models.EntryOptimized;

/**
 * Represents a tokenized word with all necessary data for the UI.
 */
public class ParsedWord {

    private String surface;
    private String reading;
    private String lemma; // Base form
    private Rect boundingBox;
    private int status; // From UserWord.STATUS_*
    private String pitchPattern;
    private List<String> meanings;
    private String pos; // Part of speech (e.g., "noun", "verb");
    private String dictionary;
    private List<String> meaningPos;

    public ParsedWord(String surface, String reading, String lemma, Rect boundingBox) {
        this.surface = surface;
        this.reading = reading;
        this.lemma = lemma;
        this.boundingBox = boundingBox;
    }

    public String getSurface() {
        return surface;
    }

    public String getReading() {
        return reading;
    }

    public String getLemma() {
        return lemma;
    }

    public Rect getBoundingBox() {
        return boundingBox;
    }

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public String getPitchPattern() {
        return pitchPattern;
    }

    public void setPitchPattern(String pitchPattern) {
        this.pitchPattern = pitchPattern;
    }

    public List<String> getMeanings() {
        return meanings;
    }

    public void setMeanings(List<String> meanings) {
        this.meanings = meanings;
    }

    public String getPos() {
        return pos;
    }

    public void setPos(String pos) {
        this.pos = pos;
    }

    public String getDictionary() {
        return dictionary;
    }

    public void setDictionary(String dictionary) {
        this.dictionary = dictionary;
    }

    public List<String> getMeaningPos() {
        return meaningPos;
    }

    public void setMeaningPos(List<String> meaningPos) {
        this.meaningPos = meaningPos;
    }

    private java.util.Map<String, Object> metadata = new java.util.HashMap<>();

    public java.util.Map<String, Object> getMetadata() {
        return metadata;
    }

    public void setMetadata(java.util.Map<String, Object> metadata) {
        this.metadata = metadata;
    }

    public void putMetadata(String key, Object value) {
        this.metadata.put(key, value);
    }

    public Object getMetadata(String key) {
        return this.metadata.get(key);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Analysis/SentenceParser.java">
package ca.fuwafuwa.gaku.Analysis;

import java.util.List;

public interface SentenceParser {
    List<ParsedWord> parse(String text);
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Analysis/SentenceParserFactory.java">
package ca.fuwafuwa.gaku.Analysis;

import android.content.Context;
import androidx.preference.PreferenceManager;

public class SentenceParserFactory {

    private static SentenceParserFactory instance;
    private Context context;

    private SentenceParserFactory(Context context) {
        this.context = context.getApplicationContext();
    }

    public static synchronized SentenceParserFactory getInstance(Context context) {
        if (instance == null) {
            instance = new SentenceParserFactory(context);
        }
        return instance;
    }

    public SentenceParser getParser() {
        String backend = PreferenceManager.getDefaultSharedPreferences(context)
                .getString("pref_parser_backend", "jiten");

        switch (backend) {
            case "jpdb":
                return new JpdbSentenceParser(context);
            case "offline":
                return new LocalSentenceParser(context);
            case "jiten":
            default:
                return new JitenSentenceParser(context);
        }
    }

    public SentenceParser getLocalParser() {
        return new LocalSentenceParser(context);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Analysis/TextAnalyzer.java">
package ca.fuwafuwa.gaku.Analysis;

import android.content.Context;
import android.graphics.Rect;

import com.google.mlkit.vision.text.Text;

import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr;

import java.util.ArrayList;
import java.util.List;

public class TextAnalyzer {

    private SentenceParserFactory parserFactory;
    private Context context;

    public TextAnalyzer(Context context) {
        this.context = context;
        this.parserFactory = SentenceParserFactory.getInstance(context);
    }

    public ParsedResult analyze(Text mlKitText, DisplayDataOcr displayData, long ocrTime) {
        List<ParsedWord> parsedWords = new ArrayList<>();
        List<ParsedLine> parsedLines = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        List<Text.Symbol> allSymbols = new ArrayList<>();

        // Flatten MLKit hierarchy into a single string and a list of symbols
        for (Text.TextBlock block : mlKitText.getTextBlocks()) {
            for (Text.Line line : block.getLines()) {
                parsedLines.add(new ParsedLine(line.getText(), line.getBoundingBox()));
                if (sb.length() > 0) {
                    sb.append("\n");
                }
                sb.append(line.getText());
                for (Text.Element element : line.getElements()) {
                    allSymbols.addAll(element.getSymbols());
                }
            }
        }

        String fullText = sb.toString();
        if (fullText.isEmpty()) {
            return new ParsedResult(parsedWords, parsedLines, displayData, ocrTime);
        }

        // Parse the full text (Kuromoji / Jiten / JPDB)
        SentenceParser parser = parserFactory.getParser();
        List<ParsedWord> words = parser.parse(fullText);

        int charIndex = 0;

        for (ParsedWord word : words) {
            String surface = word.getSurface();

            // FIX: Skip ALL whitespace in the SOURCE text that isn't part of the parser's
            // word.
            // MLKit often inserts spaces that the tokenizer removes. We must advance
            // charIndex
            // past any source whitespace that isn't at the start of the current surface
            // token.
            while (charIndex < fullText.length() &&
                    Character.isWhitespace(fullText.codePointAt(charIndex)) &&
                    !startsWithWhitespace(surface)) {
                charIndex++;
            }

            if (charIndex >= fullText.length()) {
                break;
            }

            // Calculate the visual bounding box for this word
            Rect tokenRect = calculateTokenRectFromGlobalSymbols(allSymbols, fullText, charIndex, surface.length());
            charIndex += surface.length();

            // Create new word with the calculated bounding box
            ParsedWord newWord = new ParsedWord(surface, word.getReading(), word.getLemma(), tokenRect);
            newWord.setStatus(word.getStatus());
            newWord.setPitchPattern(word.getPitchPattern());
            newWord.setMeanings(word.getMeanings());
            newWord.setPos(word.getPos());
            newWord.setDictionary(word.getDictionary());
            newWord.setMeaningPos(word.getMeaningPos());
            newWord.setMetadata(word.getMetadata());

            parsedWords.add(newWord);
        }

        return new ParsedResult(parsedWords, parsedLines, displayData, ocrTime);
    }

    private boolean startsWithWhitespace(String s) {
        if (s == null || s.isEmpty())
            return false;
        return Character.isWhitespace(s.codePointAt(0));
    }

    private Rect calculateTokenRectFromGlobalSymbols(List<Text.Symbol> symbols, String fullText, int startIndex,
            int length) {
        Rect unionRect = null;
        int symIdx = 0;

        // Validation
        if (startIndex < 0 || startIndex + length > fullText.length()) {
            return new Rect(0, 0, 0, 0);
        }

        // Fast-forward symIdx to match startIndex.
        // MLKit Symbols list DOES NOT contain whitespace, but fullText DOES.
        for (int i = 0; i < startIndex; i++) {
            if (!Character.isWhitespace(fullText.codePointAt(i))) {
                symIdx++;
            }
        }

        int charsToCollect = length;
        int currentTextIdx = startIndex;

        while (charsToCollect > 0 && currentTextIdx < fullText.length()) {

            // If the source text has whitespace here, we consume the text index but NOT a
            // symbol
            if (Character.isWhitespace(fullText.codePointAt(currentTextIdx))) {
                currentTextIdx++;
                charsToCollect--;
                continue;
            }

            if (symIdx < symbols.size()) {
                Text.Symbol symbol = symbols.get(symIdx);
                Rect symbolRect = symbol.getBoundingBox();
                if (symbolRect != null) {
                    if (unionRect == null) {
                        unionRect = new Rect(symbolRect);
                    } else {
                        unionRect.union(symbolRect);
                    }
                }
                symIdx++;
            }

            currentTextIdx++;
            charsToCollect--;
        }

        if (unionRect == null) {
            return new Rect(0, 0, 0, 0);
        }
        return unionRect;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/dao/DictionaryDaos.kt">
package ca.fuwafuwa.gaku.data.dao

import androidx.room.ColumnInfo
import androidx.room.Dao
import androidx.room.Embedded
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import ca.fuwafuwa.gaku.data.Dictionary
import ca.fuwafuwa.gaku.data.Kanji
import ca.fuwafuwa.gaku.data.KanjiMeta
import ca.fuwafuwa.gaku.data.TagMeta
import ca.fuwafuwa.gaku.data.Term
import ca.fuwafuwa.gaku.data.TermMeta

data class DictionarySummary(
    @Embedded val dictionary: Dictionary,
    @ColumnInfo(name = "termCount") val termCount: Int,
    @ColumnInfo(name = "kanjiCount") val kanjiCount: Int
)

@Dao
interface DictionaryDao {
    @Insert
    fun insert(dictionary: Dictionary): Long

    @Query("SELECT * FROM dictionaries")
    fun getAllDictionaries(): List<Dictionary>

    @Query("""
        SELECT d.*, 
        (SELECT COUNT(*) FROM terms t WHERE t.dictionaryId = d.id) as termCount,
        (SELECT COUNT(*) FROM kanji k WHERE k.dictionaryId = d.id) as kanjiCount
        FROM dictionaries d
    """)
    fun getDictionariesWithStats(): List<DictionarySummary>

    @Query("DELETE FROM dictionaries WHERE id = :id")
    fun deleteDictionary(id: Long)
}

@Dao
interface TermDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insert(term: Term): Long

    // Simplified: No longer need to return IDs, just void/Unit is fine
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertAll(terms: List<Term>)

    @Query("SELECT * FROM terms WHERE expression IN (:queries) OR reading IN (:queries)")
    fun findTermsExact(queries: List<String>): List<Term>

    @Query("SELECT * FROM terms WHERE expression LIKE :prefix || '%' OR reading LIKE :prefix || '%'")
    fun findTermsByPrefix(prefix: String): List<Term>

    @Query("SELECT * FROM terms WHERE expression LIKE '%' || :suffix OR reading LIKE '%' || :suffix")
    fun findTermsBySuffix(suffix: String): List<Term>

    @Query("SELECT * FROM terms WHERE sequence IN (:sequences)")
    fun findTermsBySequence(sequences: List<Int>): List<Term>

    @Query("SELECT * FROM terms WHERE expression = :expression AND reading = :reading")
    fun findTermExact(expression: String, reading: String): List<Term>

    @Query(
        """
        SELECT * FROM terms
        WHERE dictionaryId IN (:activeDictionaryIds)
          AND (expression IN (:variants) OR reading IN (:variants))
        ORDER BY CASE WHEN score <= 0 THEN 2147483647 ELSE score END ASC,
                 LENGTH(expression) ASC
        """
    )
    fun findTermsByVariants(variants: List<String>, activeDictionaryIds: List<Long>): List<Term>

    @Query("SELECT COUNT(*) FROM terms")
    fun count(): Int
}

@Dao
interface KanjiDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertAll(kanji: List<Kanji>)

    @Query("SELECT * FROM kanji WHERE character = :characterQuery AND dictionaryId IN (:activeDictionaryIds)")
    fun findKanji(characterQuery: String, activeDictionaryIds: List<Long>): List<Kanji>

    @Query("SELECT COUNT(*) FROM kanji")
    fun count(): Int

    @Query("SELECT * FROM kanji WHERE character IN (:characters)")
    fun findKanjiBulk(characters: List<String>): List<Kanji>
}

@Dao
interface TermMetaDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertAll(items: List<TermMeta>)

    @Query("SELECT COUNT(*) FROM term_meta")
    fun count(): Int

    @Query("SELECT * FROM term_meta WHERE expression IN (:expressions)")
    fun findByExpressions(expressions: List<String>): List<TermMeta>
}

@Dao
interface KanjiMetaDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertAll(items: List<KanjiMeta>)

    @Query("SELECT COUNT(*) FROM kanji_meta")
    fun count(): Int

    @Query("SELECT * FROM kanji_meta WHERE character IN (:characters)")
    fun findByCharacters(characters: List<String>): List<KanjiMeta>
}

@Dao
interface TagMetaDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertAll(items: List<TagMeta>)

    @Query("SELECT COUNT(*) FROM tag_meta")
    fun count(): Int

    @Query(
        """
        SELECT tag_meta.* FROM tag_meta
        INNER JOIN dictionaries ON dictionaries.id = tag_meta.dictionaryId
        WHERE tag_meta.name = :name AND dictionaries.name = :dictionaryName
        LIMIT 1
        """
    )
    fun findTagByNameAndDictionary(name: String, dictionaryName: String): TagMeta?
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/importer/YomitanImporter.kt">
package ca.fuwafuwa.gaku.data.importer

import ca.fuwafuwa.gaku.data.AppDatabase
import ca.fuwafuwa.gaku.data.Definition
import ca.fuwafuwa.gaku.data.Dictionary
import ca.fuwafuwa.gaku.data.Kanji
import ca.fuwafuwa.gaku.data.KanjiMeta
import ca.fuwafuwa.gaku.data.TagMeta
import ca.fuwafuwa.gaku.data.Term
import ca.fuwafuwa.gaku.data.TermMeta
import com.google.gson.Gson
import com.google.gson.stream.JsonReader
import com.google.gson.stream.JsonToken
import java.io.File
import java.io.InputStream
import java.io.InputStreamReader
import java.util.zip.ZipFile

/**
 * Optimized importer that embeds definitions directly into Terms.
 */
class YomitanImporter(private val db: AppDatabase) {

    private val gson = Gson()
    private val BATCH_SIZE = 2000

    data class ImportProgress(
        val currentFileIndex: Int,
        val totalFiles: Int,
        val fileName: String
    )

    fun importDictionary(inputStream: InputStream, progressCallback: (ImportProgress) -> Unit) {
        val tempZip = File.createTempFile("gaku-yomitan-", ".zip")
        try {
            tempZip.outputStream().use { output -> inputStream.copyTo(output) }
            importDictionary(tempZip, progressCallback)
        } finally {
            tempZip.delete()
        }
    }

    fun importDictionary(zipArchive: File, progressCallback: (ImportProgress) -> Unit) {
        ZipFile(zipArchive).use { zip ->
            // 1. Scan structure
            val entries = zip.entries().asSequence()
                .filter { !it.isDirectory }
                .sortedBy { it.name }
                .toList()

            val indexEntry = entries.firstOrNull { it.name.endsWith("index.json") }
                ?: throw IllegalStateException("Missing index.json in Yomitan dictionary archive")

            val bankFiles = entries.filter { 
                it.name.contains("term_bank") || 
                it.name.contains("kanji_bank") || 
                it.name.contains("meta_bank") ||
                it.name.contains("tag_bank")
            }
            
            val totalFiles = bankFiles.size + 1 

            // 2. Import Index
            progressCallback(ImportProgress(0, totalFiles, "index.json"))
            val dictionaryId = db.runInTransaction<Long> {
                zip.getInputStream(indexEntry).use { parseAndInsertIndex(it) }
            }

            // 3. Process Banks
            var processedCount = 1
            
            for (entry in bankFiles) {
                val name = entry.name.substringAfterLast('/')
                progressCallback(ImportProgress(processedCount, totalFiles, name))

                // Using transactions speeds up SQLite insertions by ~100x
                db.runInTransaction {
                    zip.getInputStream(entry).use { stream ->
                        when {
                            name.contains("term_bank") -> parseAndInsertTerms(stream, dictionaryId)
                            name.contains("kanji_bank") -> parseAndInsertKanji(stream, dictionaryId)
                            name.contains("term_meta_bank") -> parseAndInsertTermMeta(stream, dictionaryId)
                            name.contains("kanji_meta_bank") -> parseAndInsertKanjiMeta(stream, dictionaryId)
                            name.contains("tag_bank") -> parseAndInsertTagMeta(stream, dictionaryId)
                        }
                    }
                }
                processedCount++
            }
        }
    }

    private fun parseAndInsertIndex(stream: InputStream): Long {
        val reader = JsonReader(InputStreamReader(stream, Charsets.UTF_8))
        var title = ""
        var revision = ""
        var format = 0
        var sequenced = false

        reader.beginObject()
        while (reader.hasNext()) {
            when (reader.nextName()) {
                "title" -> title = readAsString(reader)
                "revision" -> revision = readAsString(reader)
                "format", "version" -> format = readAsInt(reader)
                "sequenced" -> sequenced = if (reader.peek() == JsonToken.BOOLEAN) reader.nextBoolean() else readAsInt(reader) != 0
                else -> reader.skipValue()
            }
        }
        reader.endObject()

        val dict = Dictionary(name = title, revision = revision, format = format, sequenced = sequenced)
        return db.dictionaryDao().insert(dict)
    }

    private fun parseAndInsertTerms(stream: InputStream, dictId: Long) {
        val reader = JsonReader(InputStreamReader(stream, Charsets.UTF_8))
        reader.beginArray()

        val termBuffer = ArrayList<Term>(BATCH_SIZE)

        while (reader.hasNext()) {
            reader.beginArray()
            val expression = readAsString(reader)
            val reading = readAsString(reader)
            val tags = readAsString(reader)
            val rules = readAsString(reader)
            val score = readAsInt(reader)
            val definitions = parseGlossary(reader)
            val sequence = readAsInt(reader)
            val termTags = if (reader.hasNext()) readAsString(reader) else ""
            while (reader.hasNext()) reader.skipValue()
            reader.endArray()

            termBuffer.add(
                Term(
                    dictionaryId = dictId,
                    expression = expression,
                    reading = reading,
                    tags = tags,
                    rules = rules,
                    score = score,
                    sequence = sequence,
                    termTags = termTags,
                    definitions = definitions // Now stored directly
                )
            )

            if (termBuffer.size >= BATCH_SIZE) {
                db.termDao().insertAll(termBuffer)
                termBuffer.clear()
            }
        }
        
        if (termBuffer.isNotEmpty()) {
            db.termDao().insertAll(termBuffer)
        }
        reader.endArray()
    }

    private fun parseGlossary(reader: JsonReader): List<Definition> {
        val defs = mutableListOf<Definition>()
        reader.beginArray()
        while (reader.hasNext()) {
            when (reader.peek()) {
                JsonToken.STRING -> defs.add(Definition(reader.nextString().trim(), "text"))
                else -> {
                    val obj = gson.fromJson<Any>(reader, Any::class.java)
                    defs.add(Definition(gson.toJson(obj), "structured"))
                }
            }
        }
        reader.endArray()
        return defs
    }

    private fun parseAndInsertKanji(stream: InputStream, dictId: Long) {
        val reader = JsonReader(InputStreamReader(stream, Charsets.UTF_8))
        reader.beginArray()
        val buffer = ArrayList<Kanji>(BATCH_SIZE)
        while (reader.hasNext()) {
            reader.beginArray()
            val char = readAsString(reader)
            val on = readAsString(reader)
            val kun = readAsString(reader)
            val tags = readAsString(reader)
            val meaningsList = mutableListOf<String>()
            reader.beginArray()
            while (reader.hasNext()) meaningsList.add(readAsString(reader).trim())
            reader.endArray()
            while (reader.hasNext()) reader.skipValue()
            reader.endArray()

            buffer.add(
                Kanji(
                    dictionaryId = dictId,
                    character = char,
                    onyomi = on,
                    kunyomi = kun,
                    tags = tags,
                    meanings = meaningsList.joinToString("\n")
                )
            )
            
            if (buffer.size >= BATCH_SIZE) {
                db.kanjiDao().insertAll(buffer)
                buffer.clear()
            }
        }
        if (buffer.isNotEmpty()) db.kanjiDao().insertAll(buffer)
        reader.endArray()
    }

    private fun parseAndInsertTermMeta(stream: InputStream, dictId: Long) {
        val reader = JsonReader(InputStreamReader(stream, Charsets.UTF_8))
        val buffer = ArrayList<TermMeta>(BATCH_SIZE)
        reader.beginArray()
        while (reader.hasNext()) {
            reader.beginArray()
            val expression = readAsString(reader)
            val mode = readAsString(reader)
            val data = readUnknownAsJsonOrString(reader)
            while (reader.hasNext()) reader.skipValue()
            reader.endArray()
            buffer.add(TermMeta(dictionaryId = dictId, expression = expression, mode = mode, data = data))
            
            if (buffer.size >= BATCH_SIZE) {
                db.termMetaDao().insertAll(buffer)
                buffer.clear()
            }
        }
        reader.endArray()
        if (buffer.isNotEmpty()) db.termMetaDao().insertAll(buffer)
    }

    private fun parseAndInsertKanjiMeta(stream: InputStream, dictId: Long) {
        val reader = JsonReader(InputStreamReader(stream, Charsets.UTF_8))
        val buffer = ArrayList<KanjiMeta>(BATCH_SIZE)
        reader.beginArray()
        while (reader.hasNext()) {
            reader.beginArray()
            val character = readAsString(reader)
            val mode = readAsString(reader)
            val data = readUnknownAsJsonOrString(reader)
            while (reader.hasNext()) reader.skipValue()
            reader.endArray()
            buffer.add(KanjiMeta(dictionaryId = dictId, character = character, mode = mode, data = data))
            
            if (buffer.size >= BATCH_SIZE) {
                db.kanjiMetaDao().insertAll(buffer)
                buffer.clear()
            }
        }
        reader.endArray()
        if (buffer.isNotEmpty()) db.kanjiMetaDao().insertAll(buffer)
    }

    private fun parseAndInsertTagMeta(stream: InputStream, dictId: Long) {
        val reader = JsonReader(InputStreamReader(stream, Charsets.UTF_8))
        val buffer = ArrayList<TagMeta>(BATCH_SIZE)
        reader.beginArray()
        while (reader.hasNext()) {
            reader.beginArray()
            buffer.add(
                TagMeta(
                    dictionaryId = dictId,
                    name = readAsString(reader),
                    category = readAsString(reader),
                    orderIndex = readAsInt(reader),
                    notes = readAsString(reader),
                    score = readAsInt(reader)
                )
            )
            while (reader.hasNext()) reader.skipValue()
            reader.endArray()
            
            if (buffer.size >= BATCH_SIZE) {
                db.tagMetaDao().insertAll(buffer)
                buffer.clear()
            }
        }
        reader.endArray()
        if (buffer.isNotEmpty()) db.tagMetaDao().insertAll(buffer)
    }

    private fun readAsString(reader: JsonReader): String {
        return when (reader.peek()) {
            JsonToken.NULL -> {
                reader.nextNull()
                ""
            }
            JsonToken.NUMBER -> reader.nextString()
            JsonToken.BOOLEAN -> reader.nextBoolean().toString()
            else -> reader.nextString()
        }
    }

    private fun readAsInt(reader: JsonReader): Int {
        return when (reader.peek()) {
            JsonToken.NUMBER -> reader.nextInt()
            JsonToken.STRING -> reader.nextString().toIntOrNull() ?: 0
            JsonToken.NULL -> {
                reader.nextNull(); 0
            }
            else -> 0
        }
    }

    private fun readUnknownAsJsonOrString(reader: JsonReader): String {
        return when (reader.peek()) {
            JsonToken.STRING -> reader.nextString().trim()
            JsonToken.NUMBER -> reader.nextString()
            JsonToken.BOOLEAN -> reader.nextBoolean().toString()
            JsonToken.NULL -> {
                reader.nextNull(); ""
            }
            else -> gson.toJson(gson.fromJson<Any>(reader, Any::class.java))
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/parser/DictionaryParser.java">
package ca.fuwafuwa.gaku.data.parser;

/**
 * Backend-agnostic dictionary parser contract.
 *
 * @param <TInput> parser input format (e.g. XmlPullParser, InputStream, ZipInputStream)
 */
public interface DictionaryParser<TInput> {
    void parse(TInput input) throws Exception;
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/parser/JmDictLegacyParser.java">
package ca.fuwafuwa.gaku.data.parser;

import ca.fuwafuwa.gaku.legacy.core.IDatabaseHelper;
import org.xmlpull.v1.XmlPullParser;

/**
 * Temporary replacement for the removed XmlParsers.JmDict.JmParser.
 *
 * This keeps old generator code compiling while the app migrates to Room/Yomitan.
 */
public class JmDictLegacyParser implements XmlDictionaryParser {

    private final IDatabaseHelper dbHelper;

    public JmDictLegacyParser(IDatabaseHelper dbHelper) {
        this.dbHelper = dbHelper;
    }

    @Override
    public void parse(XmlPullParser input) {
        throw new UnsupportedOperationException(
                "Legacy JMdict XML parser is no longer bundled. " +
                "Use the Room/Yomitan importer under ca.fuwafuwa.gaku.data.importer."
        );
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/parser/XmlDictionaryParser.java">
package ca.fuwafuwa.gaku.data.parser;

import org.xmlpull.v1.XmlPullParser;

/**
 * Parser contract for XML dictionary sources.
 */
public interface XmlDictionaryParser extends DictionaryParser<XmlPullParser> {
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/AppDatabase.kt">
package ca.fuwafuwa.gaku.data

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import ca.fuwafuwa.gaku.data.Dictionary
import ca.fuwafuwa.gaku.data.Term
import ca.fuwafuwa.gaku.data.Kanji
import ca.fuwafuwa.gaku.data.TermMeta
import ca.fuwafuwa.gaku.data.KanjiMeta
import ca.fuwafuwa.gaku.data.TagMeta
import ca.fuwafuwa.gaku.data.dao.DictionaryDao
import ca.fuwafuwa.gaku.data.dao.KanjiDao
import ca.fuwafuwa.gaku.data.dao.KanjiMetaDao
import ca.fuwafuwa.gaku.data.dao.TagMetaDao
import ca.fuwafuwa.gaku.data.dao.TermDao
import ca.fuwafuwa.gaku.data.dao.TermMetaDao

@Database(
    entities = [
        Dictionary::class,
        Term::class,
        Kanji::class,
        TermMeta::class,
        KanjiMeta::class,
        TagMeta::class
    ],
    version = 3,
    exportSchema = false
)
@TypeConverters(Converters::class)
abstract class AppDatabase : RoomDatabase() {
    abstract fun dictionaryDao(): DictionaryDao
    abstract fun termDao(): TermDao
    abstract fun kanjiDao(): KanjiDao
    abstract fun termMetaDao(): TermMetaDao
    abstract fun kanjiMetaDao(): KanjiMetaDao
    abstract fun tagMetaDao(): TagMetaDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "gaku_yomitan.db"
                )
                    .fallbackToDestructiveMigration()
                    .build()
                INSTANCE = instance
                instance
            }
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/Converters.kt">
package ca.fuwafuwa.gaku.data

import androidx.room.TypeConverter
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken

class Converters {
    private val gson = Gson()

    @TypeConverter
    fun fromDefinitionList(value: List<Definition>?): String {
        return gson.toJson(value)
    }

    @TypeConverter
    fun toDefinitionList(value: String?): List<Definition> {
        if (value.isNullOrEmpty()) return emptyList()
        val type = object : TypeToken<List<Definition>>() {}.type
        return gson.fromJson(value, type)
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/Definition.kt">
package ca.fuwafuwa.gaku.data

/**
 * Simple data class for definitions.
 * No longer an @Entity because it is embedded directly into the Term table via JSON.
 */
data class Definition(
    val content: String,
    val type: String
)
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/Dictionary.kt">
package ca.fuwafuwa.gaku.data

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "dictionaries")
data class Dictionary(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val name: String,
    val revision: String,
    val format: Int,
    val sequenced: Boolean = false,
    val isEnabled: Boolean = true
)
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/Kanji.kt">
package ca.fuwafuwa.gaku.data

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "kanji",
    indices = [Index(value = ["character"]), Index(value = ["dictionaryId"])],
    foreignKeys = [
        ForeignKey(
            entity = Dictionary::class,
            parentColumns = ["id"],
            childColumns = ["dictionaryId"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class Kanji(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val dictionaryId: Long,
    val character: String,
    val onyomi: String,
    val kunyomi: String,
    val tags: String,
    val meanings: String
)
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/MetaEntities.kt">
package ca.fuwafuwa.gaku.data

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "term_meta",
    indices = [Index(value = ["expression"]), Index(value = ["dictionaryId"])],
    foreignKeys = [ForeignKey(entity = Dictionary::class, parentColumns = ["id"], childColumns = ["dictionaryId"], onDelete = ForeignKey.CASCADE)]
)
data class TermMeta(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val dictionaryId: Long,
    val expression: String,
    val mode: String,
    val data: String
)

@Entity(
    tableName = "kanji_meta",
    indices = [Index(value = ["character"]), Index(value = ["dictionaryId"])],
    foreignKeys = [ForeignKey(entity = Dictionary::class, parentColumns = ["id"], childColumns = ["dictionaryId"], onDelete = ForeignKey.CASCADE)]
)
data class KanjiMeta(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val dictionaryId: Long,
    val character: String,
    val mode: String,
    val data: String
)

@Entity(
    tableName = "tag_meta",
    indices = [Index(value = ["name"]), Index(value = ["dictionaryId"])],
    foreignKeys = [ForeignKey(entity = Dictionary::class, parentColumns = ["id"], childColumns = ["dictionaryId"], onDelete = ForeignKey.CASCADE)]
)
data class TagMeta(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val dictionaryId: Long,
    val name: String,
    val category: String,
    val orderIndex: Int,
    val notes: String,
    val score: Int
)
</file>

<file path="main/java/ca/fuwafuwa/gaku/data/Term.kt">
package ca.fuwafuwa.gaku.data

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "terms",
    indices = [
        Index(value = ["expression"]),
        Index(value = ["reading"]),
        Index(value = ["sequence"]),
        Index(value = ["dictionaryId"])
    ],
    foreignKeys = [
        ForeignKey(
            entity = Dictionary::class,
            parentColumns = ["id"],
            childColumns = ["dictionaryId"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class Term(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val dictionaryId: Long,
    val expression: String,
    val reading: String,
    val tags: String,
    val rules: String,
    val score: Int,
    val sequence: Int,
    val termTags: String = "",
    
    // NEW: Embedded definitions. 
    // This saves ~30% space by removing the need for a secondary table and foreign keys.
    val definitions: List<Definition>
)
</file>

<file path="main/java/ca/fuwafuwa/gaku/Deinflictor/DeinflectionDTOs.kt">
package ca.fuwafuwa.gaku.Deinflictor

/**
 * A RuleGroup is composed of multiple rules that share the same [DeinflectionRule.from] length
 *
 * @property rules List containing the rules in the RuleGroup
 * @property fromLength The [DeinflectionRule.from] length of the RuleGroup
 */
class DeinflectionRuleGroup
{
    val rules: ArrayList<DeinflectionRule> = ArrayList()
    var fromLength: Int = 0
}

/**
 * Data class to represent each rule in deinflect.dat
 *
 * @property from The inflected form
 * @property to The deinflected form
 * @property type Bitmask for determining whether to continue processing deinflection.
 * This is kinda Japanese black magic and I don't really understand it that well either.
 * @property reason Deinflection reason
 */
data class DeinflectionRule(
        val from: String,
        val to: String,
        val type: Int,
        val reason: String)

/**
 * Class to represent a deinflected word
 *
 * @property word The deinflected word
 * @property type Bitmask for determining whether to continue processing deinflection
 * @property reason Deinflection reason
 */
class DeinflectionInfo(
        var word: String,
        var type: Int,
        var reason: String)
</file>

<file path="main/java/ca/fuwafuwa/gaku/Deinflictor/Deinflector.kt">
package ca.fuwafuwa.gaku.Deinflictor

import android.content.Context
import ca.fuwafuwa.gaku.LangUtils
import java.io.BufferedReader

class Deinflector(context: Context) {

    private val _ruleGroups: ArrayList<DeinflectionRuleGroup> = ArrayList()

    init
    {
        loadRules(context.assets.open("deinflect.dat").bufferedReader(Charsets.UTF_8))
    }

    private fun loadRules(reader: BufferedReader)
    {
        // Skip header
        reader.readLine()

        var ruleGroup = DeinflectionRuleGroup()
        ruleGroup.fromLength = -1

        var ruleReasons: ArrayList<String> = ArrayList()

        reader.forEachLine {

            var fields: List<String> = it.split("\t")

            // Parse reason from file
            if (fields.size == 1)
            {
                ruleReasons.add(fields[0].trim())
            }
            // Parse rule from file
            else if (fields.size == 4)
            {
                var rule = DeinflectionRule(fields[0].trim(),
                        fields[1].trim(),
                        fields[2].trim().toInt(),
                        ruleReasons.get(fields[3].trim().toInt()))

                // Group inflections of the same length together into the same RuleGroup
                if (ruleGroup.fromLength != rule.from.length){
                    ruleGroup = DeinflectionRuleGroup()
                    ruleGroup.fromLength = rule.from.length
                    _ruleGroups.add(ruleGroup)
                }

                ruleGroup.rules.add(rule)
            }
        }
    }

    /**
     * Gets potential deinflections of an inflected word.
     * Does not guarantee that each deinflection is a real word.
     *
     * Example:
     * 		1152 (00000000 00000000 00000100 10000000)	14 (past)
     * 		2308 (00000000 00000000 00001001 00000100)	15 (negative)
     *
     * Starting word: 
     *
     * 
     * - 
     * - 00000000 00000000 00000000 00000100
     * - "< past"
     *
     * 
     * - 
     * - 00000000 00000000 00000000 00001001
     * - "< negative"
     *
     * Chain is: ["", ""]
     */
    fun getPotentialDeinflections(word: String): List<DeinflectionInfo> {

        var text: String = word //LangUtils.ConvertKanatanaToHiragana(word)

        // Chain of inflections encountered
        var deinfWordChain = ArrayList<DeinflectionInfo>()
        deinfWordChain.add(DeinflectionInfo(text, 0xFF, ""))

        // Map of possible deinflections to its deinfWordList index
        var prevSeenDeinfWords = HashMap<String, Int>()
        prevSeenDeinfWords[text] = 0

        var currWordChainIndex = 0

        do
        {
            var currDeinflectionInfo: DeinflectionInfo = deinfWordChain.get(currWordChainIndex)
            var currWord: String = currDeinflectionInfo.word

            for (ruleGroup in _ruleGroups)
            {
                // Only process RuleGroup if inflected word is longer than the group
                if (ruleGroup.fromLength > currWord.length) continue

                // Get the last X characters of word so that wordTail is the same length as the RuleGroup
                var wordTail: String = currWord.substring(currWord.length - ruleGroup.fromLength)

                for (rule in ruleGroup.rules)
                {
                    // Only process rule if wordTail matches a valid inflection rule
                    // Only process rule if previous word in deinflection chain allows for such a transformation (type does not mask out)
                    var shouldProcessRule = (currDeinflectionInfo.type and rule.type != 0) && (wordTail == rule.from)
                    if (!shouldProcessRule) continue

                    // Inflected words must be at least 2 characters in length
                    var newWord: String = currWord.substring(0, currWord.length - rule.from.length) + rule.to
                    if (newWord.length <= 1) continue

                    // We've seen this deinflection before under a different rule, update type
                    var prevSeenWordIndex: Int? = prevSeenDeinfWords.get(newWord)
                    if (prevSeenWordIndex != null)
                    {
                        var prevSeenWordType: Int = deinfWordChain[prevSeenWordIndex].type
                        deinfWordChain[prevSeenWordIndex].type = prevSeenWordType or (rule.type shr 8)
                        continue
                    }

                    // Add new deinflection to the deinflection chain
                    var newDeinflectedWord = DeinflectionInfo(
                            newWord,
                            rule.type shr 8,
                            if (currDeinflectionInfo.reason.isNotEmpty()) "< ${rule.reason} ${currDeinflectionInfo.reason}" else "< ${rule.reason}"
                    )
                    prevSeenDeinfWords[newWord] = deinfWordChain.size
                    deinfWordChain.add(newDeinflectedWord)
                }
            }
        } while (++currWordChainIndex < deinfWordChain.size)

        return deinfWordChain
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Deinflictor/PosMap.kt">
package ca.fuwafuwa.gaku.Deinflictor

class PosMap {

    companion object {

        fun GetPosMapVal(pos: String) : String {

            return when(pos){

                "*" -> "*"

                "" -> "general"

                "" -> "adjective"
                "" -> "adjective auo-end"
                "" -> "adjective i-end"
                "" -> "adjective ii"
                "" -> "adverb"
                "" -> "auxiliary verb"
                "" -> "conjunction"
                "" -> "conjunction particle"
                "" -> "pre-noun adjectival"
                "" -> "interjection"
                "" -> "noun"
                "" -> "particle"
                "" -> "case-marking particle"
                "" -> "sentence-ending particle"
                "" -> "adverbial particle"
                "" -> "parallel marker"
                "  " -> "binding particle"
                "" -> "adverbial particle/parallel marker/binding particle"
                "" -> "prefix"
                "" -> "counter suffix"
                "" -> "verb"
                "" -> "pronoun"
                "" -> "proper noun"

                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> "conjunction-like"

                "" -> "independent"
                "" -> "not independent"

                "" -> "basic form"
                "" -> "classical basic form"
                "" -> "hypothetical form"
                "" -> "imperfective form (nai stem)"
                "" -> "conjunctive form (masu stem)"
                "" -> "euphonic change basic form"
                "" -> "modern basic form"
                "-" -> "basic form - nasal sound change"

                "" -> "before -ta link"
                "" -> "before -u link"
                "" -> "before -reru link"
                "" -> "continuous -ta link"
                "" -> "continuous -te link"
                "" -> "continuous -ni link"
                "" -> "continuous -de link"
                "" -> "continuous -gozai link"
                "" -> "uninflected word link"
                "" -> "-garu link"
                "" -> "particle link"
                "" -> "irregular link"
                "" -> "noun link"
                "" -> "adjective link"
                "" -> "number link"
                "" -> "verb link"
                "" -> "special uninflected word link"
                "" -> "special uninflected word link 2"

                "" -> "assumed contraction 1"
                "" -> "assumed contraction 2"

                "" -> "suffix"
                "" -> "Invariant type"
                "" -> "before special"
                "" -> "compound word"
                "" -> pos

                "" -> pos
                "" -> pos

                "" -> "special"
                "" -> "masu"
                "" -> "desu"
                "" -> "jya"
                "" -> "ta"
                "" -> "tai"
                "" -> "nu"
                "" -> "ya"
                "" -> "nai"
                "" -> "da"

                "" -> "e-command"
                "" -> "i-command"
                "" -> "yo-command"
                "" -> "ro-command"

                "" -> "classical beshi"
                "" -> "classical maji"
                "" -> "classical ki"
                "" -> "classical nari"
                "" -> "classical ru"
                "" -> "classical ri"
                "" -> "classical keri"
                "" -> "classical gotoshi"

                "" -> "ichidan verb"
                "" -> "ichidan verb kureru"
                "" -> "ichidan verb eru"

                "" -> "yodan verb ha"
                "" -> "yodan verb ta"
                "" -> "yodan verb sa"
                "" -> "yodan verb ba"

                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos

                "" -> pos
                "" -> pos

                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos

                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos

                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos
                "" -> pos

                else -> "UNMAPPED"
            };
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Dialogs/FeedbackDialogFragment.kt">
package ca.fuwafuwa.gaku.Dialogs

import android.app.AlertDialog
import android.app.Dialog
import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.widget.Toast
import androidx.fragment.app.DialogFragment
import ca.fuwafuwa.gaku.GAKU_PREF_FILE
import ca.fuwafuwa.gaku.GAKU_PREF_PLAY_STORE_RATED

class FeedbackDialogFragment : DialogFragment()
{
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog
    {
        return activity?.let {

            val builder = AlertDialog.Builder(it)

            builder.setTitle("Thanks for your feedback!")
                    .setMessage("Do you have anything you wish to say to the developer about Gaku? Bugs, feature requests, annoyances, anything goes! (currently the developer does not exist)")
                    .setPositiveButton("SEND EMAIL")
                    {
                        _, _ ->
                        run {
                            val emailIntent = Intent(android.content.Intent.ACTION_SENDTO)
                            emailIntent.type = "text/plain"
                            emailIntent.data = Uri.parse("mailto:")
                            emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, arrayOf("example@gmail.com"))
                            emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, "Gaku Feedback - ${android.os.Build.BRAND + " " + android.os.Build.MODEL}")

                            startActivity(Intent.createChooser(emailIntent, "Send e-mail using..."))
                        }
                    }
                    .setNegativeButton("CANCEL")
                    {
                        _, _ ->
                        run {
                        }
                    }

            builder.create()

        } ?: throw IllegalStateException("Activity cannot be null")
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Dialogs/GrantPermissionDialogFragment.kt">
package ca.fuwafuwa.gaku.Dialogs

import android.app.AlertDialog
import android.app.Dialog
import android.content.Context
import android.content.Intent
import android.os.Bundle
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.FragmentActivity
import ca.fuwafuwa.gaku.GAKU_PREF_FILE
import ca.fuwafuwa.gaku.GAKU_PREF_FIRST_LAUNCH
import ca.fuwafuwa.gaku.MainActivity

class GrantPermissionDialogFragment : DialogFragment()
{
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog
    {
        return activity?.let {

            val builder = AlertDialog.Builder(it)

            builder.setTitle("Grant Gaku Permissions")
                    .setMessage("Gaku uses optical character recognition (OCR) to detect text from images and works by automatically taking screenshots of your screen when active. After granting permissions, please restart Gaku.\n\nGaku works completely offline and WILL NEVER transmit ANY user data encountered during usage.")
                    .setPositiveButton("GRANT")
                    {
                        _, _ ->
                        run {
                            val prefs = context!!.getSharedPreferences(GAKU_PREF_FILE, Context.MODE_PRIVATE)
                            prefs.edit().putBoolean(GAKU_PREF_FIRST_LAUNCH, false).apply()

                            startActivity(Intent(activity, MainActivity::class.java))
                            (activity as FragmentActivity).finish()
                        }
                    }
                    .setNegativeButton("CANCEL")
                    {
                        _, _ ->
                        run {
                        }
                    }

            builder.create()

        } ?: throw IllegalStateException("Activity cannot be null")
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Dialogs/PlayStoreRatingDialogFragment.kt">
package ca.fuwafuwa.gaku.Dialogs

import android.app.AlertDialog
import android.app.Dialog
import android.os.Bundle
import androidx.fragment.app.DialogFragment
import android.widget.Toast
import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.net.Uri
import ca.fuwafuwa.gaku.GAKU_PREF_FILE
import ca.fuwafuwa.gaku.GAKU_PREF_PLAY_STORE_RATED


class PlayStoreRatingDialogFragment : DialogFragment()
{
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog
    {
        return activity?.let {

            val builder = AlertDialog.Builder(it)
            val prefs = requireContext().getSharedPreferences(GAKU_PREF_FILE, Context.MODE_PRIVATE)

            builder.setTitle("Thanks for your feedback!")
                    .setMessage("Would you like to rate the app in the Play Store? It would mean a lot to me and helps support the app!")
                    .setPositiveButton("OK")
                    {
                        _, _ ->
                        run {
                            launchMarket()
                            prefs.edit().putBoolean(GAKU_PREF_PLAY_STORE_RATED, true).apply()
                        }
                    }
                    .setNegativeButton("NO")
                    {
                        _, _ ->
                        run {
                        }
                    }
                    .setNeutralButton("NEVER ASK AGAIN")
                    {
                        _, _ ->
                        run {
                            prefs.edit().putBoolean(GAKU_PREF_PLAY_STORE_RATED, true).apply()
                        }
                    }

            builder.create()

        } ?: throw IllegalStateException("Activity cannot be null")
    }

    private fun launchMarket()
    {
        val uri = Uri.parse("market://details?id=" + requireActivity().packageName)
        val linkToMarket = Intent(Intent.ACTION_VIEW, uri)

        try
        {
            startActivity(linkToMarket)
        } catch (e: ActivityNotFoundException)
        {
            Toast.makeText(requireContext(), "Unable to launch Play Store", Toast.LENGTH_LONG).show()
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Dialogs/StarRatingDialogFragment.kt">
package ca.fuwafuwa.gaku.Dialogs

import android.app.AlertDialog
import android.app.Dialog
import android.content.Context
import android.os.Bundle
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import ca.fuwafuwa.gaku.GAKU_PREF_FILE
import ca.fuwafuwa.gaku.GAKU_PREF_PLAY_STORE_RATED
import ca.fuwafuwa.gaku.R

class StarRatingDialogFragment : DialogFragment()
{
    private var rating = 0

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog
    {
        return activity?.let {

            val builder = AlertDialog.Builder(it)

            val inflater = requireActivity().layoutInflater;
            val view = inflater.inflate(R.layout.dialog_rating_stars, null)

            val star1 = view.findViewById<TextView>(R.id.dialog_rating_star1)
            val star2 = view.findViewById<TextView>(R.id.dialog_rating_star2)
            val star3 = view.findViewById<TextView>(R.id.dialog_rating_star3)
            val star4 = view.findViewById<TextView>(R.id.dialog_rating_star4)
            val star5 = view.findViewById<TextView>(R.id.dialog_rating_star5)

            star1.setOnClickListener {
                star1.text = ""
                star2.text = ""
                star3.text = ""
                star4.text = ""
                star5.text = ""
                rating = 1
            }

            star2.setOnClickListener {
                star1.text = ""
                star2.text = ""
                star3.text = ""
                star4.text = ""
                star5.text = ""
                rating = 2
            }

            star3.setOnClickListener {
                star1.text = ""
                star2.text = ""
                star3.text = ""
                star4.text = ""
                star5.text = ""
                rating = 3
            }

            star4.setOnClickListener {
                star1.text = ""
                star2.text = ""
                star3.text = ""
                star4.text = ""
                star5.text = ""
                rating = 4
            }

            star5.setOnClickListener {
                star1.text = ""
                star2.text = ""
                star3.text = ""
                star4.text = ""
                star5.text = ""
                rating = 5
            }

            builder.setTitle("What do you think of Gaku?")
                    .setView(view)
                    .setPositiveButton("Ok")
                    {
                        _, _ ->
                        run {
                            if (rating == 5)
                            {
                                PlayStoreRatingDialogFragment().show(requireActivity().supportFragmentManager, "PlayStoreRating")
                            } else
                            {
                                val prefs = requireContext().getSharedPreferences(GAKU_PREF_FILE, Context.MODE_PRIVATE)
                                prefs.edit().putBoolean(GAKU_PREF_PLAY_STORE_RATED, true).apply()

                                FeedbackDialogFragment().show(requireActivity().supportFragmentManager, "Feedback")
                            }
                        }
                    }
                    .setNegativeButton("Cancel")
                    {
                        _, _ ->
                        run {
                        }
                    }

            builder.create()

        } ?: throw IllegalStateException("Activity cannot be null")
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Dialogs/TutorialExplainDialogFragment.kt">
package ca.fuwafuwa.gaku.Dialogs

import android.app.AlertDialog
import android.app.Dialog
import android.os.Bundle
import androidx.fragment.app.DialogFragment


class TutorialExplainDialogFragment : DialogFragment()
{
    private lateinit var mTitle : String
    private lateinit var mMessage : String

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog
    {
        mTitle = arguments?.getString(ARG_TITLE)!!
        mMessage = arguments?.getString(ARG_MESSAGE)!!

        return activity?.let {

            val builder = AlertDialog.Builder(it)

            builder.setTitle(mTitle)
                    .setMessage(mMessage)
                    .setPositiveButton("OK")
                    {
                        _, _ ->
                        run {
                        }
                    }

            builder.create()

        } ?: throw IllegalStateException("Activity cannot be null")
    }

    companion object
    {
        private val ARG_TITLE = "arg_title"
        private val ARG_MESSAGE = "arg_message"

        fun newInstance(title: String, message: String) : TutorialExplainDialogFragment
        {
            val dialog = TutorialExplainDialogFragment()
            val args = Bundle()
            args.putString(ARG_TITLE, title)
            args.putString(ARG_MESSAGE, message)
            dialog.arguments = args
            return dialog
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Exceptions/NotImplementedException.java">
package ca.fuwafuwa.gaku.Exceptions;

/**
 * Created by 0xbad1d3a5 on 12/1/2016.
 */

public class NotImplementedException extends RuntimeException {
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/interfaces/DictionaryViewModel.kt">
package ca.fuwafuwa.gaku.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import ca.fuwafuwa.gaku.data.Definition
import ca.fuwafuwa.gaku.data.Term
import ca.fuwafuwa.gaku.data.repository.DictionaryRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class DictionaryViewModel(private val repository: DictionaryRepository) : ViewModel() {

    // State for the list of words found (Headwords + Readings only)
    private val _searchResults = MutableStateFlow<List<Term>>(emptyList())
    val searchResults: StateFlow<List<Term>> = _searchResults

    fun search(query: String) {
        viewModelScope.launch {
            val results = repository.searchTerms(query)
            _searchResults.value = results
        }
    }

    /**
     * This is called when the RecyclerView/List binds a specific item,
     * or when the user expands a card.
     */
    fun loadDefinitionsForTerm(term: Term, onResult: (List<Definition>) -> Unit) {
        // Fix: Definitions are now embedded in the Term object, no DB call needed.
        onResult(term.definitions)
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Interfaces/Stoppable.java">
package ca.fuwafuwa.gaku.Interfaces;

/**
 * Created by 0xbad1d3a5 on 4/13/2016.
 */

public interface Stoppable {
    void stop();
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/legacy/core/DatabaseHelper.java">
package ca.fuwafuwa.gaku.legacy.core;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper;
import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.support.ConnectionSource;
import java.sql.SQLException;

public abstract class DatabaseHelper extends OrmLiteSqliteOpenHelper implements IDatabaseHelper {
    public DatabaseHelper(Context context, String databaseName, SQLiteDatabase.CursorFactory factory, int databaseVersion) {
        super(context, databaseName, factory, databaseVersion);
    }

    @Override
    public abstract void onCreate(SQLiteDatabase database, ConnectionSource connectionSource);

    @Override
    public abstract void onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion);

    public abstract void deleteDatabase();

    @Override
    public abstract <T> Dao<T, Integer> getDbDao(Class clazz) throws SQLException;
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/legacy/core/IDatabaseHelper.java">
package ca.fuwafuwa.gaku.legacy.core;

import com.j256.ormlite.dao.Dao;
import java.sql.SQLException;

public interface IDatabaseHelper {
    <T> Dao<T, Integer> getDbDao(Class clazz) throws SQLException;
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/legacy/furigana/PitchAccent.java">
package ca.fuwafuwa.gaku.legacy.furigana;

import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

@DatabaseTable(tableName = "pitch_accents")
public class PitchAccent {

    @DatabaseField(generatedId = true)
    private Integer id;

    @DatabaseField(columnName = "expression")
    private String expression; // The word (kanji or kana)

    @DatabaseField(columnName = "reading")
    private String reading; // The reading, usually kana

    @DatabaseField(columnName = "pitch_pattern")
    private String pitchPattern; // e.g., "0100"

    // Optional: JmDictFurigana might have other fields, but we focus on these for
    // now.

    public PitchAccent() {
    }

    public String getExpression() {
        return expression;
    }

    public String getReading() {
        return reading;
    }

    public String getPitchPattern() {
        return pitchPattern;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/legacy/furigana/PitchAccentDatabaseHelper.java">
package ca.fuwafuwa.gaku.legacy.furigana;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.table.TableUtils;

import java.sql.SQLException;

import ca.fuwafuwa.gaku.Constants;
import ca.fuwafuwa.gaku.legacy.core.DatabaseHelper;

public class PitchAccentDatabaseHelper extends DatabaseHelper {

    private static final String TAG = PitchAccentDatabaseHelper.class.getName();
    public static final String DATABASE_NAME = Constants.JM_DICT_FURIGANA_DATABASE_NAME;
    private static final int DATABASE_VERSION = 1;

    private static PitchAccentDatabaseHelper instance;
    private Context mContext;

    private PitchAccentDatabaseHelper(Context context) {
        // Path logic consistent with JmDatabaseHelper
        super(context, String.format("%s/%s", context.getFilesDir().getAbsolutePath(), DATABASE_NAME), null,
                DATABASE_VERSION);
        mContext = context;
    }

    public static synchronized PitchAccentDatabaseHelper instance(Context context) {
        if (instance == null) {
            instance = new PitchAccentDatabaseHelper(context);
        }
        return instance;
    }

    @Override
    public void onCreate(SQLiteDatabase database, ConnectionSource connectionSource) {
        // We expect this DB to be pre-populated or imported,
        // but if we need to create it from scratch:
        try {
            TableUtils.createTable(connectionSource, PitchAccent.class);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion) {
        // Migration logic
    }

    @Override
    public void deleteDatabase() {
        mContext.deleteDatabase(String.format("%s/%s", mContext.getFilesDir().getAbsolutePath(), DATABASE_NAME));
    }

    public Dao<PitchAccent, Integer> getPitchAccentDao() throws SQLException {
        return getDao(PitchAccent.class);
    }

    @Override
    public <T> Dao<T, Integer> getDbDao(Class clazz) throws SQLException {
        return getDao(clazz);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/legacy/jmdict/models/EntryOptimized.java">
package ca.fuwafuwa.gaku.legacy.jmdict.models;

import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

@DatabaseTable(tableName = "EntryOptimized")
public class EntryOptimized {
    @DatabaseField(generatedId = true)
    private int id;

    @DatabaseField(columnName = "kanji", index = true)
    public String kanji = "";

    @DatabaseField(columnName = "reading")
    public String readings = "";

    @DatabaseField(columnName = "pos")
    public String pos = "";

    @DatabaseField(columnName = "meanings")
    public String meanings = "";

    @DatabaseField(columnName = "priorities")
    public String priorities = "";

    @DatabaseField(columnName = "dictionary")
    public String dictionary = "";

    @DatabaseField(columnName = "isPrimaryEntry")
    public boolean isPrimaryEntry = false;

    public EntryOptimized() {}

    public String getKanji() { return kanji; }
    public String getReadings() { return readings; }
    public String getPos() { return pos; }
    public String getMeanings() { return meanings; }
    public String getPriorities() { return priorities; }
    public String getDictionary() { return dictionary; }
    public boolean isPrimaryEntry() { return isPrimaryEntry; }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/legacy/jmdict/JmDatabaseHelper.java">
package ca.fuwafuwa.gaku.legacy.jmdict;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;

import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.support.ConnectionSource;

import java.sql.SQLException;

import ca.fuwafuwa.gaku.Constants;
import ca.fuwafuwa.gaku.legacy.core.DatabaseHelper;

public class JmDatabaseHelper extends DatabaseHelper {
    private static final int DATABASE_VERSION = 1;
    private static JmDatabaseHelper instance;
    private final Context context;

    private JmDatabaseHelper(Context context) {
        super(context, Constants.JMDICT_DATABASE_NAME, null, DATABASE_VERSION);
        this.context = context;
    }

    public static synchronized JmDatabaseHelper instance(Context context) {
        if (instance == null) instance = new JmDatabaseHelper(context);
        return instance;
    }

    @Override
    public void onCreate(SQLiteDatabase database, ConnectionSource connectionSource) { }

    @Override
    public void onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion) { }

    @Override
    public void deleteDatabase() {
        context.deleteDatabase(Constants.JMDICT_DATABASE_NAME);
    }

    @Override
    public <T> Dao<T, Integer> getDbDao(Class clazz) throws SQLException {
        return getDao(clazz);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/legacy/kanjidict/models/CharacterOptimized.java">
package ca.fuwafuwa.gaku.legacy.kanjidict.models;

public class CharacterOptimized {
    public String literal = "";
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/legacy/user/UserDatabaseHelper.java">
package ca.fuwafuwa.gaku.legacy.user;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.table.TableUtils;

import java.sql.SQLException;

import ca.fuwafuwa.gaku.legacy.core.DatabaseHelper;

public class UserDatabaseHelper extends DatabaseHelper {

    private static final String TAG = UserDatabaseHelper.class.getName();
    private static final String DATABASE_NAME = "gaku_user_data.db";
    private static final int DATABASE_VERSION = 1;

    private static UserDatabaseHelper instance;
    private Context mContext;

    private UserDatabaseHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
        mContext = context;
    }

    public static synchronized UserDatabaseHelper instance(Context context) {
        if (instance == null) {
            instance = new UserDatabaseHelper(context);
        }
        return instance;
    }

    @Override
    public void onCreate(SQLiteDatabase database, ConnectionSource connectionSource) {
        try {
            TableUtils.createTable(connectionSource, UserWord.class);
            Log.i(TAG, "Created UserWord table");
        } catch (SQLException e) {
            Log.e(TAG, "Can't create database", e);
            throw new RuntimeException(e);
        }
    }

    @Override
    public void onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion) {
        try {
            TableUtils.dropTable(connectionSource, UserWord.class, true);
            onCreate(database, connectionSource);
        } catch (SQLException e) {
            Log.e(TAG, "Can't drop databases", e);
            throw new RuntimeException(e);
        }
    }

    @Override
    public void deleteDatabase() {
        mContext.deleteDatabase(DATABASE_NAME);
    }

    public Dao<UserWord, Integer> getUserWordDao() throws SQLException {
        return getDao(UserWord.class);
    }

    @Override
    public <T> Dao<T, Integer> getDbDao(Class clazz) throws SQLException {
        return getDao(clazz);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/legacy/user/UserWord.java">
package ca.fuwafuwa.gaku.legacy.user;

import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

@DatabaseTable(tableName = "UserWord")
public class UserWord {

    @DatabaseField(generatedId = true)
    private Integer id;

    @DatabaseField(uniqueCombo = true, index = true)
    private String text; // Surface form or Kanji

    @DatabaseField(uniqueCombo = true)
    private String reading; // Kana reading

    @DatabaseField
    private int status; // 0=Unknown, 1=Learning, 2=Known, 3=Mature, 4=Dismissed

    @DatabaseField
    private long timestamp; // For sync

    public static final int STATUS_UNKNOWN = 0;
    public static final int STATUS_LEARNING = 1;
    public static final int STATUS_KNOWN = 2;
    public static final int STATUS_MATURE = 3;
    public static final int STATUS_DISMISSED = 4;
    public static final int STATUS_DUE = 5;
    public static final int STATUS_MASTERED = 6;

    public UserWord() {
        // ORMLite needs a no-arg constructor
    }

    public UserWord(String text, String reading, int status) {
        this.text = text;
        this.reading = reading;
        this.status = status;
        this.timestamp = System.currentTimeMillis();
    }

    public Integer getId() {
        return id;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getReading() {
        return reading;
    }

    public void setReading(String reading) {
        this.reading = reading;
    }

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
        this.timestamp = System.currentTimeMillis();
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Logic/ReviewController.java">
package ca.fuwafuwa.gaku.Logic;

import android.content.Context;
import android.widget.Toast;

import androidx.preference.PreferenceManager;

import java.util.List;
import java.util.Map;

import ca.fuwafuwa.gaku.Analysis.ParsedWord;
import ca.fuwafuwa.gaku.legacy.user.UserWord;
import ca.fuwafuwa.gaku.Network.AnkiConnectClient;
import ca.fuwafuwa.gaku.Network.JitenApiClient;
import ca.fuwafuwa.gaku.Network.JpdbApiClient;
import ca.fuwafuwa.gaku.Network.JpdbDTOs;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

public class ReviewController {

    private final Context context;
    private final JitenApiClient jitenClient;
    private final JpdbApiClient jpdbClient;
    private final AnkiConnectClient ankiClient;

    public ReviewController(Context context) {
        this.context = context;
        this.jitenClient = JitenApiClient.getInstance(context);
        this.jpdbClient = JpdbApiClient.getInstance(context);
        this.ankiClient = AnkiConnectClient.getInstance(context);
    }

    public void sync() {
        String backend = PreferenceManager.getDefaultSharedPreferences(context)
                .getString("pref_parser_backend", "jiten");

        if ("jiten".equals(backend)) {
            jitenClient.sync((success, count) -> {
                runOnMain(success ? "Sync complete: " + count + " words updated" : "Sync failed");
            });
        } else if ("jpdb".equals(backend)) {
            runOnMain("Sync for JPDB is automatic (live). Ensure API Key is correct.");
        } else {
            runOnMain("Sync not available for offline mode.");
        }
    }

    public void mine(ParsedWord word) {
        String backend = PreferenceManager.getDefaultSharedPreferences(context)
                .getString("pref_parser_backend", "jiten");

        if ("jpdb".equals(backend)) {
            Map<String, Object> meta = word.getMetadata();
            if (meta != null && meta.containsKey("vid") && meta.containsKey("sid")) {
                int vid = (int) meta.get("vid");
                int sid = (int) meta.get("sid");
                // Default deck for mining in JPDB is usually user selected, but API takes Deck
                // ID.
                // jpd-breader uses specific logic. For now, let's trying adding to "learning"
                // deck equivalent?
                // Wait, jpd-breader uses deck IDs.
                // Assuming we want to add to "default" deck?
                // backend.ts uses addToDeckAPI with a deckId.
                // To keep it simple, we might need to ask user for Deck ID for JPDB too?
                // Or maybe just use a known deck like "global" or current deck?
                // "RequestMine" in background_comms calls `requestMine` which calls
                // `addToDeck`.
                // Actually `requestMine` calls `requestUnabortable({ type: 'mine' ... })`
                // In backend.ts line 49, `requestMine`.
                // It seems to fetch the deck?

                // Let's look at `addToDeck` in `backend.ts`. It takes `deckId`.
                // We'll trust the user has configured something, OR we might need to implement
                // deck fetch.
                // For this iteration, I'll log that deck selection is needed or try a default
                // if I can guess it.
                // Actually, let's fallback to "jiten" style for now: just toast?
                // NO, I implemented `addVocabulary`.
                // I'll try adding to deck id 1 (often default) or ask the user.
                // User didn't specify Deck ID for JPDB.
                // I will add a TOAST saying "JPDB Mining not fully configured" if I can't
                // guess.
                runOnMain("JPDB Mining: Deck ID selection not yet implemented.");
            }
        } else {
            // Jiten / Offline -> Anki
            openAnkiBrowser(word);
        }
    }

    public void setJpdbFlag(ParsedWord word, String flag, boolean remove) {
        String backend = PreferenceManager.getDefaultSharedPreferences(context)
                .getString("pref_parser_backend", "jiten");

        Map<String, Object> meta = word.getMetadata();
        if (meta == null)
            return;

        if ("jiten".equals(backend)) {
            if (meta.containsKey("wordId") && meta.containsKey("readingIndex")) {
                int wordId = (int) meta.get("wordId");
                int readingIndex = (int) meta.get("readingIndex");

                // Normalize flag for Jiten (never-forget -> neverForget)
                String jitenFlag = flag.replace("-f", "F");

                // If remove is true, we usually revert the state to "new" or 0
                if (remove) {
                    // Note: Check if your JitenApiClient/API supports a 'clear' or 'new' state
                    jitenClient.setVocabularyState(wordId, readingIndex, "new");
                } else {
                    jitenClient.setVocabularyState(wordId, readingIndex, jitenFlag);
                }
            }
        } else if ("jpdb".equals(backend)) {
            if (meta.containsKey("vid") && meta.containsKey("sid")) {
                int vid = (int) meta.get("vid");
                int sid = (int) meta.get("sid");

                // JPDB uses the "id" field in ModifyDeckRequest to determine the action
                // flag here should be "blacklist" or "never-forget"
                JpdbDTOs.ModifyDeckRequest req = new JpdbDTOs.ModifyDeckRequest(flag, vid, sid);

                // callJpdbModify handles add vs remove via the API endpoint used
                callJpdbModify(req, !remove);
            }
        }
    }

    private void callJpdbModify(JpdbDTOs.ModifyDeckRequest req, boolean add) {
        // Need to expose JpdbApiClient methods or get the api directly?
        // JpdbApiClient wraps JpdbApi. I should add methods to JpdbApiClient.
        // Assuming I added them to JpdbApi but not JpdbApiClient yet.
        // I need to update JpdbApiClient first.

        // For now, I'll use JpdbApiClient.getInstance().getApi() pattern?
        // No, JpdbApiClient is singleton and hides API.
        // I must add methods to JpdbApiClient.
    }

    public void grade(ParsedWord word, String grade) {
        String backend = PreferenceManager.getDefaultSharedPreferences(context)
                .getString("pref_parser_backend", "jiten");

        if ("jiten".equals(backend)) {
            int wordId = (int) word.getMetadata("wordId");
            int readingIndex = (int) word.getMetadata("readingIndex");

            int rating = 3; // Default Good
            switch (grade) {
                case "nothing":
                    rating = 1;
                    break;
                case "something":
                case "hard":
                    rating = 2;
                    break;
                case "good":
                    rating = 3;
                    break;
                case "easy":
                    rating = 4;
                    break;
            }

            JitenApiClient.getInstance(context).rateWord(wordId, readingIndex, rating);
        } else {
            openAnkiBrowser(word);
        }
    }

    private void openAnkiBrowser(ParsedWord word) {
        String query = "deck:\"" +
                PreferenceManager.getDefaultSharedPreferences(context).getString("anki_mining_deck", "Mining") +
                "\" " + word.getSurface();
        ankiClient.guiBrowse(query);
    }

    private void runOnMain(String message) {
        // Need a way to post to main thread if context is activity, or just Toast.
        // Toast can be shown from any thread if using Looper, but safely:
        android.os.Handler handler = new android.os.Handler(android.os.Looper.getMainLooper());
        handler.post(() -> Toast.makeText(context, message, Toast.LENGTH_SHORT).show());
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Network/AnkiConnectApi.java">
package ca.fuwafuwa.gaku.Network;

import retrofit2.Call;
import retrofit2.http.Body;
import retrofit2.http.POST;

public interface AnkiConnectApi {
    @POST("/")
    Call<AnkiConnectDTOs.Response<Object>> request(@Body AnkiConnectDTOs.Request request);
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Network/AnkiConnectClient.java">
package ca.fuwafuwa.gaku.Network;

import android.content.Context;
import android.util.Log;
import androidx.preference.PreferenceManager;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import okhttp3.OkHttpClient;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;

public class AnkiConnectClient {

    private static final String TAG = AnkiConnectClient.class.getSimpleName();
    private static AnkiConnectClient instance;
    private final Context context;
    private AnkiConnectApi api;
    private String currentUrl;

    private AnkiConnectClient(Context context) {
        this.context = context.getApplicationContext();
        ensureApi();
    }

    public static synchronized AnkiConnectClient getInstance(Context context) {
        if (instance == null) {
            instance = new AnkiConnectClient(context);
        }
        return instance;
    }

    private synchronized void ensureApi() {
        String url = PreferenceManager.getDefaultSharedPreferences(context)
                .getString("anki_connect_url", "http://10.0.2.2:8765");

        if (api == null || !url.equals(currentUrl)) {
            currentUrl = url;
            OkHttpClient client = new OkHttpClient.Builder()
                    .connectTimeout(5, TimeUnit.SECONDS)
                    .writeTimeout(5, TimeUnit.SECONDS)
                    .readTimeout(5, TimeUnit.SECONDS)
                    .build();

            // Ensure URL ends with slash
            if (!url.endsWith("/"))
                url += "/";

            try {
                Retrofit retrofit = new Retrofit.Builder()
                        .baseUrl(url)
                        .client(client)
                        .addConverterFactory(GsonConverterFactory.create())
                        .build();
                api = retrofit.create(AnkiConnectApi.class);
            } catch (Exception e) {
                Log.e(TAG, "Failed to create AnkiConnect client", e);
                api = null;
            }
        }
    }

    public void guiBrowse(String query) {
        ensureApi();
        if (api == null)
            return;

        Map<String, Object> params = new HashMap<>();
        params.put("query", query);

        api.request(new AnkiConnectDTOs.Request("guiBrowse", params))
                .enqueue(new Callback<AnkiConnectDTOs.Response<Object>>() {
                    @Override
                    public void onResponse(Call<AnkiConnectDTOs.Response<Object>> call,
                            Response<AnkiConnectDTOs.Response<Object>> response) {
                        if (response.isSuccessful()) {
                            Log.d(TAG, "guiBrowse success");
                        } else {
                            Log.e(TAG, "guiBrowse failed: " + response.code());
                        }
                    }

                    @Override
                    public void onFailure(Call<AnkiConnectDTOs.Response<Object>> call, Throwable t) {
                        Log.e(TAG, "guiBrowse error", t);
                    }
                });
    }

    public void findNotes(String query, Callback<AnkiConnectDTOs.Response<Object>> callback) {
        ensureApi();
        if (api == null)
            return;
        Map<String, Object> params = new HashMap<>();
        params.put("query", query);
        api.request(new AnkiConnectDTOs.Request("findNotes", params)).enqueue(callback);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Network/AnkiConnectDTOs.java">
package ca.fuwafuwa.gaku.Network;

import com.google.gson.annotations.SerializedName;
import java.util.Map;

public class AnkiConnectDTOs {

    public static class Request {
        @SerializedName("action")
        public String action;

        @SerializedName("version")
        public int version = 6;

        @SerializedName("params")
        public Map<String, Object> params;

        public Request(String action, Map<String, Object> params) {
            this.action = action;
            this.params = params;
        }
    }

    public static class Response<T> {
        @SerializedName("result")
        public T result;

        @SerializedName("error")
        public String error;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Network/JitenApi.java">
package ca.fuwafuwa.gaku.Network;

import java.util.List;
import ca.fuwafuwa.gaku.legacy.user.UserWord;
import retrofit2.Call;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.POST;
import retrofit2.http.Path;

/**
 * JitenApi defines the Retrofit interface for interacting with Jiten.moe
 * services.
 */
public interface JitenApi {

        @POST("/login")
        Call<LoginResponse> login(@Body LoginRequest request);

        // --- Reader Endpoints ---

        @POST("/api/reader/parse")
        Call<List<JitenDTOs.DeckWordDto>> parse(
                        @Header("Authorization") String token,
                        @Body JitenDTOs.ReaderParseRequest request);

        @POST("/api/reader/lookup-vocabulary")
        Call<List<Integer>> lookupVocabulary(
                        @Header("Authorization") String token,
                        @Body JitenDTOs.LookupVocabularyRequest request);

        // --- Vocabulary Endpoints ---

        @GET("/api/vocabulary/{wordId}/{readingIndex}")
        Call<JitenDTOs.WordDto> getWordDetails(
                        @Header("Authorization") String token,
                        @Path("wordId") int wordId,
                        @Path("readingIndex") int readingIndex);

        // --- SRS Endpoints ---

        @POST("/api/srs/review")
        Call<Void> review(
                        @Header("Authorization") String token,
                        @Body JitenDTOs.SrsReviewRequest request);

        @POST("/api/srs/set-vocabulary-state")
        Call<Void> setVocabularyState(
                        @Header("Authorization") String token,
                        @Body JitenDTOs.SetVocabularyStateRequest request);

        // --- Legacy / Sync Endpoints ---

        @GET("/user/words")
        Call<List<UserWord>> getWords(@Header("Authorization") String token);

        @POST("/user/words/sync")
        Call<SyncResponse> syncWords(
                        @Header("Authorization") String token,
                        @Body List<UserWord> words);

        /**
         * Data classes for authentication and sync
         */
        class LoginRequest {
                public String username;
                public String password;

                public LoginRequest(String u, String p) {
                        this.username = u;
                        this.password = p;
                }
        }

        class LoginResponse {
                public String token;
        }

        class SyncResponse {
                public boolean success;
                public int updated;
        }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Network/JitenApiClient.java">
package ca.fuwafuwa.gaku.Network;

import android.content.Context;
import android.util.Log;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.sql.SQLException;
import java.util.List;

import androidx.preference.PreferenceManager;

import ca.fuwafuwa.gaku.legacy.user.UserDatabaseHelper;
import ca.fuwafuwa.gaku.legacy.user.UserWord;
import okhttp3.OkHttpClient;
import okhttp3.logging.HttpLoggingInterceptor;
import retrofit2.Call;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;
import retrofit2.Callback;
import retrofit2.Response;

public class JitenApiClient {

    private static final String TAG = "JitenApiClient";
    private static JitenApiClient instance;

    private JitenApi api;
    private String authToken;
    private String baseUrl;
    private UserDatabaseHelper dbHelper;
    private Context mContext;

    public interface SyncCallback {
        void onSyncComplete(boolean success, int updatedCount);
    }

    private JitenApiClient(Context context) {
        mContext = context.getApplicationContext();
        baseUrl = PreferenceManager.getDefaultSharedPreferences(mContext).getString("jiten_api_url",
                "https://api.jiten.moe");
        authToken = PreferenceManager.getDefaultSharedPreferences(mContext).getString("jiten_api_key", "");

        if (!authToken.isEmpty() && !authToken.startsWith("Bearer ")) {
            authToken = "Bearer " + authToken;
        }

        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
        logging.setLevel(HttpLoggingInterceptor.Level.BODY);
        OkHttpClient client = new OkHttpClient.Builder()
                .addInterceptor(logging)
                .build();

        Gson gson = new GsonBuilder().setLenient().create();

        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(baseUrl)
                .client(client)
                .addConverterFactory(GsonConverterFactory.create(gson))
                .build();

        api = retrofit.create(JitenApi.class);
        dbHelper = UserDatabaseHelper.instance(mContext);
    }

    public void setVocabularyState(int wordId, int readingIndex, String state) {
        refreshSettings();
        if (authToken == null || authToken.isEmpty()) {
            return;
        }

        JitenDTOs.SetVocabularyStateRequest request = new JitenDTOs.SetVocabularyStateRequest();
        request.wordId = wordId;
        request.readingIndex = readingIndex;
        request.state = state;

        api.setVocabularyState(authToken, request).enqueue(new Callback<Void>() {
            @Override
            public void onResponse(Call<Void> call, Response<Void> response) {
                if (response.isSuccessful()) {
                    Log.d(TAG, "Jiten state updated: " + state);
                } else {
                    Log.e(TAG, "Failed to update Jiten state: " + response.code());
                }
            }

            @Override
            public void onFailure(Call<Void> call, Throwable t) {
                Log.e(TAG, "Jiten state update error", t);
            }
        });
    }

    public void rateWord(int wordId, int readingIndex, int rating) {
        refreshSettings();
        if (authToken == null || authToken.isEmpty()) {
            return;
        }

        JitenDTOs.SrsReviewRequest request = new JitenDTOs.SrsReviewRequest();
        request.wordId = wordId;
        request.readingIndex = readingIndex;
        request.rating = rating;

        api.review(authToken, request).enqueue(new Callback<Void>() {
            @Override
            public void onResponse(Call<Void> call, Response<Void> response) {
                if (response.isSuccessful()) {
                    Log.d(TAG, "Jiten SRS rating sent: " + rating);
                } else {
                    Log.e(TAG, "Failed to send Jiten SRS rating: " + response.code());
                }
            }

            @Override
            public void onFailure(Call<Void> call, Throwable t) {
                Log.e(TAG, "Jiten SRS rating error", t);
            }
        });
    }

    public static synchronized JitenApiClient getInstance(Context context) {
        if (instance == null) {
            instance = new JitenApiClient(context);
        }
        return instance;
    }

    private void refreshSettings() {
        String newBaseUrl = PreferenceManager.getDefaultSharedPreferences(mContext).getString("jiten_api_url",
                "https://api.jiten.moe");
        String newAuthToken = PreferenceManager.getDefaultSharedPreferences(mContext).getString("jiten_api_key", "");

        if (!newAuthToken.isEmpty() && !newAuthToken.startsWith("Bearer ")) {
            newAuthToken = "Bearer " + newAuthToken;
        }

        if (!newBaseUrl.equals(baseUrl)) {
            baseUrl = newBaseUrl;
            OkHttpClient client = new OkHttpClient.Builder().build();
            Retrofit retrofit = new Retrofit.Builder()
                    .baseUrl(baseUrl)
                    .client(client)
                    .addConverterFactory(GsonConverterFactory.create(new GsonBuilder().setLenient().create()))
                    .build();
            api = retrofit.create(JitenApi.class);
        }

        authToken = newAuthToken;
    }

    public void login(String username, String password, SyncCallback callback) {
        refreshSettings();
        api.login(new JitenApi.LoginRequest(username, password))
                .enqueue(new retrofit2.Callback<JitenApi.LoginResponse>() {
                    @Override
                    public void onResponse(Call<JitenApi.LoginResponse> call,
                            retrofit2.Response<JitenApi.LoginResponse> response) {
                        if (response.isSuccessful() && response.body() != null) {
                            authToken = "Bearer " + response.body().token;
                            // Save this token to preferences automatically
                            PreferenceManager.getDefaultSharedPreferences(mContext).edit()
                                    .putString("jiten_api_key", response.body().token).apply();
                            if (callback != null)
                                callback.onSyncComplete(true, 0);
                        } else {
                            if (callback != null)
                                callback.onSyncComplete(false, 0);
                        }
                    }

                    @Override
                    public void onFailure(Call<JitenApi.LoginResponse> call, Throwable t) {
                        if (callback != null)
                            callback.onSyncComplete(false, 0);
                    }
                });
    }

    public void sync(SyncCallback callback) {
        refreshSettings();
        if (authToken == null || authToken.isEmpty()) {
            if (callback != null)
                callback.onSyncComplete(false, 0);
            return;
        }

        try {
            List<UserWord> localWords = dbHelper.getUserWordDao().queryForAll();
            api.syncWords(authToken, localWords).enqueue(new retrofit2.Callback<JitenApi.SyncResponse>() {
                @Override
                public void onResponse(Call<JitenApi.SyncResponse> call,
                        retrofit2.Response<JitenApi.SyncResponse> response) {
                    if (response.isSuccessful()) {
                        fetchWordsFromServer(callback);
                    } else {
                        if (callback != null)
                            callback.onSyncComplete(false, 0);
                    }
                }

                @Override
                public void onFailure(Call<JitenApi.SyncResponse> call, Throwable t) {
                    if (callback != null)
                        callback.onSyncComplete(false, 0);
                }
            });
        } catch (SQLException e) {
            if (callback != null)
                callback.onSyncComplete(false, 0);
        }
    }

    private void fetchWordsFromServer(SyncCallback callback) {
        api.getWords(authToken).enqueue(new retrofit2.Callback<List<UserWord>>() {
            @Override
            public void onResponse(Call<List<UserWord>> call, retrofit2.Response<List<UserWord>> response) {
                if (response.isSuccessful() && response.body() != null) {
                    updateLocalDb(response.body());
                    if (callback != null)
                        callback.onSyncComplete(true, response.body().size());
                } else {
                    if (callback != null)
                        callback.onSyncComplete(false, 0);
                }
            }

            @Override
            public void onFailure(Call<List<UserWord>> call, Throwable t) {
                if (callback != null)
                    callback.onSyncComplete(false, 0);
            }
        });
    }

    private void updateLocalDb(List<UserWord> serverWords) {
        try {
            for (UserWord sw : serverWords) {
                UserWord lw = dbHelper.getUserWordDao().queryBuilder()
                        .where().eq("text", sw.getText()).and().eq("reading", sw.getReading()).queryForFirst();
                if (lw == null) {
                    dbHelper.getUserWordDao().create(sw);
                } else if (sw.getTimestamp() > lw.getTimestamp()) {
                    lw.setStatus(sw.getStatus());
                    lw.setTimestamp(sw.getTimestamp());
                    dbHelper.getUserWordDao().update(lw);
                }
            }
        } catch (SQLException e) {
            Log.e(TAG, "Update local DB failed", e);
        }
    }

    public List<JitenDTOs.DeckWordDto> parse(String text) throws java.io.IOException {
        refreshSettings();
        if (authToken == null || authToken.isEmpty()) {
            return null;
        }

        // Wrap the raw string into the DTO required by the new POST endpoint
        JitenDTOs.ReaderParseRequest request = new JitenDTOs.ReaderParseRequest(text);

        // Pass the request object instead of the raw text string
        retrofit2.Response<List<JitenDTOs.DeckWordDto>> response = api.parse(authToken, request).execute();

        if (response.isSuccessful()) {
            return response.body();
        }
        return null;
    }

    public JitenDTOs.WordDto getWordDetails(int wordId, int readingIndex) throws java.io.IOException {
        refreshSettings();
        if (authToken == null || authToken.isEmpty()) {
            return null;
        }
        retrofit2.Response<JitenDTOs.WordDto> response = api.getWordDetails(authToken, wordId, readingIndex).execute();
        if (response.isSuccessful()) {
            return response.body();
        }
        return null;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Network/JitenDTOs.java">
package ca.fuwafuwa.gaku.Network;

import java.util.Collections;
import java.util.List;

public class JitenDTOs {

    public static class ReaderParseRequest {
        public List<String> text;

        public ReaderParseRequest(String t) {
            this.text = java.util.Collections.singletonList(t);
        }
    }

    public static class LookupVocabularyRequest {
        public List<List<Integer>> words; // List of [wordId, readingIndex]
    }

    public static class SrsReviewRequest {
        public int wordId;
        public int readingIndex;
        public int rating; // 1: Again, 2: Hard, 3: Good, 4: Easy
    }

    public static class SetVocabularyStateRequest {
        public int wordId;
        public int readingIndex;
        public String state; // "blacklist" or "neverForget"
    }

    public static class DeckWordDto {
        public int wordId;
        public String originalText;
        public int readingIndex;
        // JitenReader uses these for positioning, but Gaku calculates its own Rects
    }

    public static class WordDto {
        public int wordId;
        public ReadingDto mainReading;
        public List<DefinitionDto> definitions;
        public List<Integer> pitchAccents;
        public List<Integer> knownStates; // [0: New, 1: Young, 2: Mature, 3: Blacklisted, 4: Due, 5: Mastered]
    }

    public static class ReadingDto {
        public String text;
    }

    public static class DefinitionDto {
        public List<String> meanings;
        public List<String> partsOfSpeech;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Network/JpdbApi.java">
package ca.fuwafuwa.gaku.Network;

import retrofit2.Call;
import retrofit2.http.Body;
import retrofit2.http.Header;
import retrofit2.http.POST;

public interface JpdbApi {

    @POST("/api/v1/parse")
    Call<JpdbDTOs.ParseResponse> parse(
            @Header("Authorization") String token,
            @Body JpdbDTOs.ParseRequest request);

    @POST("/api/v1/deck/add-vocabulary")
    Call<Void> addVocabulary(
            @Header("Authorization") String token,
            @Body JpdbDTOs.ModifyDeckRequest request);

    @POST("/api/v1/deck/remove-vocabulary")
    Call<Void> removeVocabulary(
            @Header("Authorization") String token,
            @Body JpdbDTOs.ModifyDeckRequest request);
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Network/JpdbApiClient.java">
package ca.fuwafuwa.gaku.Network;

import android.content.Context;
import androidx.preference.PreferenceManager;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import okhttp3.OkHttpClient;
import okhttp3.logging.HttpLoggingInterceptor;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;

public class JpdbApiClient {

    private static JpdbApiClient instance;
    private JpdbApi api;
    private String authToken;
    private Context context;

    private JpdbApiClient(Context context) {
        this.context = context.getApplicationContext();
        refreshSettings();
    }

    public static synchronized JpdbApiClient getInstance(Context context) {
        if (instance == null) {
            instance = new JpdbApiClient(context);
        }
        return instance;
    }

    private void refreshSettings() {
        authToken = PreferenceManager.getDefaultSharedPreferences(context).getString("jpdb_api_key", "");
        if (!authToken.isEmpty() && !authToken.startsWith("Bearer ")) {
            authToken = "Bearer " + authToken;
        }

        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
        logging.setLevel(HttpLoggingInterceptor.Level.BODY);
        OkHttpClient client = new OkHttpClient.Builder()
                .addInterceptor(logging)
                .build();

        Gson gson = new GsonBuilder().create();

        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://jpdb.io")
                .client(client)
                .addConverterFactory(GsonConverterFactory.create(gson))
                .build();

        api = retrofit.create(JpdbApi.class);
    }

    public JpdbDTOs.ParseResponse parse(String text) throws IOException {
        refreshSettings();
        if (authToken == null || authToken.isEmpty()) {
            return null;
        }

        JpdbDTOs.ParseRequest request = new JpdbDTOs.ParseRequest(
                Collections.singletonList(text),
                Arrays.asList(JpdbDTOs.TOKEN_FIELDS),
                Arrays.asList(JpdbDTOs.VOCAB_FIELDS_REQUEST));

        retrofit2.Response<JpdbDTOs.ParseResponse> response = api.parse(authToken, request).execute();
        if (response.isSuccessful()) {
            return response.body();
        }
        return null;

    }

    public boolean addVocabulary(JpdbDTOs.ModifyDeckRequest request) {
        refreshSettings();
        if (authToken == null || authToken.isEmpty())
            return false;
        try {
            return api.addVocabulary(authToken, request).execute().isSuccessful();
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public boolean removeVocabulary(JpdbDTOs.ModifyDeckRequest request) {
        refreshSettings();
        if (authToken == null || authToken.isEmpty())
            return false;
        try {
            return api.removeVocabulary(authToken, request).execute().isSuccessful();
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Network/JpdbDTOs.java">
package ca.fuwafuwa.gaku.Network;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class JpdbDTOs {

    public static class ModifyDeckRequest {
        public Object id; // Can be Integer or String (e.g., "blacklist", "never-forget")
        public List<List<Integer>> vocabulary;

        public ModifyDeckRequest(Object id, int vid, int sid) {
            this.id = id;
            this.vocabulary = Collections.singletonList(Arrays.asList(vid, sid));
        }
    }

    public static class ParseRequest {
        public List<String> text;
        public List<String> token_fields;
        public List<String> vocabulary_fields;

        public ParseRequest(List<String> text, List<String> token_fields, List<String> vocabulary_fields) {
            this.text = text;
            this.token_fields = token_fields;
            this.vocabulary_fields = vocabulary_fields;
        }
    }

    public static class ParseResponse {
        public List<List<List<Object>>> tokens; // [ [ [vocab_index, pos, len, furigana], ... ] ]
        public List<List<Object>> vocabulary; // [ [vid, sid, rid, ...], ... ]
    }

    // Helper to request fields
    public static final String[] TOKEN_FIELDS = { "vocabulary_index", "position", "length", "furigana" };
    public static final String[] VOCAB_FIELDS = {
            "vid", "sid", "rid", "spelling", "reading",
            "card_state", "meanings", "part_of_speech", "pitch_accent"
    };
    // Note: meanings_chunks in TS code, but swagger/logic implies meaning
    // structure.
    // Typescript used meanings_chunks and meanings_part_of_speech.
    // I should match TS usage for consistency if mimicking it:
    // "meanings_chunks", "meanings_part_of_speech"

    public static final String[] VOCAB_FIELDS_REQUEST = {
            "vid", "sid", "rid", "spelling", "reading",
            "card_state", "meanings_chunks", "meanings_part_of_speech", "pitch_accent", "due_at"
    };
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Ocr/BoxParams.java">
package ca.fuwafuwa.gaku.Ocr;

/**
 * Created by 0xbad1d3a5 on 4/16/2016.
 */
public final class BoxParams {

    public int x;
    public int y;
    public int width;
    public int height;

    public BoxParams(int x, int y, int width, int height){
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public String toString(){
        return String.format("X:%d Y:%d (%dx%d)", x, y, width, height);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Ocr/OcrCorrection.kt">
package ca.fuwafuwa.gaku.Ocr

class OcrCorrection
{
    companion object
    {
        val CommonLookalikes: List<List<String>> = listOf(

                // Hiragana
                listOf("", "", "", ""),
                listOf("", ""),
                listOf("", ""),
                listOf("", "", "z", "Z"),
                listOf("", "", "", ""),

                listOf("", "", "", "", "", ""),
                listOf("", "", "", ""),
                listOf("", "", "", "<", "", "("),
                listOf("", ""),
                listOf("", ""),

                listOf("", "", "", ""),
                listOf("", "", "L", "", "U"),
                listOf("", ""),
                listOf("", ""),
                listOf("", ""),

                listOf("", ""),
                listOf("", ""),
                listOf("", "", "", "", "", "", ""),
                listOf("", ""),
                listOf("", ""),

                listOf(""),
                listOf(""),
                listOf(""),
                listOf(""),
                listOf(""),

                listOf("", "", ""),
                listOf("", "", ""),
                listOf("", "", ""),
                listOf("", "", ""),
                listOf("", "", ""),

                listOf(""),
                listOf(""),
                listOf(""),
                listOf(""),
                listOf(""),

                listOf("", ""),
                listOf("", ""),
                listOf("", ""),

                listOf(""),
                listOf("", "", ""),
                listOf(""),
                listOf(""),
                listOf(""),

                listOf("", ""),
                listOf(""),
                listOf(""),

                // Katakana
                listOf("", ""),
                listOf("", ""),
                listOf("", "", "", "", "", "", ""),
                listOf("", ""),
                listOf("", ""),

                listOf("", "", "", "", "", ""),
                listOf("", ""),
                listOf("", "", ""),
                listOf("", "", ""),
                listOf("", ""),

                listOf("", ""),
                listOf("", "", ""),
                listOf("", "", ""),
                listOf("", ""),
                listOf("", ""),

                listOf("", "", ""),
                listOf("", ""),
                listOf("", "", ""),
                listOf("", ""),
                listOf("", "", ""),

                listOf(""),
                listOf(""),
                listOf("", ""),
                listOf(""),
                listOf(""),

                listOf("", "", "", ""),
                listOf("", "", "", ""),
                listOf("", "", "", "", ""), //, "\u31f7\u309a"),
                listOf("", "", "", ""),
                listOf("", "", "", ""),

                listOf(""),
                listOf(""),
                listOf("", ""),
                listOf(""),
                listOf(""),

                listOf("", ""),
                listOf("", ""),
                listOf("", ""),

                listOf("", ""),
                listOf("", "", ""),
                listOf("", ""),
                listOf("", ""),
                listOf("", "", ""),

                listOf("", "", "", "", "", "", ""),
                listOf(""),
                listOf(""),

                // Other
                listOf("", "", "", "", "", "", "-", "_", "|"),
                listOf("", "`", ""),
                listOf("", "o")
        )

        val CommonMistakes : List<Pair<List<String>, String>> = listOf(

                Pair(listOf("", "<", ""), ""),
                Pair(listOf("L", ""), ""),
                Pair(listOf("z", "Z"), ""),
                Pair(listOf("U"), ""),
                Pair(listOf("`", ""), ""),
                Pair(listOf("o"), ""),

                // Special cases for multiple mappings
                Pair(listOf("", "", "", "", "", "", "-", "_", "|"), "")
        )
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Ocr/OcrParams.kt">
package ca.fuwafuwa.gaku.Ocr

import android.graphics.Bitmap

data class OcrParams(val bitmap: Bitmap,
                     val originalBitmap: Bitmap,
                     val box: BoxParams,
                     val offsetX: Int,
                     val offsetY: Int,
                     val instantMode: Boolean)
{
    override fun toString() : String {
        return "Box: $box InstantOCR: $instantMode Offset: ($offsetX, $offsetY)"
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Ocr/OcrResult.kt">
package ca.fuwafuwa.gaku.Ocr

import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr

/**
 * Created by 0xbad1d3a5 on 5/2/2016.
 */
class OcrResult(val displayData: DisplayDataOcr,
                private val mOcrTime: Long)
{
    val text: String get() = displayData.text
    val message: String get() = String.format("OCR Time: %.2fs", mOcrTime / 1000.0)

    override fun toString(): String
    {
        return String.format("%s\nOcrTime: %d\nInstant: %b", text, mOcrTime, displayData.instantMode)
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Ocr/OcrRunnable.kt">
package ca.fuwafuwa.gaku.Ocr

import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.os.Message
import android.util.Log
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import com.google.android.gms.tasks.Tasks
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.japanese.JapaneseTextRecognizerOptions
import java.io.FileNotFoundException
import java.io.FileOutputStream
import java.util.concurrent.ExecutionException
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException
import ca.fuwafuwa.gaku.*
import ca.fuwafuwa.gaku.Interfaces.Stoppable
import ca.fuwafuwa.gaku.MainService
import ca.fuwafuwa.gaku.Windows.CaptureWindow
import ca.fuwafuwa.gaku.Windows.Data.ChoiceCertainty
import ca.fuwafuwa.gaku.Windows.Data.SquareCharOcr
import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr
import ca.fuwafuwa.gaku.Analysis.TextAnalyzer
import ca.fuwafuwa.gaku.Analysis.ParsedResult

class OcrRunnable(context: Context, private var mCaptureWindow: CaptureWindow?) : Runnable, Stoppable {
    private val mContext: MainService = context as MainService
    private val mOcrLock = java.lang.Object()
    private val mSimilarChars = loadSimilarChars()
    private val mCommonMistakes = loadCommonMistakes()
    private val mTextAnalyzer = TextAnalyzer(context)
    private var mTextRecognizer: com.google.mlkit.vision.text.TextRecognizer? = null
    private var mThreadRunning = true
    private var mOcrParams: OcrParams? = null
    private var mIsReady = false

    val isReadyForOcr: Boolean
    get() = mOcrParams == null

    init {
        mOcrParams = null
    }

    fun warmUp() {
        if (mIsReady) return

        Log.d(TAG, "Warming up OCR engine.")

        // safeInitClient returns true if successful, false if it crashed
        if (!safeInitClient()) {
            sendToastToContext("Failed to initialize MLKit (Check Logs)")
            return
        }

        // ML Kit requires input images to be at least 32x32 pixels.
        val dummyBitmap = Bitmap.createBitmap(32, 32, Bitmap.Config.ARGB_8888)
        val image = InputImage.fromBitmap(dummyBitmap, 0)

        // Force non-null assertion (!!) is safe here because safeInitClient returned true
        mTextRecognizer!!.process(image)
            .addOnSuccessListener {
                Log.d(TAG, "OCR engine is ready.")
                mIsReady = true
                sendModelReadyBroadcast()
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "OCR engine warm-up failed.", e)
                mIsReady = true // Mark ready anyway to unblock UI
                sendModelReadyBroadcast()
            }
    }

    private fun safeInitClient(): Boolean {
        if (mTextRecognizer != null) return true

        return try {
            val options = JapaneseTextRecognizerOptions.Builder().build()
            mTextRecognizer = TextRecognition.getClient(options)
            true
        } catch (e: Throwable) {
            // This catch block is CRITICAL. It catches UnsatisfiedLinkError (Native crash)
            // and standard Exceptions, printing them to Logcat so you can finally see them.
            Log.e(TAG, "CRITICAL ERROR: Could not create TextRecognition client", e)
            e.printStackTrace()
            false
        }
    }

    private fun sendModelReadyBroadcast() {
        val intent = Intent(ACTION_MODEL_READY)
        LocalBroadcastManager.getInstance(mContext).sendBroadcast(intent)
    }

    override fun run() {
        // 1. Initialize safely on the background thread.
        // If this fails, we exit the thread to prevent a crash loop.
        if (!safeInitClient()) {
            Log.e(TAG, "Stopping OcrRunnable because OCR Client failed to initialize.")
            return
        }

        while (mThreadRunning) {
            try {
                synchronized(mOcrLock) {
                    if (mOcrParams == null) {
                        mOcrLock.wait()
                    }

                    if (!mThreadRunning) return

                    // Local capture to ensure thread safety
                    val ocrParams = mOcrParams
                    // Safely unwrap the recognizer (we know it's not null due to safeInitClient)
                    val recognizer = mTextRecognizer

                    if (ocrParams != null && recognizer != null) {
                        Log.d(TAG, "Processing OCR with params $ocrParams")
                        val startTime = System.currentTimeMillis()
                        mCaptureWindow?.showLoadingAnimation()

                        try {
                            // 2. Prepare the InputImage
                            val image = InputImage.fromBitmap(ocrParams.bitmap, 0)

                            // 3. Process blocking (Tasks.await is safe here in background thread)
                            val result = Tasks.await(recognizer.process(image), 10, TimeUnit.SECONDS)

                            val displayData = getDisplayData(ocrParams, result)
                            processDisplayData(displayData)

                            val ocrTime = System.currentTimeMillis() - startTime
                            val parsedResult = mTextAnalyzer.analyze(result, displayData, ocrTime)

                            if (displayData.text.isNotEmpty()) {
                                sendOcrResultToContext(parsedResult)
                            } else {
                                sendToastToContext("No Characters Recognized.")
                            }
                        } catch (e: Exception) {
                            when (e) {
                                is ExecutionException, is InterruptedException, is TimeoutException -> {
                                    Log.e(TAG, "OCR failed", e)
                                    sendToastToContext("OCR Failed: ${e.message}")
                                }
                                else -> {
                                    Log.e(TAG, "Unexpected OCR Error", e)
                                    // Don't throw; just log so the thread keeps living
                                }
                            }
                        } finally {
                            mCaptureWindow?.stopLoadingAnimation(ocrParams.instantMode)
                            mOcrParams = null
                        }
                    }
                }
            } catch (e: InterruptedException) {
                Log.d(TAG, "OcrRunnable interrupted, shutting down.")
                mThreadRunning = false
            } catch (e: Exception) {
                // Catch global exceptions to keep the thread alive
                Log.e(TAG, "General Error in OcrRunnable Loop", e)
                e.printStackTrace()
            }
        }

        Log.d(TAG, "THREAD STOPPED")
        mTextRecognizer?.close()
    }

    fun runTess(ocrParams: OcrParams) {
        synchronized(mOcrLock) {
            if (!mThreadRunning) return
            mOcrParams = ocrParams
            mOcrLock.notify()
            Log.d(TAG, "NOTIFIED")
        }
    }

    fun cancel() {
        Log.d(TAG, "CANCELED (Not implemented for ML Kit)")
    }

    override fun stop() {
        synchronized(mOcrLock) {
            mThreadRunning = false
            mCaptureWindow = null
            mOcrParams = null
            mOcrLock.notify()
        }
    }

    private fun processDisplayData(displayData: DisplayDataOcr) {
        val squareChars = displayData.squareChars.filterIsInstance<SquareCharOcr>()
        for (squareChar in squareChars) {
            mSimilarChars[squareChar.char]?.forEach {
                squareChar.addChoice(it, ChoiceCertainty.UNCERTAIN)
            }
        }

        for (squareChar in squareChars) {
            correctCommonMistake(squareChar, "")
            correctCommonMistake(squareChar, "")
            correctCommonMistake(squareChar, "")
            correctCommonMistake(squareChar, "")
            correctCommonMistake(squareChar, "")
            correctCommonMistake(squareChar, "")
            correctKanjiOne(squareChar)
            correctKatakanaDash(squareChar)
        }
    }

    private fun correctCommonMistake(squareChar: SquareCharOcr, char: String) {
        if (mCommonMistakes[squareChar.char] == char) {
            val prev = squareChar.prev
            val next = squareChar.next
            if (prev?.char?.let { LangUtils.IsJapaneseChar(it[0]) } == true ||
                next?.char?.let { LangUtils.IsJapaneseChar(it[0]) } == true) {
                squareChar.addChoice(char, ChoiceCertainty.CERTAIN)
            }
        }
    }

    private fun correctKatakanaDash(squareChar: SquareCharOcr) {
        if (mCommonMistakes[squareChar.char] != null) {
            val prev = squareChar.prev
            if (prev?.char?.let { LangUtils.IsKatakana(it[0]) } == true) {
                squareChar.addChoice("", ChoiceCertainty.CERTAIN)
            }
        }
    }

    private fun correctKanjiOne(squareChar: SquareCharOcr) {
        if (mCommonMistakes[squareChar.char] != null) {
            val next = squareChar.next
            if (next?.char?.let { LangUtils.IsKanji(it[0]) || LangUtils.IsHiragana(it[0]) } == true) {
                squareChar.addChoice("", ChoiceCertainty.CERTAIN)
            }
        }
    }

    private fun getDisplayData(ocrParams: OcrParams, visionText: Text): DisplayDataOcr {
        val bitmap = ocrParams.originalBitmap
        val boxParams = ocrParams.box
        val ocrChars = ArrayList<SquareCharOcr>()
        val displayData = DisplayDataOcr(bitmap, boxParams, ocrParams.instantMode, ocrChars)

        // 1. Sort the BLOCKS, not the individual symbols.
        // This preserves the internal Left-to-Right order of horizontal text,
        // while still ordering the blocks themselves in Japanese/Manga order (Right-to-Left, Top-to-Bottom).
        val sortedBlocks = visionText.textBlocks.sortedWith(Comparator { a, b ->
            val rectA = a.boundingBox ?: return@Comparator 0
            val rectB = b.boundingBox ?: return@Comparator 0

            // If blocks are vertically aligned (similar X coordinates), sort Top-to-Bottom.
            // If they are horizontally separated, sort Right-to-Left (Manga style).
            val threshold = 20 

            if (Math.abs(rectA.left - rectB.left) > threshold) {
                // Right to Left (Manga Columns)
                rectB.left - rectA.left
            } else {
                // Top to Bottom (Standard Rows)
                rectA.top - rectB.top
            }
        })

        // 2. Iterate through hierarchy to collect symbols in the correct order
        for (block in sortedBlocks) {
            for (line in block.lines) {
                for (element in line.elements) {
                    for (symbol in element.symbols) {
                        
                        val choices = ArrayList<Pair<String, Double>>()
                        choices.add(Pair(symbol.text, symbol.confidence.toDouble()))

                        val pos = symbol.boundingBox ?: android.graphics.Rect()

                        // Calculate relative position to the original full-screen bitmap
                        ocrChars.add(SquareCharOcr(
                            displayData,
                            choices,
                            intArrayOf(
                                pos.left + ocrParams.offsetX, 
                                pos.top + ocrParams.offsetY, 
                                pos.right + ocrParams.offsetX, 
                                pos.bottom + ocrParams.offsetY
                            )
                        ))
                    }
                }
            }
        }

        displayData.assignIndicies()
        return displayData
    }

    private fun loadSimilarChars(): Map<String, List<String>> {
        val similarChars = HashMap<String, MutableList<String>>()
        for (list in OcrCorrection.CommonLookalikes) {
            for ((index, kana) in list.withIndex()) {
                if (list.size <= 1) continue

                val others = list.toMutableList().apply { removeAt(index) }
                val existing = similarChars.getOrPut(kana) { mutableListOf() }
                others.forEach {
                    if (!existing.contains(it)) {
                        existing.add(it)
                    }
                }
            }
        }
        return similarChars
    }

    private fun loadCommonMistakes(): HashMap<String, String> {
        val commonMistakes = HashMap<String, String>()
        for (pair in OcrCorrection.CommonMistakes) {
            for (c in pair.first) {
                commonMistakes[c] = pair.second
            }
        }
        return commonMistakes
    }

    private fun sendOcrResultToContext(result: Any) {
        Message.obtain(mContext.handler, 0, result).sendToTarget()
    }

    private fun sendToastToContext(message: String) {
        Message.obtain(mContext.handler, 0, message).sendToTarget()
    }

    @Throws(FileNotFoundException::class)
    private fun saveBitmap(bitmap: Bitmap, name: String = "screen") {
        try {
            val fs = "${mContext.filesDir.absolutePath}/$SCREENSHOT_FOLDER_NAME/${name}_${System.nanoTime()}.png"
            Log.d(TAG, fs)
            FileOutputStream(fs).use {
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, it)
            }
        } catch(e: Exception) {
            Log.e(TAG, "Failed to save bitmap", e)
        }
    }

    companion object {
        private val TAG = OcrRunnable::class.java.name
        const val ACTION_MODEL_READY = "ca.fuwafuwa.gaku.MODEL_READY"
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/repository/DictionaryRepository.kt">
package ca.fuwafuwa.gaku.data.repository

import android.content.Context
import ca.fuwafuwa.gaku.Deinflictor.DeinflectionInfo
import ca.fuwafuwa.gaku.Deinflictor.Deinflector
import ca.fuwafuwa.gaku.data.AppDatabase
import ca.fuwafuwa.gaku.data.Definition
import ca.fuwafuwa.gaku.data.Term
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class DictionaryRepository(private val db: AppDatabase, context: Context? = null) {

    // Cache active dictionary IDs to avoid DB lookups on every keystroke
    private var activeDictIds: List<Long> = emptyList()
    private val deinflector: Deinflector? = context?.let { Deinflector(it) }

    suspend fun refreshActiveDictionaries() = withContext(Dispatchers.IO) {
        activeDictIds = db.dictionaryDao().getAllDictionaries()
            .filter { it.isEnabled }
            .map { it.id }
    }

    suspend fun searchTerms(rawQuery: String): List<Term> = withContext(Dispatchers.IO) {
        if (activeDictIds.isEmpty()) refreshActiveDictionaries()

        val deinflectionResults = getPotentialForms(rawQuery)
        val potentialForms = deinflectionResults.map { it.word }.distinct()

        val matches = db.termDao().findTermsByVariants(potentialForms, activeDictIds)
        return@withContext filterMatchesByDeinflection(matches, deinflectionResults)
    }

    // REMOVED: getDefinitions(termId). The definitions are now in the Term object.

    private fun getPotentialForms(text: String): List<DeinflectionInfo> {
        val real = deinflector?.getPotentialDeinflections(text)
        if (!real.isNullOrEmpty()) return real

        // Fallback for environments where Deinflector cannot be initialized yet.
        return listOf(DeinflectionInfo(text, 0xFF, ""))
    }

    private fun filterMatchesByDeinflection(
        terms: List<Term>,
        deinflections: List<DeinflectionInfo>
    ): List<Term> {
        val byWord = deinflections.groupBy { it.word }

        return terms.filter { term ->
            val candidates = byWord[term.expression].orEmpty() + byWord[term.reading].orEmpty()
            if (candidates.isEmpty()) {
                false
            } else {
                candidates.any { deinf -> validateDeinflectionType(term.rules, deinf.type) }
            }
        }
    }

    private fun validateDeinflectionType(termRules: String, deinfType: Int): Boolean {
        if (deinfType == 0xFF || termRules.isBlank()) return true

        val normalizedRules = termRules.split(" ", ",")
            .map { it.trim().lowercase() }
            .filter { it.isNotBlank() }

        if (normalizedRules.isEmpty()) return true

        val isV1 = normalizedRules.any { it == "v1" }
        val isV5 = normalizedRules.any { it.startsWith("v5") }
        val isAdjI = normalizedRules.any { it == "adj-i" }
        val isVk = normalizedRules.any { it == "vk" }
        val isVs = normalizedRules.any { it.startsWith("vs") }

        return ((deinfType and 1) != 0 && isV1) ||
            ((deinfType and 2) != 0 && isV5) ||
            ((deinfType and 4) != 0 && isAdjI) ||
            ((deinfType and 8) != 0 && isVk) ||
            ((deinfType and 16) != 0 && isVs)
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Search/JmSearchResult.kt">
package ca.fuwafuwa.gaku.Search

import ca.fuwafuwa.gaku.legacy.jmdict.models.EntryOptimized
import ca.fuwafuwa.gaku.Deinflictor.DeinflectionInfo

data class JmSearchResult(
        val entry: EntryOptimized,
        val deinfInfo: DeinflectionInfo,
        val word: String
)
</file>

<file path="main/java/ca/fuwafuwa/gaku/Search/JmTask.kt">
package ca.fuwafuwa.gaku.Search

import android.content.Context
import android.os.AsyncTask
import android.util.Log
import ca.fuwafuwa.gaku.DB_JMDICT_NAME
import ca.fuwafuwa.gaku.DB_KANJIDICT_NAME
import ca.fuwafuwa.gaku.legacy.jmdict.JmDatabaseHelper
import ca.fuwafuwa.gaku.legacy.jmdict.models.EntryOptimized
import ca.fuwafuwa.gaku.Deinflictor.DeinflectionInfo
import ca.fuwafuwa.gaku.Deinflictor.Deinflector
import java.sql.SQLException
import java.util.ArrayList
import kotlin.collections.HashSet
import kotlin.collections.List
import kotlin.collections.filter
import kotlin.collections.sortedWith

/**
 * Created by 0xbad1d3a5 on 12/16/2016.
 */

class JmTask @Throws(SQLException::class)
constructor(private val mSearchInfo: SearchInfo, private val mSearchJmTaskDone: SearchJmTaskDone, context: Context) : AsyncTask<Void, Void, List<JmSearchResult>>()
{
    companion object
    {
        private val TAG = JmTask::class.java.getName()
    }

    private val mJmDbHelper: JmDatabaseHelper = JmDatabaseHelper.instance(context)
    private val mDeinflector: Deinflector = Deinflector(context)

    interface SearchJmTaskDone
    {
        fun jmTaskCallback(results: List<JmSearchResult>, searchInfo: SearchInfo)
    }

    override fun doInBackground(vararg params: Void): List<JmSearchResult>
    {
        val text = mSearchInfo.text
        val textOffset = mSearchInfo.textOffset
        val entryOptimizedDao = mJmDbHelper.getDbDao<EntryOptimized>(EntryOptimized::class.java)

        val startDictTime = System.currentTimeMillis()
        var character = String(intArrayOf(text.codePointAt(textOffset)), 0, 1)

        // What the flying fuck? Wasn't the entire point of using an ORM is so shit would be escaped for me?
        character = character.replace("%", "\\%")
        character = character.replace("_", "\\_")
        character = character.replace("'", "''")

        val entries: List<EntryOptimized> = entryOptimizedDao.queryBuilder().where().like("kanji", "$character%").query()
        val matchedEntries = rankResults(getMatchedEntries(text, textOffset, entries))
        Log.d(TAG, "Dict lookup time: ${System.currentTimeMillis() - startDictTime}")

        return matchedEntries
    }

    override fun onPostExecute(result: List<JmSearchResult>)
    {
        mSearchJmTaskDone.jmTaskCallback(result, mSearchInfo)
    }

    @Throws(SQLException::class)
    private fun getMatchedEntries(text: String, textOffset: Int, entries: List<EntryOptimized>): List<JmSearchResult>
    {
        val end = if (textOffset + 80 >= text.length) text.length else textOffset + 80
        var word = text.substring(textOffset, end)
        val seenEntries = HashSet<EntryOptimized>()
        val results = ArrayList<JmSearchResult>()

        while (word.isNotEmpty())
        {
            // Find deinflections and add them
            val deinfResultsList: List<DeinflectionInfo> = mDeinflector.getPotentialDeinflections(word)
            var count = 0
            for (deinfInfo in deinfResultsList)
            {
                val filteredEntry: List<EntryOptimized> = entries.filter { entry -> entry.kanji == deinfInfo.word }

                if (filteredEntry.isEmpty())
                {
                    continue
                }

                for (entry in filteredEntry){

                    if (seenEntries.contains(entry)){
                        continue
                    }

                    var valid = true

                    if (count > 0)
                    {
                        valid = (deinfInfo.type and 1 != 0) && (entry.pos.contains("v1")) ||
                                (deinfInfo.type and 2 != 0) && (entry.pos.contains("v5")) ||
                                (deinfInfo.type and 4 != 0) && (entry.pos.contains("adj-i")) ||
                                (deinfInfo.type and 8 != 0) && (entry.pos.contains("vk")) ||
                                (deinfInfo.type and 16 != 0) && (entry.pos.contains("vs-"))
                    }

                    if (valid){
                        results.add(JmSearchResult(entry, deinfInfo, word))
                        seenEntries.add(entry)
                    }

                    count++
                }
            }

            // Add all exact matches as well
            val filteredEntry: List<EntryOptimized> = entries.filter { entry -> entry.kanji == word }
            for (entry in filteredEntry)
            {
                if (seenEntries.contains(entry))
                {
                    continue
                }

                results.add(JmSearchResult(entry, DeinflectionInfo(word, 0, ""), word))
                seenEntries.add(entry)
            }

            word = word.substring(0, word.length - 1)
        }

        return results
    }

    private fun rankResults(results: List<JmSearchResult>) : List<JmSearchResult>
    {
        return results.sortedWith(compareBy(
                { getDictPriority(it) },
                { 0 - it.entry.kanji.length },
                { getEntryPriority(it) },
                { getPriority(it) }))
    }

    private fun getDictPriority(result: JmSearchResult) : Int
    {
        return when
        {
            result.entry.dictionary == DB_JMDICT_NAME -> Int.MAX_VALUE - 2
            result.entry.dictionary == DB_KANJIDICT_NAME -> Int.MAX_VALUE - 1
            else -> Int.MAX_VALUE
        }
    }

    private fun getEntryPriority(result: JmSearchResult) : Int
    {
        return if (result.entry.isPrimaryEntry) 0 else 1
    }

    private fun getPriority(result: JmSearchResult) : Int
    {
        val priorities = result.entry.priorities.split(",")
        var lowestPriority = Int.MAX_VALUE

        for (priority in priorities){

            var pri = Int.MAX_VALUE

            if (priority.contains("nf")){ // looks like the range is nf01-nf48
                pri = priority.substring(2).toInt()
            }
            else if (priority == "news1"){
                pri = 60
            }
            else if (priority == "news2"){
                pri = 70
            }
            else if (priority == "ichi1"){
                pri = 80
            }
            else if (priority == "ichi2"){
                pri = 90
            }
            else if (priority == "spec1"){
                pri = 100
            }
            else if (priority == "spec2"){
                pri = 110
            }
            else if (priority == "gai1"){
                pri = 120
            }
            else if (priority == "gai2"){
                pri = 130
            }

            lowestPriority = if (pri < lowestPriority) pri else lowestPriority
        }

        return lowestPriority
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Search/Kd2Task.kt">
package ca.fuwafuwa.gaku.Search

import android.content.Context
import android.os.AsyncTask
import ca.fuwafuwa.gaku.data.AppDatabase
import ca.fuwafuwa.gaku.data.Kanji

/**
 * Migrated to use Room (AppDatabase) instead of the old ORMLite Kd2DatabaseHelper.
 */
class Kd2Task(
    private val mSearchInfo: SearchInfo,
    private val mSearchKd2TaskDone: SearchKd2TaskDone,
    context: Context
) : AsyncTask<Void, Void, List<Kanji>>() {

    companion object {
        private val TAG = Kd2Task::class.java.name
    }

    private val db: AppDatabase = AppDatabase.getDatabase(context)

    interface SearchKd2TaskDone {
        fun kd2TaskCallback(results: List<Kanji>, searchInfo: SearchInfo)
    }

    override fun doInBackground(vararg params: Void): List<Kanji> {
        val text = mSearchInfo.text
        val textOffset = mSearchInfo.textOffset

        // Extract the specific character from the text string
        val charCode = text.codePointAt(textOffset)
        val character = String(intArrayOf(charCode), 0, 1)

        // 1. Get Active Dictionary IDs
        // In the new architecture, we must know which dictionaries to search.
        // We fetch enabled dictionaries first.
        val activeDictIds = db.dictionaryDao().getAllDictionaries()
            .filter { it.isEnabled }
            .map { it.id }

        if (activeDictIds.isEmpty()) {
            return emptyList()
        }

        // 2. Query the KanjiDao using the new method signature
        return db.kanjiDao().findKanji(character, activeDictIds)
    }

    override fun onPostExecute(result: List<Kanji>) {
        mSearchKd2TaskDone.kd2TaskCallback(result, mSearchInfo)
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Search/Searcher.java">
package ca.fuwafuwa.gaku.Search;

import android.content.Context;
import android.os.AsyncTask;
import android.util.Log;

import org.jetbrains.annotations.NotNull;

import java.sql.SQLException;
import java.util.List;

import ca.fuwafuwa.gaku.legacy.jmdict.models.EntryOptimized;
import ca.fuwafuwa.gaku.legacy.kanjidict.models.CharacterOptimized;

/**
 * Created by 0xbad1d3a5 on 8/28/2016.
 */
public class Searcher implements JmTask.SearchJmTaskDone {

    public interface SearchDictDone
    {
        void jmResultsCallback(List<JmSearchResult> results, SearchInfo search);
    }

    private static final String TAG = Searcher.class.getName();

    private SearchDictDone mSearchDictDone;
    private Context mContext;

    public Searcher(Context context) throws SQLException
    {
        mContext = context;
    }

    public void registerCallback(SearchDictDone dictDone)
    {
        this.mSearchDictDone = dictDone;
    }

    public void unregisterCallback()
    {
        this.mSearchDictDone = null;
    }

    public void search(SearchInfo searchInfo)
    {
        try {
            new JmTask(searchInfo, this, mContext).executeOnExecutor(AsyncTask.SERIAL_EXECUTOR);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void jmTaskCallback(@NotNull List<JmSearchResult> results, @NotNull SearchInfo searchInfo)
    {
        mSearchDictDone.jmResultsCallback(results, searchInfo);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Search/SearchInfo.kt">
package ca.fuwafuwa.gaku.Search

import ca.fuwafuwa.gaku.Windows.Data.DisplayData
import ca.fuwafuwa.gaku.Windows.Data.ISquareChar
import ca.fuwafuwa.gaku.Windows.Views.KanjiCharacterView

/**
 * Created by 0xbad1d3a5 on 12/16/2016.
 */

class SearchInfo(val squareChar: ISquareChar)
{
    val text: String get() = squareChar.displayData.text

    val textOffset: Int
        get() {
            var index = 0

            for (char in squareChar.displayData.squareChars)
            {
                if (char === squareChar)
                {
                    break
                }
                index += char.char.length
            }

            return index
        }

    val index: Int get() = squareChar.index
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Data/DisplayData.kt">
package ca.fuwafuwa.gaku.Windows.Data

import android.graphics.Bitmap
import ca.fuwafuwa.gaku.Ocr.BoxParams
import ca.fuwafuwa.gaku.splitTextByChar

open class DisplayData(var squareChars: List<ISquareChar>)
{
    open var instantMode = false

    val text: String
        get()
        {
            val sb = StringBuilder()

            for (char in squareChars)
            {
                sb.append(char.char)
            }

            return sb.toString()
        }

    val count: Int
        get()
        {
            return squareChars.size
        }

    fun recomputeChars()
    {
        val newSquareChars = mutableListOf<ISquareChar>()

        for (squareChar in squareChars)
        {
            val newChars = squareChar.text ?: squareChar.char
            squareChar.text = null

            when
            {
                newChars.length > 1 ->
                {
                    val newCharsList = splitTextByChar(newChars)

                    for (newChar in newCharsList)
                    {
                        val newSquareChar = squareChar.clone()
                        newSquareChar.char = newChar
                        addOcrChoice(newSquareChar, newChar)

                        newSquareChars.add(newSquareChar)
                    }
                }
                newChars.length == 1 ->
                {
                    if (newChars != squareChar.char)
                    {
                        squareChar.char = newChars
                        addOcrChoice(squareChar, newChars)
                    }
                    newSquareChars.add(squareChar)
                }
                newChars.length == 0 ->
                {
                    // character was deleted
                }
            }
        }

        squareChars = newSquareChars
        assignIndicies()
    }

    fun assignIndicies()
    {
        for ((index, squareChars) in squareChars.withIndex())
        {
            squareChars.index = index
        }
    }

    private fun addOcrChoice(squareChar: ISquareChar, choice: String)
    {
        if (squareChar is SquareCharOcr)
        {
            squareChar.addChoice(choice, ChoiceCertainty.CERTAIN)
        }
    }
}

class DisplayDataOcr(val bitmap: Bitmap,
                     val boxParams: BoxParams,
                     override var instantMode: Boolean,
                     squareChars: List<SquareCharOcr>) : DisplayData(squareChars)
{
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Data/SquareChar.kt">
package ca.fuwafuwa.gaku.Windows.Data

interface ISquareChar
{
    var index: Int

    var char: String

    var text: String?

    var prev: ISquareChar?

    var next: ISquareChar?

    var userTouched: Boolean

    val displayData: DisplayData

    fun clone() : ISquareChar
}

open class SquareChar(override val displayData: DisplayData,
                      override var char: String) : ISquareChar
{
    override var index: Int = -1

    override var userTouched: Boolean = false

    override var text : String? = null
    get()
    {
        val returnText = field
        field = null
        return returnText
    }

    override var prev : ISquareChar? = null
    get()
    {
        return if (index == 0)
        {
            null
        }
        else
        {
            displayData.squareChars[index - 1]
        }
    }

    override var next: ISquareChar? = null
    get()
    {
        return if (index == displayData.count - 1)
        {
            null
        }
        else
        {
            displayData.squareChars[index + 1]
        }
    }

    override fun clone(): ISquareChar
    {
        return SquareChar(displayData, char)
    }
}

class SquareCharOcr(override val displayData: DisplayDataOcr,
                    val allChoices : MutableList<Pair<String, Double>>,
                    val bitmapPos: IntArray) : SquareChar(displayData, "")
{
    override var char : String = ""

    init
    {
        sortChoices()
        char = allChoices[0].first
    }

    fun addChoice(char: String, certainty: ChoiceCertainty)
    {
        val matchIndex = allChoices.indexOfFirst { x -> x.first == char}

        if (certainty == ChoiceCertainty.CERTAIN)
        {
            if (matchIndex >= 0) allChoices.removeAt(matchIndex)

            allChoices.add(0, Pair(char, 100.0))
            this.char = char
        }
        else
        {
            if (matchIndex < 0)
            {
                allChoices.add(Pair(char, 0.0))
            }
        }
    }

    override fun clone(): ISquareChar
    {
        return SquareCharOcr(displayData, allChoices.toMutableList(), bitmapPos)
    }

    private fun sortChoices()
    {
        allChoices.sortByDescending { x -> x.second }
    }
}

enum class ChoiceCertainty
{
    CERTAIN,
    UNCERTAIN
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Enums/ChoiceType.java">
package ca.fuwafuwa.gaku.Windows.Enums;

/**
 * Created by 0xbad1d3a5 on 1/9/2017.
 */
public enum ChoiceType {
    EDIT,
    DELETE,
    NONE
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Enums/LayoutPosition.kt">
package ca.fuwafuwa.gaku.Windows.Enums

enum class LayoutPosition {
    TOP,
    BOTTOM,
    LEFT,
    RIGHT
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Interfaces/ICopyText.kt">
package ca.fuwafuwa.gaku.Windows.Interfaces

interface ICopyText
{
    fun copyText()
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Interfaces/IRecalculateKanjiViews.kt">
package ca.fuwafuwa.gaku.Windows.Interfaces

interface IRecalculateKanjiViews
{
    fun recalculateKanjiViews()
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Interfaces/ISearchPerformer.kt">
package ca.fuwafuwa.gaku.Windows.Interfaces

import ca.fuwafuwa.gaku.Windows.Data.DisplayData
import ca.fuwafuwa.gaku.Windows.Data.ISquareChar

interface ISearchPerformer
{
    fun performSearch(squareChar: ISquareChar)
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Interfaces/WindowListener.java">
package ca.fuwafuwa.gaku.Windows.Interfaces;

import android.view.GestureDetector;
import android.view.MotionEvent;

/**
 * Created by 0xbad1d3a5 on 4/12/2016.
 */
public interface WindowListener extends GestureDetector.OnGestureListener, GestureDetector.OnDoubleTapListener {
    boolean onTouch(MotionEvent e);
    boolean onResize(MotionEvent e);
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/ChoiceEditText.java">
package ca.fuwafuwa.gaku.Windows.Views;

import android.annotation.SuppressLint;
import android.content.Context;
import android.provider.Settings;
import android.util.AttributeSet;
import android.view.KeyEvent;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;

/**
 * Created by 0xbad1d3a5 on 1/10/2017.
 */

@SuppressLint("AppCompatCustomView")
public class ChoiceEditText extends EditText
{
    public interface InputDoneListener
    {
        void onEditTextInputDone(String input);
    }

    private static final String TAG = ChoiceEditText.class.getName();

    private InputMethodManager mImeManager;
    private InputDoneListener mCallback;

    public ChoiceEditText(Context context)
    {
        super(context);
        Init(context);
    }

    public ChoiceEditText(Context context, AttributeSet attrs)
    {
        super(context, attrs);
        Init(context);
    }

    public ChoiceEditText(Context context, AttributeSet attrs, int defStyleAttr)
    {
        super(context, attrs, defStyleAttr);
        Init(context);
    }

    public ChoiceEditText(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
    {
        super(context, attrs, defStyleAttr, defStyleRes);
        Init(context);
    }

    private void Init(Context context)
    {
        mImeManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        showKeyboard();
    }

    public void showKeyboard()
    {
        post(new Runnable() {
            @Override
            public void run() {
                requestFocus();
                mImeManager.showSoftInput(ChoiceEditText.this, InputMethodManager.SHOW_FORCED);
            }
        });
    }

    public void setInputDoneCallback(InputDoneListener callback)
    {
        mCallback = callback;
    }

    @Override
    public void onEditorAction(int actionCode)
    {
        if (actionCode == EditorInfo.IME_ACTION_DONE){
            if (mCallback != null){
                mImeManager.hideSoftInputFromWindow(getWindowToken(), 0);
                mCallback.onEditTextInputDone(getText().toString());
            }
        }
        super.onEditorAction(actionCode);
    }

    @Override
    public boolean onKeyPreIme(int keyCode, KeyEvent event)
    {
        if (event.getKeyCode() == KeyEvent.KEYCODE_BACK){
            if (mCallback != null){
                mImeManager.hideSoftInputFromWindow(getWindowToken(), 0);
                mCallback.onEditTextInputDone(getText().toString());
            }
        }
        return super.onKeyPreIme(keyCode, event);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/ChoiceGridView.java">
package ca.fuwafuwa.gaku.Windows.Views;

import android.content.Context;
import android.graphics.Bitmap;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.ImageView;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.List;

import ca.fuwafuwa.gaku.GakuTools;
import ca.fuwafuwa.gaku.R;
import ca.fuwafuwa.gaku.Windows.Data.SquareCharOcr;
import kotlin.Pair;

/**
 * Created by 0xbad1d3a5 on 5/5/2016.
 */
public class ChoiceGridView extends SquareGridView {

    private static final String TAG = ChoiceGridView.class.getName();

    private Context mContext;
    private List<TextView> mKanjiChoices;

    public ChoiceGridView(Context context) {
        super(context);
        Init(context);
    }

    public ChoiceGridView(Context context, AttributeSet attrs) {
        super(context, attrs);
        Init(context);
    }

    public ChoiceGridView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        Init(context);
    }

    public ChoiceGridView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
        Init(context);
    }

    private void Init(Context context){
        mContext = context;
        setCellSize(100);
    }

    public void onKanjiViewScrollStart(SquareCharOcr squareChar, MotionEvent e)
    {
        mKanjiChoices = new ArrayList<>();
        setItemCount(squareChar.getAllChoices().size() + 1);

        int[] pos = squareChar.getBitmapPos();
        if (pos != null){
            int dp10 = GakuTools.dpToPx(mContext, 10);
            Bitmap orig = squareChar.getDisplayData().getBitmap();
            int width = pos[2] - pos[0];
            int height = pos[3] - pos[1];
            width = width <= 0 ? 1 : width;
            height = height <= 0 ? 1 : height;
            Bitmap bitmapChar = Bitmap.createBitmap(orig, pos[0], pos[1], width, height);
            KanjiImageView charImage = new KanjiImageView(mContext);

            charImage.setSize(90);
            charImage.setPadding(dp10, dp10, dp10, dp10);
            charImage.setScaleType(ImageView.ScaleType.FIT_CENTER);
            charImage.setCropToPadding(true);
            charImage.setImageBitmap(bitmapChar);
            charImage.setBackground(R.drawable.bg_translucent_border_0_black_black);
            addView(charImage);
        }

        for (Pair<String, Double> choice : squareChar.getAllChoices()){
            TextView kanjiText = new TextView(mContext);
            kanjiText.setWidth(GakuTools.dpToPx(mContext, 90));
            kanjiText.setTextSize(60);
            kanjiText.setText(choice.getFirst());
            kanjiText.setBackgroundResource(R.drawable.bg_solid_border_0_white_black);
            addView(kanjiText);

            mKanjiChoices.add(kanjiText);
        }

        setY(e.getRawY());
    }

    public void onKanjiViewScroll(MotionEvent e1, MotionEvent e2)
    {
        if (mKanjiChoices == null){
            return;
        }

        for (TextView k : mKanjiChoices){
            if (checkForSelection(k, e2)){
                k.setBackgroundResource(R.drawable.bg_solid_border_0_blue_black);
            }
            else {
                k.setBackgroundResource(R.drawable.bg_solid_border_0_white_black);
            }
        }
    }

    public void onKanjiViewScrollEnd(SquareCharOcr squareChar, MotionEvent e){

        if (mKanjiChoices == null){
            return;
        }

        for (TextView k : mKanjiChoices){
            if (checkForSelection(k, e)){
                squareChar.setChar(k.getText().toString());
            }
        }

        removeAllViews();
        mKanjiChoices = null;
    }

    private boolean checkForSelection(TextView kanjiView, MotionEvent e){

        int[] pos = new int[2];
        kanjiView.getLocationInWindow(pos);

        if (pos[0] < e.getRawX() && e.getRawX() < pos[0] + kanjiView.getWidth() &&
            pos[1] < e.getRawY() && e.getRawY() < pos[1] + kanjiView.getHeight()){
            return true;
        }
        else {
            return false;
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/ChoiceIconView.java">
package ca.fuwafuwa.gaku.Windows.Views;

import android.annotation.SuppressLint;
import android.content.Context;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.widget.ImageView;
import android.widget.RelativeLayout;

import ca.fuwafuwa.gaku.GakuTools;
import ca.fuwafuwa.gaku.R;
import ca.fuwafuwa.gaku.Windows.Enums.ChoiceType;

/**
 * Created by 0xbad1d3a5 on 1/9/2017.
 */

@SuppressLint("AppCompatCustomView")
public class ChoiceIconView extends ImageView {

    private Context mContext;
    private int mStatusBarHeight;

    public ChoiceIconView(Context context) {
        super(context);
        Init(context);
    }

    public ChoiceIconView(Context context, AttributeSet attrs) {
        super(context, attrs);
        Init(context);
    }

    public ChoiceIconView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        Init(context);
    }

    public ChoiceIconView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
        Init(context);
    }

    private void Init(Context context){
        setLayoutParams(new RelativeLayout.LayoutParams(GakuTools.dpToPx(context, 35), GakuTools.dpToPx(context, 35)));
    }

    public void onKanjiViewScrollStart(int statusBarHeight, KanjiCharacterView kanjiView, MotionEvent e)
    {
        mStatusBarHeight = statusBarHeight;
        setVisibility(View.VISIBLE);
    }

    public void onKanjiViewScroll(MotionEvent e1, MotionEvent e2)
    {
        switch (getChoiceType(e2)){
            case EDIT:
                setImageResource(R.drawable.icon_edit);
                break;
            case DELETE:
                setImageResource(R.drawable.icon_delete);
                break;
            case NONE:
                setImageResource(R.drawable.icon_swap);
                break;
        }
    }

    public ChoiceType onKanjiViewScrollEnd(MotionEvent e){

        setVisibility(INVISIBLE);
        return getChoiceType(e);
    }

    private ChoiceType getChoiceType(MotionEvent e){

        int[] pos = new int[2];
        getLocationInWindow(pos);

        if (e.getRawY() < pos[1] + mStatusBarHeight){
            int mid =  pos[0] + getWidth() / 2;
            if (e.getRawX() < mid){
                return ChoiceType.EDIT;
            }
            else {
                return ChoiceType.DELETE;
            }
        }

        return ChoiceType.NONE;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/KanjiCharacterView.kt">
package ca.fuwafuwa.gaku.Windows.Views

import android.content.Context
import android.graphics.Color
import android.util.AttributeSet
import android.util.Log
import android.util.TypedValue
import android.view.GestureDetector
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.TextView
import androidx.core.content.ContextCompat
import ca.fuwafuwa.gaku.*
import ca.fuwafuwa.gaku.Ocr.BoxParams
import ca.fuwafuwa.gaku.Windows.*
import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr
import ca.fuwafuwa.gaku.Windows.Data.ISquareChar
import ca.fuwafuwa.gaku.Windows.Interfaces.ICopyText
import ca.fuwafuwa.gaku.Windows.Interfaces.IRecalculateKanjiViews
import ca.fuwafuwa.gaku.Windows.Interfaces.ISearchPerformer

/**
 * Created by 0xbad1d3a5 on 5/5/2016.
 */
class KanjiCharacterView : FrameLayout, GestureDetector.OnGestureListener, IRecalculateKanjiViews
{
    private lateinit var mContext: Context
    private lateinit var mGestureDetector: GestureDetector
    private lateinit var mWindowCoordinator: WindowCoordinator
    private lateinit var mSearchPerformer: ISearchPerformer
    private lateinit var mKanjiChoiceWindow: KanjiChoiceWindow
    private lateinit var mEditWindow: EditWindow
    private lateinit var mSquareChar: ISquareChar

    private lateinit var mKanjiTextView: TextView
    private lateinit var mIconImageView: ImageView

    private var mCellSizePx: Int = 0
    private var mScrollStartEvent: MotionEvent? = null

    constructor(context: Context) : super(context)
    {
        Init(context)
    }

    constructor(context: Context, attrs: AttributeSet) : super(context, attrs)
    {
        Init(context)
    }

    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int) : super(context, attrs, defStyleAttr)
    {
        Init(context)
    }

    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int, defStyleRes: Int) : super(context, attrs, defStyleAttr, defStyleRes)
    {
        Init(context)
    }

    private fun Init(context: Context)
    {
        mContext = context
        mGestureDetector = GestureDetector(mContext, this)

        mKanjiTextView = TextView(mContext)
        mKanjiTextView.gravity = Gravity.CENTER
        mKanjiTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20.toFloat())
        mKanjiTextView.setTextColor(Color.BLACK)
        addView(mKanjiTextView)

        mIconImageView = ImageView(mContext)
        mIconImageView.visibility = GONE
        addView(mIconImageView)
    }

    fun getSquareChar(): ISquareChar
    {
        return mSquareChar
    }

    fun setDependencies(windowCoordinator: WindowCoordinator, searchPerformer: ISearchPerformer)
    {
        mWindowCoordinator = windowCoordinator
        mSearchPerformer = searchPerformer

        mKanjiChoiceWindow = mWindowCoordinator.getWindowOfType(WINDOW_KANJI_CHOICE)
        mEditWindow = mWindowCoordinator.getWindowOfType(WINDOW_EDIT)
    }

    fun setText(squareChar: ISquareChar)
    {
        mSquareChar = squareChar
        mKanjiTextView.text = squareChar.char
    }

    fun setCellSize(px: Int)
    {
        mCellSizePx = dpToPx(context, pxToDp(context, px) - 2)
    }

    fun highlight()
    {
        // Use the new box drawable
        background = ContextCompat.getDrawable(mContext, R.drawable.bg_word_selection)
        
        // Optional: Add padding to the text view inside to prevent text from touching borders
        // if the box feels too tight.
    }

    fun highlightLight()
    {
        // A lighter version for single selection if desired, or reuse the same box
        background = ContextCompat.getDrawable(mContext, R.drawable.bg_transparent_border_0_nil_default)
    }

    fun unhighlight()
    {
        background = null
    }


    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int)
    {
        val cellWidthSpec = View.MeasureSpec.makeMeasureSpec(mCellSizePx, View.MeasureSpec.EXACTLY)
        val cellHeightSpec = View.MeasureSpec.makeMeasureSpec(mCellSizePx, View.MeasureSpec.EXACTLY)

        for (i in 0 until childCount)
        {
            getChildAt(i).measure(cellWidthSpec, cellHeightSpec)
        }

        setMeasuredDimension(mCellSizePx, mCellSizePx)
    }

    override fun onTouchEvent(e: MotionEvent): Boolean
    {
        mGestureDetector.onTouchEvent(e)

        if (e.action == MotionEvent.ACTION_UP)
        {
            visibility = View.VISIBLE

            if (mScrollStartEvent != null)
            {
                mScrollStartEvent = null

                mKanjiTextView.visibility = View.VISIBLE
                mIconImageView.visibility = View.GONE

                val choiceResult = mKanjiChoiceWindow.onSquareScrollEnd(e)
                when (choiceResult.first)
                {
                    ChoiceResultType.SWAP ->
                    {
                        mKanjiTextView.text = choiceResult.second
                        mSquareChar.text = choiceResult.second
                        recalculateKanjiViews()
                    }
                    ChoiceResultType.EDIT ->
                    {
                        val window = getProperWindow<Window>()
                        if (mSquareChar.displayData is DisplayDataOcr)
                        {
                            window.hide()
                        }

                        mEditWindow.setInfo(mSquareChar)
                        mEditWindow.setInputDoneCallback(this)
                        mEditWindow.show()
                    }
                    ChoiceResultType.DELETE ->
                    {
                        mSquareChar.text = ""
                        recalculateKanjiViews()
                    }
                    ChoiceResultType.NONE ->
                    {
                    }
                }
            }
        }

        return true
    }

    override fun recalculateKanjiViews()
    {
        val cwindow = getProperWindow<IRecalculateKanjiViews>()
        cwindow.recalculateKanjiViews()

        val window = getProperWindow<Window>()
        window.show()
    }

    override fun onDown(e: MotionEvent): Boolean
    {
        return true
    }

    override fun onSingleTapUp(e: MotionEvent): Boolean
    {
        highlightLight()
        mSquareChar.userTouched = true
        mSearchPerformer.performSearch(mSquareChar)
        return true
    }

    override fun onScroll(e1: MotionEvent?, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean
    {
        if (mScrollStartEvent == null)
        {
            Log.d(TAG, "ScrollStart")
            mScrollStartEvent = e1

            unhighlight()
            mKanjiTextView.visibility = View.INVISIBLE
            mIconImageView.visibility = View.VISIBLE
            mIconImageView.setImageResource(R.drawable.icon_swap)

            mKanjiChoiceWindow.onSquareScrollStart(mSquareChar, getKanjiBoxParams())
        }
        else {
            Log.d(TAG, "ScrollContinue")
            mIconImageView.setImageResource(mKanjiChoiceWindow.onSquareScroll(e2))
        }

        return true
    }

    override fun onFling(e1: MotionEvent?, e2: MotionEvent, velocityX: Float, velocityY: Float): Boolean
    {
        return false
    }

    override fun onLongPress(e: MotionEvent)
    {
        val window = getProperWindow<ICopyText>()
        window.copyText()
    }

    override fun onShowPress(e: MotionEvent)
    {
    }

    private fun <WindowType> getProperWindow() : WindowType
    {
        return if (mSquareChar.displayData.instantMode)
        {
            mWindowCoordinator.getWindowOfType(WINDOW_INSTANT_KANJI)
        }
        else {
            mWindowCoordinator.getWindowOfType(WINDOW_INFO)
        }
    }

    private fun getKanjiBoxParams() : BoxParams
    {
        var pos = IntArray(2)
        getLocationOnScreen(pos)
        return BoxParams(pos[0], pos[1], width, height)
    }

    companion object
    {
        private val TAG = KanjiCharacterView::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/KanjiGridView.kt">
package ca.fuwafuwa.gaku.Windows.Views

import android.content.Context
import android.util.AttributeSet
import android.view.View
import ca.fuwafuwa.gaku.Windows.Data.DisplayData
import ca.fuwafuwa.gaku.Windows.Data.ISquareChar
import ca.fuwafuwa.gaku.Windows.Interfaces.IRecalculateKanjiViews
import ca.fuwafuwa.gaku.Windows.Interfaces.ISearchPerformer
import ca.fuwafuwa.gaku.Windows.WindowCoordinator
import java.util.*


/**
 * Created by 0xbad1d3a5 on 5/5/2016.
 */
class KanjiGridView : SquareGridView, IRecalculateKanjiViews
{
    private lateinit var mWindowCoordinator: WindowCoordinator
    private lateinit var mSearchPerformer: ISearchPerformer
    private lateinit var mDisplayData: DisplayData

    private var mScrollValue: Int = 0

    private val mKanjiCellSize = squareCellSize

    var offset: Int = 0
        private set

    val kanjiViewList: List<KanjiCharacterView>
        get()
        {
            val count = childCount
            val kanjiViewList = ArrayList<KanjiCharacterView>()

            for (i in 0 until count)
            {
                kanjiViewList.add(getChildAt(i) as KanjiCharacterView)
            }

            return kanjiViewList
        }

    constructor(context: Context) : super(context)
    {
    }

    constructor(context: Context, attrs: AttributeSet) : super(context, attrs)
    {
    }

    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int) : super(context, attrs, defStyleAttr)
    {
    }

    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int, defStyleRes: Int) : super(context, attrs, defStyleAttr, defStyleRes)
    {
    }

    fun setDependencies(windowCoordinator: WindowCoordinator, searchPerformer: ISearchPerformer)
    {
        mWindowCoordinator = windowCoordinator
        mSearchPerformer = searchPerformer
    }

    fun setText(displayData: DisplayData)
    {
        mDisplayData = displayData
        offset = 0

        ensureViews()
    }

    fun getText() : String
    {
        return mDisplayData.text
    }

    fun clearText()
    {
        removeAllViews()
        postInvalidate()
    }

    fun clearSelection()
    {
        unhighlightAll()
    }

    fun unhighlightAll(squareCharToExclude: ISquareChar)
    {
        for (k in kanjiViewList)
        {
            if (k.getSquareChar() !== squareCharToExclude) k.unhighlight()
        }
    }

    fun unhighlightAll()
    {
        for (k in kanjiViewList)
        {
            k.unhighlight()
        }
    }

    fun scrollNext()
    {
        if (offset + maxSquares < mDisplayData.count)
        {
            offset += maxSquares
            mScrollValue = maxSquares
        }

        ensureViews()
    }

    fun scrollPrev()
    {
        if (offset - mScrollValue >= 0)
        {
            offset -= mScrollValue
        }
        else
        {
            offset = 0
        }

        ensureViews()
    }

    override fun recalculateKanjiViews()
    {
        mDisplayData.recomputeChars()

        ensureViews()
    }

    private fun ensureViews()
    {
        val numChars = mDisplayData.count - offset
        val currentChildCount = childCount

        // 1. If we need MORE views, add them
        if (numChars > currentChildCount)
        {
            addKanjiViews(numChars - currentChildCount)
        } 
        
        // 2. Iterate through all children. Bind data to needed ones, Hide the rest.
        // We do NOT remove views anymore, avoiding GC overhead.
        for (i in 0 until childCount) 
        {
            val kanjiView = getChildAt(i) as KanjiCharacterView
            
            if (i < numChars) {
                // We need this view. Make it visible and update data.
                if (kanjiView.visibility != View.VISIBLE) {
                    kanjiView.visibility = View.VISIBLE
                }
                
                // Get data based on offset
                val squareChar = mDisplayData.squareChars[offset + i]
                kanjiView.setText(squareChar)
                kanjiView.unhighlight()
            } else {
                // We don't need this view right now. Hide it.
                if (kanjiView.visibility != View.GONE) {
                    kanjiView.visibility = View.GONE
                }
            }
        }

        setItemCount(numChars)
        postInvalidate()
    }

    private fun addKanjiViews(count: Int)
    {
        for (i in 0 until count)
        {
            val kanjiView = KanjiCharacterView(context)
            kanjiView.setDependencies(mWindowCoordinator, mSearchPerformer)
            kanjiView.setCellSize(mKanjiCellSize)

            addView(kanjiView)
        }
    }

    companion object
    {
        private val TAG = KanjiGridView::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/KanjiImageView.kt">
package ca.fuwafuwa.gaku.Windows.Views

import android.content.Context
import android.graphics.drawable.Drawable
import android.util.AttributeSet
import android.util.Log
import android.widget.ImageView

import ca.fuwafuwa.gaku.*

/**
 * Created by 0xbad1d3a5 on 1/11/2017.
 */

class KanjiImageView : ImageView
{
    private var mSizePx: Int = 0

    constructor(context: Context) : super(context)
    {
    }

    constructor(context: Context, attrs: AttributeSet) : super(context, attrs)
    {
    }

    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int) : super(context, attrs, defStyleAttr)
    {
    }

    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int, defStyleRes: Int) : super(context, attrs, defStyleAttr, defStyleRes)
    {
    }

    fun setSize(dp: Int)
    {
        mSizePx = dpToPx(context, dp)
        Log.d(TAG, String.format("setSize: X: %d Y: %d", width, height))
    }

    fun setBackground(id: Int)
    {
        val bg = context.getDrawable(id)
        background = bg
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int)
    {
        Log.d(TAG, String.format("mSizePx: %d", mSizePx))
        setMeasuredDimension(mSizePx, mSizePx)
    }

    override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int)
    {
        super.onLayout(changed, left, top, right, bottom)

        Log.d(TAG, String.format("onLayout: X: %d Y: %d", width, height))
    }

    companion object
    {

        private val TAG = KanjiImageView::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/PitchAccentGraphView.java">
package ca.fuwafuwa.gaku.Windows.Views;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.util.AttributeSet;
import android.view.View;

import androidx.core.content.ContextCompat;

import ca.fuwafuwa.gaku.R;

public class PitchAccentGraphView extends View {

    private String reading = "";
    private String pattern = ""; // "0100"
    private Paint linePaint;
    private Paint circlePaint;
    private Paint textPaint;

    // Constants to match mockup style
    private float charWidth;
    private float graphHeight = 5; // Vertical space for lines
    private float highY = 8;
    private float textY = 35;

    public PitchAccentGraphView(Context context) {
        super(context);
        init();
    }

    public PitchAccentGraphView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    private void init() {
        linePaint = new Paint();
        linePaint.setColor(Color.LTGRAY);
        linePaint.setStrokeWidth(4);
        linePaint.setStyle(Paint.Style.STROKE);
        linePaint.setAntiAlias(true);

        circlePaint = new Paint();
        circlePaint.setStyle(Paint.Style.FILL);
        circlePaint.setAntiAlias(true);

        textPaint = new Paint();
        textPaint.setColor(Color.BLACK);
        textPaint.setTextSize(36); // Approx 14sp
        textPaint.setTextAlign(Paint.Align.LEFT);
        textPaint.setAntiAlias(true);
        // Load fonts if needed
    }

    public void setData(String reading, String pattern) {
        this.reading = reading;
        this.pattern = pattern;
        requestLayout();
        invalidate();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (reading.isEmpty()) {
            setMeasuredDimension(0, 0);
            return;
        }
        float totalWidth = textPaint.measureText(reading);
        charWidth = totalWidth / reading.length();
        int width = (int) totalWidth + 20;
        int height = (int) textY + 10;
        setMeasuredDimension(resolveSize(width, widthMeasureSpec), resolveSize(height, heightMeasureSpec));
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (reading.isEmpty())
            return;

        float currentX = 5;
        canvas.drawText(reading, currentX, textY, textPaint);

        if (pattern.isEmpty())
            return;

        // Draw Overline
        float lineY = highY;
        boolean inHigh = false;

        for (int i = 0; i < pattern.length() && i < reading.length(); i++) {
            boolean isHigh = pattern.charAt(i) == '1';
            float charW = textPaint.measureText(reading.substring(i, i + 1));

            if (isHigh) {
                if (!inHigh) {
                    // Start high
                    inHigh = true;
                    // Draw vertical start if not the first character or if first character is low
                    // (standard Japanese pitch)
                    // Actually usually just a horizontal line. The drop is more important.
                }
                // Draw horizontal line over this char
                canvas.drawLine(currentX, lineY, currentX + charW, lineY, linePaint);

                // If next is low or end, draw drop
                if (i + 1 == pattern.length() || pattern.charAt(i + 1) == '0') {
                    canvas.drawLine(currentX + charW, lineY, currentX + charW, textY - 5, linePaint);
                    inHigh = false;
                }
            } else {
                inHigh = false;
            }
            currentX += charW;
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/ResizeView.java">
package ca.fuwafuwa.gaku.Windows.Views;

import android.content.Context;
import androidx.core.view.GestureDetectorCompat;
import android.util.AttributeSet;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.widget.LinearLayout;

import ca.fuwafuwa.gaku.Windows.Interfaces.WindowListener;

/**
 * Created by 0xbad1d3a5 on 4/13/2016.
 */
public class ResizeView extends LinearLayout
        implements GestureDetector.OnGestureListener, GestureDetector.OnDoubleTapListener {
    private WindowListener mWindowListener;
    private GestureDetectorCompat mDetector;

    public ResizeView(Context context) {
        super(context);
        init(context);
    }

    public ResizeView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    public ResizeView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init(context);
    }

    private void init(Context context) {
        mDetector = new GestureDetectorCompat(context, this);
        mDetector.setOnDoubleTapListener(this);
    }

    public void setWindowListener(WindowListener windowListener) {
        this.mWindowListener = windowListener;
    }

    @Override
    public boolean onTouchEvent(MotionEvent e) {
        mDetector.onTouchEvent(e);

        return mWindowListener.onResize(e);
    }

    @Override
    public boolean onSingleTapConfirmed(MotionEvent e) {
        return false;
    }

    @Override
    public boolean onDoubleTap(MotionEvent e) {
        return mWindowListener.onDoubleTap(e);
    }

    @Override
    public boolean onDoubleTapEvent(MotionEvent e) {
        return false;
    }

    @Override
    public boolean onDown(MotionEvent e) {
        return false;
    }

    @Override
    public void onShowPress(MotionEvent e) {
    }

    @Override
    public boolean onSingleTapUp(MotionEvent e) {
        return false;
    }

    @Override
    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
        return false;
    }

    @Override
    public void onLongPress(MotionEvent e) {
        // Forward long press to the WindowListener to allow unlocking Edit Mode from
        // the resize handle
        if (mWindowListener != null) {
            mWindowListener.onLongPress(e);
        }
    }

    @Override
    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
        return false;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/SquareGridView.kt">
package ca.fuwafuwa.gaku.Windows.Views

import android.content.Context
import android.util.AttributeSet
import android.view.View
import android.view.ViewGroup

import ca.fuwafuwa.gaku.*

/**
 * Created by 0xbad1d3a5 on 5/5/2016.
 */
open class SquareGridView : ViewGroup
{
    protected var squareCellSize = 0
    protected var maxSquares = 0

    private var mItemCount = 0
    private var mRowLimit = 0
    private var mRows = 1

    constructor(context: Context) : super(context)
    {
        Init(context)
    }

    constructor(context: Context, attrs: AttributeSet) : super(context, attrs)
    {
        Init(context)
    }

    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int) : super(context, attrs, defStyleAttr)
    {
        Init(context)
    }

    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int, defStyleRes: Int) : super(context, attrs, defStyleAttr, defStyleRes)
    {
        Init(context)
    }

    private fun Init(context: Context)
    {
        squareCellSize = dpToPx(context, 37)
    }

    fun setCellSize(dp: Int)
    {
        squareCellSize = dpToPx(context, dp)
    }

    fun setItemCount(items: Int)
    {
        mItemCount = items
    }

    fun setRowLimit(rowLimit: Int)
    {
        mRowLimit = rowLimit
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int)
    {
        val cellWidthSpec = View.MeasureSpec.makeMeasureSpec(squareCellSize, View.MeasureSpec.EXACTLY)
        val cellHeightSpec = View.MeasureSpec.makeMeasureSpec(squareCellSize, View.MeasureSpec.EXACTLY)

         val count = childCount
        var visibleCount = 0 // Track actual visible items

        for (index in 0 until count)
        {
            val child = getChildAt(index)
            if (child.visibility != View.GONE) {
                child.measure(cellWidthSpec, cellHeightSpec)
                visibleCount++
            }
        }

        // Use visibleCount instead of count for calculating rows
        val x = View.resolveSize(squareCellSize * visibleCount, widthMeasureSpec)
        
        // Check for 0 to avoid divide by zero if no items visible
        val columns = if (x / squareCellSize > 0) x / squareCellSize else 1
        
        mRows = Math.ceil(mItemCount.toDouble() / columns.toDouble()).toInt()
        mRows = if (mRows <= 0) 1 else mRows

        when (mRowLimit)
        {
            0 -> { mRows = if (mRows >= 4) 4 else mRows }
            1 -> { mRows = 1 }
            2 -> { mRows = if (mRows >= 8) 8 else mRows }
        }

        val y = View.resolveSize(squareCellSize * mRows, heightMeasureSpec)
        setMeasuredDimension(x, y)
    }

    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int)
    {
        var columns = (r - l) / squareCellSize
        val xStart = (r - l - squareCellSize * columns) / 2
        if (columns < 0)
        {
            columns = 1
        }

         var rows = 1
        var x = xStart
        var y = 0
        var i = 0
        val count = childCount
        
        for (index in 0 until count)
        {
            val child = getChildAt(index)
            
            // ADD THIS CHECK: Skip layout for hidden views
            if (child.visibility == View.GONE) continue

            val w = child.measuredWidth
            val h = child.measuredHeight
            val left = x + (squareCellSize - w) / 2
            val top = y + (squareCellSize - h) / 2
            child.layout(left, top, left + w, top + h)
            if (i >= columns - 1)
            {
                // advance to next row
                i = 0
                x = xStart
                y += squareCellSize
                rows++
                if (rows > mRows)
                {
                    break
                }
            } else
            {
                i++
                x += squareCellSize
            }
        }

        maxSquares = columns * mRows
    }

    companion object
    {
        private val TAG = SquareGridView::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/WindowView.java">
package ca.fuwafuwa.gaku.Windows.Views;

import android.content.Context;
import androidx.core.view.GestureDetectorCompat;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.RelativeLayout;

import ca.fuwafuwa.gaku.Windows.Interfaces.WindowListener;

/**
 * Created by 0xbad1d3a5 on 4/13/2016.
 */
public class WindowView extends RelativeLayout
{
    private WindowListener mWindowListener;
    private GestureDetectorCompat mDetector;

    public WindowView(Context context)
    {
        super(context);
    }

    public WindowView(Context context, AttributeSet attrs)
    {
        super(context, attrs);
    }

    public WindowView(Context context, AttributeSet attrs, int defStyleAttr)
    {
        super(context, attrs, defStyleAttr);
    }

    public void setWindowListener(WindowListener windowListener)
    {
        mWindowListener = windowListener;
    }

    public void setDetector(GestureDetectorCompat detector)
    {
        mDetector = detector;
    }

    @Override
    public boolean onTouchEvent(MotionEvent e)
    {
        if (mDetector.onTouchEvent(e))
        {
            return true;
        }

        return mWindowListener.onTouch(e);
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Views/WordOverlayView.java">
package ca.fuwafuwa.gaku.Windows.Views;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;

import androidx.core.content.ContextCompat;

import java.util.ArrayList;
import java.util.List;

import ca.fuwafuwa.gaku.Analysis.ParsedWord;
import ca.fuwafuwa.gaku.legacy.user.UserWord;
import ca.fuwafuwa.gaku.R;

import android.graphics.Color;
import android.util.TypedValue;
import android.widget.RelativeLayout;
import android.widget.TextView;
import ca.fuwafuwa.gaku.Analysis.ParsedLine;
import ca.fuwafuwa.gaku.Analysis.ParsedResult;

public class WordOverlayView extends RelativeLayout {

    private static final String TAG = "WordOverlayView";
    private List<ParsedWord> words = new ArrayList<>();
    private List<ParsedLine> lines = new ArrayList<>();
    // Store orientation per word for AUTO mode
    private List<Boolean> wordOrientations = new ArrayList<>();

    private Paint paintUnknown;
    private Paint paintLearning;
    private Paint paintKnown;
    private Paint paintMature;
    private Paint paintMastered;
    private Paint paintDue;
    private Paint paintDismissed;
    private Paint paintTouch;
    private ca.fuwafuwa.gaku.TextDirection textDirection = ca.fuwafuwa.gaku.TextDirection.AUTO;
    private OnWordClickListener listener;

    public interface OnWordClickListener {
        // Updated interface to pass orientation
        void onWordClicked(ParsedWord word, boolean isVertical);

        void onBlankSpaceClicked();
    }

    public WordOverlayView(Context context) {
        super(context);
        init();
    }

    public WordOverlayView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public WordOverlayView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private void init() {
        setWillNotDraw(false);
        paintUnknown = new Paint();
        paintUnknown.setColor(ContextCompat.getColor(getContext(), R.color.status_unknown));
        paintUnknown.setStrokeWidth(6);
        paintUnknown.setStyle(Paint.Style.STROKE);

        paintLearning = new Paint();
        paintLearning.setColor(ContextCompat.getColor(getContext(), R.color.status_learning));
        paintLearning.setStrokeWidth(6);
        paintLearning.setStyle(Paint.Style.STROKE);

        paintKnown = new Paint();
        paintKnown.setColor(ContextCompat.getColor(getContext(), R.color.status_known));
        paintKnown.setStrokeWidth(6);
        paintKnown.setStyle(Paint.Style.STROKE);

        paintMature = new Paint();
        paintMature.setColor(ContextCompat.getColor(getContext(), R.color.status_mature));
        paintMature.setStrokeWidth(6);
        paintMature.setStyle(Paint.Style.STROKE);

        paintMastered = new Paint();
        paintMastered.setColor(ContextCompat.getColor(getContext(), R.color.status_mastered));
        paintMastered.setStrokeWidth(6);
        paintMastered.setStyle(Paint.Style.STROKE);

        paintDue = new Paint();
        paintDue.setColor(ContextCompat.getColor(getContext(), R.color.status_due));
        paintDue.setStrokeWidth(6);
        paintDue.setStyle(Paint.Style.STROKE);

        paintDismissed = new Paint();
        paintDismissed.setColor(ContextCompat.getColor(getContext(), R.color.status_dismissed));
        paintDismissed.setStrokeWidth(6);
        paintDismissed.setStyle(Paint.Style.STROKE);
        paintDismissed.setAlpha(128);

        paintTouch = new Paint();
        paintTouch.setColor(0x33000000);
        paintTouch.setStyle(Paint.Style.FILL);
    }

    public void setTextDirection(ca.fuwafuwa.gaku.TextDirection direction) {
        this.textDirection = direction;
        invalidate();
    }

    public void setParsedResult(ParsedResult result) {
        this.words = result.getWords();
        this.lines = result.getLines();
        calculateOrientations();
        updateTextViews();
        invalidate();
    }

    private void calculateOrientations() {
        wordOrientations.clear();
        for (ParsedWord word : words) {
            Rect wRect = word.getBoundingBox();
            boolean isVertical = false;

            // Heuristic: If a word is inside a vertical line, it is vertical.
            int cx = wRect.centerX();
            int cy = wRect.centerY();

            boolean lineFound = false;
            for (ParsedLine line : lines) {
                Rect lRect = line.getBoundingBox();
                if (lRect.contains(cx, cy)) {
                    if (lRect.height() > lRect.width()) {
                        isVertical = true;
                    }
                    lineFound = true;
                    break;
                }
            }

            // Fallback if the word center isn't perfectly inside any line rect
            if (!lineFound) {
                if (wRect.height() > wRect.width()) {
                    isVertical = true;
                }
            }

            wordOrientations.add(isVertical);
        }
    }

    private void updateTextViews() {
        removeAllViews();
        int offset = getOffset();
        for (final ParsedLine line : lines) {
            Rect rect = line.getBoundingBox();
            final TextView tv = new TextView(getContext());
            tv.setText(line.getText());
            tv.setTextColor(Color.TRANSPARENT);
            tv.setTextIsSelectable(true);
            tv.setGravity(android.view.Gravity.CENTER_VERTICAL);

            tv.setTypeface(android.graphics.Typeface.MONOSPACE);

            float height = rect.height();
            tv.setTextSize(TypedValue.COMPLEX_UNIT_PX, height * 0.95f);
            tv.setPadding(0, 0, 0, 0);
            tv.setIncludeFontPadding(false);

            LayoutParams lp = new LayoutParams(rect.width(), rect.height());
            lp.leftMargin = rect.left + offset;
            lp.topMargin = rect.top + offset;
            tv.setLayoutParams(lp);

            tv.setOnTouchListener(new OnTouchListener() {
                private long downTime;

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    if (event.getAction() == MotionEvent.ACTION_DOWN) {
                        downTime = System.currentTimeMillis();
                    } else if (event.getAction() == MotionEvent.ACTION_UP) {
                        if (System.currentTimeMillis() - downTime < 300) {
                            handleTap(event.getRawX(), event.getRawY());
                            return true;
                        }
                    }
                    return true;
                }
            });

            addView(tv);
        }
    }

    private void handleTap(float rawX, float rawY) {
        int[] location = new int[2];
        getLocationOnScreen(location);
        int localX = (int) (rawX - location[0] - getOffset());
        int localY = (int) (rawY - location[1] - getOffset());

        for (int i = 0; i < words.size(); i++) {
            ParsedWord word = words.get(i);
            if (word.getBoundingBox().contains(localX, localY)) {
                if (listener != null) {
                    boolean isVertical = false;

                    // Determine orientation based on settings or calculation
                    if (textDirection == ca.fuwafuwa.gaku.TextDirection.VERTICAL) {
                        isVertical = true;
                    } else if (textDirection == ca.fuwafuwa.gaku.TextDirection.HORIZONTAL) {
                        isVertical = false;
                    } else {
                        // AUTO
                        if (i < wordOrientations.size()) {
                            isVertical = wordOrientations.get(i);
                        } else {
                            isVertical = word.getBoundingBox().height() > word.getBoundingBox().width();
                        }
                    }

                    listener.onWordClicked(word, isVertical);
                }
                return;
            }
        }

        if (listener != null) {
            listener.onBlankSpaceClicked();
        }
    }

    public void setOnWordClickListener(OnWordClickListener listener) {
        this.listener = listener;
    }

    private int getOffset() {
        return ca.fuwafuwa.gaku.GakuTools.dpToPx(getContext(), 1) + 1;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (words == null || words.isEmpty()) {
            return;
        }

        int offset = getOffset();
        int gap = ca.fuwafuwa.gaku.GakuTools.dpToPx(getContext(), 1);

        java.util.Map<Integer, List<Float>> segmentsByStatus = new java.util.HashMap<>();

        for (int i = 0; i < words.size(); i++) {
            ParsedWord word = words.get(i);
            int status = word.getStatus();

            if (!segmentsByStatus.containsKey(status)) {
                segmentsByStatus.put(status, new ArrayList<>());
            }

            Rect rect = word.getBoundingBox();

            boolean isVertical;
            if (textDirection == ca.fuwafuwa.gaku.TextDirection.VERTICAL) {
                isVertical = true;
            } else if (textDirection == ca.fuwafuwa.gaku.TextDirection.HORIZONTAL) {
                isVertical = false;
            } else {
                if (i < wordOrientations.size()) {
                    isVertical = wordOrientations.get(i);
                } else {
                    isVertical = rect.height() > rect.width();
                }
            }

            List<Float> segments = segmentsByStatus.get(status);

            if (isVertical) {
                segments.add((float) (rect.right + offset));
                segments.add((float) (rect.top + offset + gap));
                segments.add((float) (rect.right + offset));
                segments.add((float) (rect.bottom + offset - gap));
            } else {
                segments.add((float) (rect.left + offset + gap));
                segments.add((float) (rect.bottom + offset - 2));
                segments.add((float) (rect.right + offset - gap));
                segments.add((float) (rect.bottom + offset - 2));
            }
        }

        for (java.util.Map.Entry<Integer, List<Float>> entry : segmentsByStatus.entrySet()) {
            List<Float> floatList = entry.getValue();
            if (floatList.isEmpty())
                continue;

            float[] pts = new float[floatList.size()];
            for (int i = 0; i < floatList.size(); i++) {
                pts[i] = floatList.get(i);
            }

            Paint paint = getPaintForStatus(entry.getKey());
            canvas.drawLines(pts, paint);
        }
    }

    public ParsedWord getWordAtLocalCoords(int localX, int localY) {
        if (words == null) return null;
        for (ParsedWord word : words) {
            if (word.getBoundingBox().contains(localX, localY)) {
                return word;
            }
        }
        return null;
    }

    private Paint getPaintForStatus(int status) {
        switch (status) {
            case UserWord.STATUS_LEARNING:
                return paintLearning;
            case UserWord.STATUS_KNOWN:
                return paintKnown;
            case UserWord.STATUS_MATURE:
                return paintMature;
            case UserWord.STATUS_MASTERED:
                return paintMastered;
            case UserWord.STATUS_DUE:
                return paintDue;
            case UserWord.STATUS_DISMISSED:
                return paintDismissed;
            default:
                return paintUnknown;
        }
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        return false;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/CaptureWindow.kt">
package ca.fuwafuwa.gaku.Windows

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Color
import android.graphics.drawable.Drawable
import android.graphics.drawable.GradientDrawable
import android.graphics.Rect
import android.os.Build
import android.util.Log
import android.view.HapticFeedbackConstants
import android.view.MotionEvent
import android.view.View
import android.view.ViewTreeObserver
import android.view.WindowManager
import android.view.animation.Animation
import android.view.animation.AnimationUtils
import android.widget.Button
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Toast
import androidx.core.content.ContextCompat
import ca.fuwafuwa.gaku.*
import ca.fuwafuwa.gaku.Ocr.BoxParams
import ca.fuwafuwa.gaku.Ocr.OcrParams
import ca.fuwafuwa.gaku.Ocr.OcrRunnable
import ca.fuwafuwa.gaku.Prefs
import ca.fuwafuwa.gaku.R
import ca.fuwafuwa.gaku.Windows.Interfaces.WindowListener
import ca.fuwafuwa.gaku.Windows.Views.WordOverlayView
import ca.fuwafuwa.gaku.Analysis.ParsedResult
import ca.fuwafuwa.gaku.Analysis.ParsedWord
import java.io.FileOutputStream
import java.io.IOException

/**
 * CaptureWindow handles the Region of Interest (ROI) selection,
 * UI presets, and initiates the OCR pipeline.
 */
class CaptureWindow(context: Context, windowCoordinator: WindowCoordinator) : Window(context, windowCoordinator, R.layout.window_capture), WindowListener
{
    private val mOcr: OcrRunnable
    private val mWindowBox: View
    private val mImageView: ImageView
    private val mWordOverlay: WordOverlayView
    private val mFadeRepeat: Animation
    
    // REQ-007 & REQ-008 UI Elements
    private val mPresetBar: View
    private val mGuideH: View
    private val mGuideV: View

    private var mLastDoubleTapTime: Long
    private val mLastDoubleTapIgnoreDelay: Long
    private var mInLongPress: Boolean = false
    private var mProcessingOcr: Boolean = false
    
    // Flag to lock movement until long press
    private var mIsEditMode: Boolean = false
    
    // Offsets for manual movement handling
    private var mDragOffsetX: Int = 0
    private var mDragOffsetY: Int = 0

    private inner class ScreenshotForOcr(val crop: Bitmap?, val orig: Bitmap?, val params: BoxParams?) {
        fun recycle() {
            if (crop != null && !crop.isRecycled) crop.recycle()
            if (orig != null && !orig.isRecycled) orig.recycle()
        }
    }

    init
    {
        mImageView = window.findViewById(R.id.capture_image)
        mWordOverlay = window.findViewById(R.id.word_overlay)
        
        mWordOverlay.setOnWordClickListener(object : WordOverlayView.OnWordClickListener {
            override fun onWordClicked(word: ParsedWord, isVertical: Boolean) {
                // We don't use isVertical for positioning anymore, per simplify request
                this@CaptureWindow.onWordClicked(word)
            }
            override fun onBlankSpaceClicked() {
                hideInstantWindows()
            }
        })
        
        mWindowBox = window.findViewById(R.id.capture_box)
        mPresetBar = window.findViewById(R.id.preset_bar)
        mGuideH = window.findViewById(R.id.guide_h)
        mGuideV = window.findViewById(R.id.guide_v)

        mFadeRepeat = AnimationUtils.loadAnimation(this.context, R.anim.fade_repeat)
        
        mLastDoubleTapTime = System.currentTimeMillis()
        mLastDoubleTapIgnoreDelay = 500
        mInLongPress = false
        mProcessingOcr = false
        mIsEditMode = false

        // Ensure window view allows haptics
        window.isHapticFeedbackEnabled = true

        // Initialize Presets and Border
        setupPresets()
        updateBorderVisuals()

        mOcr = OcrRunnable(this.context, this)
        val ocrThread = Thread(mOcr)
        ocrThread.name = String.format("OcrThread%d", System.nanoTime())
        ocrThread.isDaemon = true
        ocrThread.start()
        
        mOcr.warmUp()

        mWindowBox.viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener
        {
            override fun onGlobalLayout()
            {
                (context as MainService).onCaptureWindowFinishedInitializing()
                mWindowBox.viewTreeObserver.removeOnGlobalLayoutListener(this)
            }
        })

        show()
    }

    override fun reInit(options: Window.ReinitOptions)
    {
        super.reInit(options)
        updateBorderVisuals()
    }

    private fun setupPresets() {
        val container = window.findViewById<LinearLayout>(R.id.preset_container)
        container.removeAllViews()
        
        CapturePreset.values().forEach { preset ->
            val btn = Button(context).apply {
                text = preset.label
                textSize = 10f
                setTextColor(Color.WHITE)
                background = ContextCompat.getDrawable(context, R.drawable.bg_solid_border_corners_0_white_black_round)
                backgroundTintList = android.content.res.ColorStateList.valueOf(Color.parseColor("#44FFFFFF"))
                
                val lp = LinearLayout.LayoutParams(dpToPx(context, 70), dpToPx(context, 40))
                lp.setMargins(dpToPx(context, 4), 0, dpToPx(context, 4), 0)
                layoutParams = lp
                
                setOnClickListener { applyPreset(preset) }
            }
            container.addView(btn)
        }
    }

    private fun applyPreset(preset: CapturePreset) {
        params.width = dpToPx(context, preset.widthDp)
        params.height = dpToPx(context, preset.heightDp)
        
        params.x = (getRealDisplaySize().x / 2) - (params.width / 2)
        params.y = (getRealDisplaySize().y / 2) - (params.height / 2)
        
        windowManager.updateViewLayout(window, params)
        blinkBorder()
        mPresetBar.visibility = View.GONE
        mIsEditMode = false 
    }

    private fun updateBorderVisuals() {
        val prefs = getPrefs(context)
        val color = Color.parseColor(prefs.borderColor)
        val thickness = dpToPx(context, prefs.borderThickness)
        
        val shape = GradientDrawable().apply {
            setStroke(thickness, color)
            val alphaColor = (color and 0x00FFFFFF) or 0x1A000000 
            setColor(alphaColor)
        }
        mWindowBox.background = shape
    }

    private fun blinkBorder() {
        mWindowBox.alpha = 0.3f
        mWindowBox.animate().alpha(1.0f).setDuration(300).start()
    }

    fun showGuides(h: Boolean, v: Boolean) {
        val prefs = getPrefs(context)
        if (!prefs.snapEnabled) return

        mGuideH.visibility = if (v) View.VISIBLE else View.GONE
        mGuideV.visibility = if (h) View.VISIBLE else View.GONE
        
        mGuideH.removeCallbacks(hideGuidesRunnable)
        mGuideH.postDelayed(hideGuidesRunnable, 800)
    }

    private val hideGuidesRunnable = Runnable {
        mGuideH.visibility = View.GONE
        mGuideV.visibility = View.GONE
    }

    override fun onDoubleTap(e: MotionEvent): Boolean
    {
        mLastDoubleTapTime = System.currentTimeMillis()
        performOcr(false)
        return true
    }

    override fun onTouch(e: MotionEvent): Boolean
    {
        if (e.pointerCount >= 3)
        {
            val currentContext = context
            if (currentContext != null) {
                Toast.makeText(currentContext, "Closing Gaku...", Toast.LENGTH_SHORT).show()
                (currentContext as? MainService)?.stopSelf()
            }
            return true
        }

        // Removed default call to hideInstantWindows here to prevent jitter closing.
        // It's now handled explicitly in onUp if clicking blank space.

        if (e.action == MotionEvent.ACTION_DOWN) {
            // Capture offsets for manual movement
            mDragOffsetX = params.x - e.rawX.toInt()
            mDragOffsetY = params.y - e.rawY.toInt()
            
            super.onTouch(e)
            return true
        }

        if (e.action == MotionEvent.ACTION_MOVE)
        {
            if (System.currentTimeMillis() > mLastDoubleTapTime + mLastDoubleTapIgnoreDelay)
            {
                mOcr.cancel()
            }

            // Manual movement logic
            if (mIsEditMode) {
                // Only clear overlay if we are actually moving the window
                mImageView.setImageResource(0)
                mWordOverlay.visibility = View.GONE
                updateWindowFlags(false)
                
                // Also close any popup if moving
                hideInstantWindows()

                params.x = mDragOffsetX + e.rawX.toInt()
                params.y = mDragOffsetY + e.rawY.toInt()
                
                // Keep within screen bounds
                val display = getRealDisplaySize()
                val statusBar = getStatusBarHeight()
                
                if (params.x < 0) params.x = 0
                else if (params.x + params.width > display.x) params.x = display.x - params.width
                
                if (params.y < 0) params.y = 0
                else if (params.y + params.height > display.y) params.y = display.y - params.height - statusBar
                
                windowManager.updateViewLayout(window, params)
            }
            
            return true
        }

        if (e.action == MotionEvent.ACTION_UP) {
            if (mIsEditMode) {
                mIsEditMode = false
                mPresetBar.postDelayed({ mPresetBar.visibility = View.GONE }, 2000)
            } else {
                // If not in edit mode (just a tap)
                // Check if we hit a word? WordOverlay handles clicks internally via its own OnTouch listener.
                // However, WordOverlay is transparent. 
                // If the click falls through to here, it means we clicked "blank space" on the capture window.
                
                // But wait, WordOverlayView fills the parent. 
                // We need to know if WordOverlay handled it. 
                // Actually, since WordOverlay is on top, if we receive onTouch here in Window, 
                // it implies WordOverlay didn't consume it?
                // No, Window's onTouch is called by WindowView's onTouchEvent which calls mDetector.
                
                // Simplest fix: Just hide the popup (WordDetailWindow) here.
                // If a word was clicked, WordDetailWindow will be shown by onWordClicked immediately after.
                // But if we hide it here, it might flicker or close immediately.
                // A better approach is to check if WordOverlay handled the tap.
                
                // Let's rely on WordOverlayView logic. If it didn't find a word, it does nothing.
                // If we want "Click blank space to close popup", we can just call hideInstantWindows().
                // However, we MUST NOT clear the results (mWordOverlay.visibility = GONE) on tap.
                
                hideInstantWindows()
            }

            onUp(e)
            return true
        }

        return true
    }

    override fun onScroll(e1: MotionEvent?, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean {
        // Prevent default window scrolling if not in edit mode
        if (!mIsEditMode) return true
        return super.onScroll(e1, e2, distanceX, distanceY)
    }

    override fun onLongPress(e: MotionEvent)
    {
        // Unlock Edit Mode and show Preset Bar
        mInLongPress = true
        mIsEditMode = true
        
        // Re-calculate offsets on long press to ensure smooth transition
        mDragOffsetX = params.x - e.rawX.toInt()
        mDragOffsetY = params.y - e.rawY.toInt()

        val prefs = getPrefs(context)
        if (prefs.showPresetBar) mPresetBar.visibility = View.VISIBLE
        
        window.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
    }

    override fun onResize(e: MotionEvent): Boolean
    {
        // Allow resize anytime (no edit mode check)
        
        // Handle touch up to reset state when resizing ends
        if (e.action == MotionEvent.ACTION_UP || e.action == MotionEvent.ACTION_CANCEL) {
            mIsEditMode = false
            mPresetBar.postDelayed({ mPresetBar.visibility = View.GONE }, 2000)
        }

        hideInstantWindows()
        mOcr.cancel()
        
        // Kept results visible during resize
        return super.onResize(e)
    }

    override fun onUp(e: MotionEvent): Boolean
    {
        mInLongPress = false

        return true
    }

    override fun stop()
    {
        mOcr.stop()
        super.stop()
    }

    /**
    * Checks if a global screen coordinate hits a word within this window.
    */
    fun getWordAtScreenCoords(rawX: Float, rawY: Float): ParsedWord? {
        val borderOffset = dpToPx(context, 1) + 1
        
        // Convert Screen Space -> Local Window Space
        val localX = (rawX - params.x - borderOffset).toInt()
        val localY = (rawY - params.y - borderOffset).toInt()

        return mWordOverlay.getWordAtLocalCoords(localX, localY)
    }

    /**
    * Proxy method to allow the Detail window to trigger a "Word Click"
    */
    fun onWordHandleExternal(word: ParsedWord) {
        this.onWordClicked(word)
    }

    fun showLoadingAnimation()
    {
        (context as MainService).handler.post {
            mImageView.imageAlpha = 0
            mWindowBox.animation = mFadeRepeat
            mWindowBox.startAnimation(mFadeRepeat)
        }
    }

    fun stopLoadingAnimation(instant: Boolean)
    {
        (context as MainService).handler.post {
            mProcessingOcr = false
            mWindowBox.clearAnimation()
            
            if (instant)
            {
                mImageView.imageAlpha = 255
            } else
            {
                mImageView.imageAlpha = 255
                mImageView.setImageResource(0)
            }
        }
    }

    fun hideInstantWindows()
    {
        windowCoordinator.getWindow(WINDOW_INSTANT_KANJI).hide()
        windowCoordinator.getWindow(WINDOW_WORD_DETAIL).hide()
    }

    fun setParsedResult(result: ParsedResult)
    {
        val prefs = getPrefs(context)
        (context as MainService).handler.post {
            mWordOverlay.setTextDirection(prefs.textDirectionSetting)
            mWordOverlay.setParsedResult(result)
            mWordOverlay.visibility = View.VISIBLE
            updateWindowFlags(true)
        }
    }

    private fun updateWindowFlags(focusable: Boolean) {
        if (focusable) {
            params.flags = params.flags and WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE.inv()
            params.flags = params.flags or WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
        } else {
            params.flags = params.flags or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            params.flags = params.flags and WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL.inv()
        }
        if (addedToWindowManager) {
            windowManager.updateViewLayout(window, params)
        }
    }

    private fun onWordClicked(word: ParsedWord)
    {
        // Close existing popup first (optional, but cleaner)
        hideInstantWindows()

        val wordDetailWindow = windowCoordinator.getWindowOfType<WordDetailWindow>(WINDOW_WORD_DETAIL)
        wordDetailWindow.setWord(word)
        wordDetailWindow.setOnStatusChangeListener {
            mWordOverlay.invalidate()
        }
        
        // Calculate Global Bounding Box of the Word
        val borderOffset = dpToPx(context, 1) + 1
        val relativeRect = word.boundingBox
        
        // CaptureWindow X + Border + Word X
        val globalLeft = params.x + borderOffset + relativeRect.left
        val globalTop = params.y + borderOffset + relativeRect.top
        
        val globalRect = Rect(globalLeft, globalTop, 
                            globalLeft + relativeRect.width(), 
                            globalTop + relativeRect.height())
                            
        // Calculate Global Bounding Box of the Capture Window
        val captureRect = Rect(params.x, params.y, params.x + params.width, params.y + params.height)
        
        wordDetailWindow.showForWordBounds(globalRect, captureRect)
    }

    override fun getDefaultParams(): WindowManager.LayoutParams
    {
        val params = super.getDefaultParams()
        params.x = realDisplaySize.x / 2 - params.width / 2
        params.y = realDisplaySize.y / 4 - params.height / 2
        params.alpha = 0.8F
        return params
    }

    private fun performOcr(instant: Boolean)
    {
        if (mProcessingOcr) return
        mProcessingOcr = true
        mLastDoubleTapTime = System.currentTimeMillis()

        showLoadingAnimation()

        val viewPos = IntArray(2)
        mWindowBox.getLocationOnScreen(viewPos)
        val box = BoxParams(viewPos[0], viewPos[1], params.width, params.height)

        Thread {
            try
            {
                if (!instant)
                {
                    var attempts = 0
                    while (!mOcr.isReadyForOcr && attempts < 20)
                    {
                        Thread.sleep(50)
                        attempts++
                    }
                }

                val ocrData = getOcrData(box)
                if (ocrData == null || ocrData.crop == null || ocrData.orig == null || ocrData.params == null)
                {
                    stopLoadingAnimation(instant)
                    return@Thread
                }

                mOcr.runTess(OcrParams(
                    ocrData.crop,
                    ocrData.orig,
                    ocrData.params,
                    ocrData.params.x,
                    ocrData.params.y,
                    instant
                ))

            } catch (e: Exception)
            {
                e.printStackTrace()
                stopLoadingAnimation(instant)
            }
        }.start()
    }

    @Throws(Exception::class)
    private fun getOcrData(box: BoxParams): ScreenshotForOcr?
    {
        try
        {
            return getReadyScreenshot(box)
        } catch (e: Exception)
        {
            e.printStackTrace()
        }
        return null
    }

    @Throws(Exception::class)
    private fun getReadyScreenshot(box: BoxParams): ScreenshotForOcr?
    {
        val bitmap = (context as MainService).screenshotBitmap
        if (bitmap == null) return null

        val croppedBitmap = getCroppedBitmap(bitmap, box)
        return ScreenshotForOcr(croppedBitmap, bitmap, box)
    }

    private fun getCroppedBitmap(screenshot: Bitmap, box: BoxParams): Bitmap
    {
        val borderSize = dpToPx(context, 1) + 1
        
        // Ensure we don't crop outside bounds
        val startX = box.x + borderSize
        val startY = box.y + borderSize
        var width = box.width - 2 * borderSize
        var height = box.height - 2 * borderSize
        
        // Validation
        if (startX < 0 || startY < 0) return Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888)
        if (width <= 0) width = 1
        if (height <= 0) height = 1
        if (startX + width > screenshot.width) width = screenshot.width - startX
        if (startY + height > screenshot.height) height = screenshot.height - startY
        
        return Bitmap.createBitmap(screenshot, startX, startY, width, height)
    }

    companion object
    {
        private val TAG = CaptureWindow::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/EditWindow.kt">
package ca.fuwafuwa.gaku.Windows

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Color
import android.graphics.PixelFormat
import android.graphics.Point
import android.os.Build
import android.util.Log
import android.view.MotionEvent
import android.view.WindowManager
import android.widget.ImageView

import ca.fuwafuwa.gaku.R
import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr
import ca.fuwafuwa.gaku.Windows.Data.ISquareChar
import ca.fuwafuwa.gaku.Windows.Data.SquareCharOcr
import ca.fuwafuwa.gaku.Windows.Interfaces.IRecalculateKanjiViews
import ca.fuwafuwa.gaku.Windows.Views.ChoiceEditText

/**
 * Created by 0xbad1d3a5 on 4/23/2016.
 */
class EditWindow(context: Context, windowCoordinator: WindowCoordinator) : Window(context, windowCoordinator, R.layout.window_edit), ChoiceEditText.InputDoneListener
{
    private val mChoiceEditText: ChoiceEditText = window.findViewById(R.id.edit_text)

    private lateinit var mCallback: IRecalculateKanjiViews
    private lateinit var mSquareChar: ISquareChar

    init
    {
        mChoiceEditText.setInputDoneCallback(this)
    }

    override fun onTouch(e: MotionEvent): Boolean
    {
        return false
    }

    override fun onDown(e: MotionEvent): Boolean {
        return false
    }

    override fun onScroll(e1: MotionEvent?, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean
    {
        return false
    }

    override fun onResize(e: MotionEvent): Boolean
    {
        return false
    }

    override fun show()
    {
        super.show()
        mChoiceEditText.setText("")
        mChoiceEditText.showKeyboard()
    }

    override fun onEditTextInputDone(input: String?)
    {
        if (input != null && !input.trim { it <= ' ' }.isEmpty())
        {
            mSquareChar.text = input
        }

        mCallback.recalculateKanjiViews()
        hide()
    }

    /**
     * EditWindow does not need to reInit layout as its getDefaultParams() are all relative. Re-initing will cause bugs.
     */
    override fun reInit(options: Window.ReinitOptions)
    {
        options.reinitViewLayout = false
        super.reInit(options)
    }

    fun setInputDoneCallback(callback: IRecalculateKanjiViews)
    {
        mCallback = callback
    }

    fun setInfo(squareChar: ISquareChar)
    {
        mSquareChar = squareChar
        val displayData = squareChar.displayData

        if (displayData is DisplayDataOcr && squareChar is SquareCharOcr)
        {
            val pos = squareChar.bitmapPos
            val orig = displayData.bitmap

            var width = pos[2] - pos[0]
            var height = pos[3] - pos[1]
            var xPos = pos[0]
            var yPos = pos[1]

            if (xPos >= orig.width || yPos >= orig.height) {
                // Invalid position, can't create bitmap
                val iv = window.findViewById<ImageView>(R.id.edit_kanji_image)
                iv.setBackgroundColor(0x44000000)
                return
            }

            Log.d(TAG, "Initial | Orig: (${orig.width}x${orig.height}) Box: ($xPos, $yPos) (${width}x${height})")

            width = if (width <= 0) 1 else width
            height = if (height <= 0) 1 else height

            val avgSize = calculateMedianSquareSize(squareChar)
            val avgWidth = avgSize.x
            val avgHeight = avgSize.y

            xPos -= avgWidth * 6
            yPos -= avgHeight * 6
            width += avgWidth * 12
            height += avgHeight * 12

            if (xPos < 0) xPos = 0
            if (yPos < 0) yPos = 0

            if (xPos >= orig.width || yPos >= orig.height) {
                val iv = window.findViewById<ImageView>(R.id.edit_kanji_image)
                iv.setBackgroundColor(0x44000000)
                return
            }

            if (width + xPos > orig.width) width = orig.width - xPos
            if (height + yPos > orig.height) height = orig.height - yPos

            if (width <= 0 || height <= 0) {
                val iv = window.findViewById<ImageView>(R.id.edit_kanji_image)
                iv.setBackgroundColor(0x44000000)
                return
            }

            Log.d(TAG, "After | Orig: (${orig.width}x${orig.height}) Box: ($xPos, $yPos) (${width}x${height})")

            val bitmapChar = Bitmap.createBitmap(orig, xPos, yPos, width, height)

            val iv = window.findViewById<ImageView>(R.id.edit_kanji_image)
            iv.setImageBitmap(bitmapChar)
        }
        else {
            val iv = window.findViewById<ImageView>(R.id.edit_kanji_image)
            iv.setBackgroundColor(0x44000000)
            return
        }
    }

    private fun calculateMedianSquareSize(squareChar: SquareCharOcr) : Point
    {
        val squareChars = (squareChar.displayData.squareChars as List<SquareCharOcr>).toList()
        val widths = squareChars.map { it.bitmapPos[2] - it.bitmapPos[0] }.sorted()
        val heights = squareChars.map { it.bitmapPos[3] - it.bitmapPos[1] }.sorted()

        return Point(widths[widths.size / 2], heights[heights.size / 2])
    }

    /**
     * We need to override here because we need cannot have the FLAG_NOT_FOCUSABLE flag set in [Window.getDefaultParams]
     */
    override fun getDefaultParams(): WindowManager.LayoutParams
    {
        val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT,
                if (Build.VERSION.SDK_INT > 25) WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY else WindowManager.LayoutParams.TYPE_PHONE,
                0,
                PixelFormat.TRANSLUCENT)
        params.x = 0
        params.y = 0
        return params
    }

    companion object
    {
        val TAG = EditWindow::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/HistoryWindow.kt">
package ca.fuwafuwa.gaku.Windows

import android.content.Context
import android.graphics.Color
import android.opengl.Visibility
import android.util.TypedValue
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup.LayoutParams.*
import android.widget.HorizontalScrollView
import android.widget.LinearLayout
import android.widget.TextView
import ca.fuwafuwa.gaku.DB_JMDICT_NAME
import ca.fuwafuwa.gaku.legacy.jmdict.models.EntryOptimized
import ca.fuwafuwa.gaku.LangUtils
import ca.fuwafuwa.gaku.R
import ca.fuwafuwa.gaku.Search.JmSearchResult
import ca.fuwafuwa.gaku.Windows.Data.ISquareChar
import ca.fuwafuwa.gaku.Windows.Enums.LayoutPosition
import ca.fuwafuwa.gaku.dpToPx

class HistoryWindow(context: Context,
                    windowCoordinator: WindowCoordinator) : Window(context, windowCoordinator, R.layout.window_history)
{
    private data class PastKanji(
            val kanji: String,
            val results: List<JmSearchResult>)
    {
        var timesSeen: Int = 0
    }

    private val container = window.findViewById<LinearLayout>(R.id.history_window_container)
    private val childKanji = container.findViewById<LinearLayout>(R.id.history_window_kanji)
    private val childResults = container.findViewById<LinearLayout>(R.id.history_window_results)
    private val changeLayoutButton = window.findViewById<TextView>(R.id.history_window_layout_button)

    private val maxShownHistory = 40
    private val normalHeight = dpToPx(context, 45)
    private val pastKanjiView = window.findViewById<LinearLayout>(R.id.past_kanji)!!
    private val pastKanjiScrollView = window.findViewById<HorizontalScrollView>(R.id.past_kanji_scroll_view)!!
    private val pastDictResults = window.findViewById<TextView>(R.id.history_dict_result)!!

    private var pastKanjis = mutableListOf<PastKanji>()
    private var isOnTop = true

    init
    {
        changeLayoutButton.setOnClickListener {
            isOnTop = !isOnTop
            relayoutWindow(if (isOnTop) LayoutPosition.TOP else LayoutPosition.BOTTOM)
        }

        val tv = createTextView(0)
        tv.text = "Lookup History"
        pastKanjiView.addView(tv)
    }

    override fun onTouch(e: MotionEvent?): Boolean
    {
        childResults.layoutParams.height = 0
        childKanji.visibility = View.VISIBLE

        params.height = normalHeight
        windowManager.updateViewLayout(window, params)

        return true
    }

    override fun onDown(e: MotionEvent): Boolean {
        return false
    }

    override fun onScroll(e1: MotionEvent?, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean
    {
        return false
    }

    override fun onResize(e: MotionEvent?): Boolean
    {
        return false
    }

    override fun show()
    {
        params.width = MATCH_PARENT
        params.height = normalHeight
        super.show()
    }

    /**
     * HistoryWindow does not need to reInit layout as its getDefaultParams() are all relative. Re-initing will cause bugs.
     */
    override fun reInit(options: Window.ReinitOptions)
    {
        options.reinitViewLayout = false
        super.reInit(options)
    }

    fun addResult(squareChar: ISquareChar, results: List<JmSearchResult>)
    {
        if (!squareChar.userTouched)
        {
            return
        }

        val word = results.first().entry.kanji

        if (pastKanjis.any { k -> k.kanji == word })
        {
            pastKanjis.first { k -> k.kanji == word }.timesSeen++
        }
        else
        {
            pastKanjis.add(PastKanji(word, results))
            if (pastKanjiView.childCount < maxShownHistory)
            {
                pastKanjiView.addView(createTextView(pastKanjis.size))
            }
        }

        recalculateViews()
    }

    @Synchronized private fun relayoutWindow(pos: LayoutPosition)
    {
        params.height = normalHeight

        val marginSize = dpToPx(context, 5)

        container.removeAllViews()

        if (pos == LayoutPosition.TOP)
        {
            val childResultsParams = childResults.layoutParams as LinearLayout.LayoutParams
            childResultsParams.setMargins(marginSize, marginSize, marginSize, 0)
            childResultsParams.height = 0
            childResults.layoutParams = childResultsParams

            val childKanjiParams = childKanji.layoutParams as LinearLayout.LayoutParams
            childKanjiParams.setMargins(marginSize, marginSize, marginSize, 0)
            childKanji.layoutParams = childKanjiParams

            changeLayoutButton.text = ""

            container.addView(childKanji)
            container.addView(childResults)
            container.gravity = Gravity.TOP

            params.y = 0
        }
        else if (pos == LayoutPosition.BOTTOM)
        {
            val childResultsParams = childResults.layoutParams as LinearLayout.LayoutParams
            childResultsParams.setMargins(marginSize, 0, marginSize, marginSize)
            childResultsParams.height = 0
            childResults.layoutParams = childResultsParams

            val childKanjiParams = childKanji.layoutParams as LinearLayout.LayoutParams
            childKanjiParams.setMargins(marginSize, 0, marginSize, marginSize)
            childKanji.layoutParams = childKanjiParams

            changeLayoutButton.text = ""

            container.addView(childResults)
            container.addView(childKanji)
            container.gravity = Gravity.BOTTOM

            params.y = viewHeight - normalHeight
        }

        windowManager.updateViewLayout(window, params)
    }

    private fun recalculateViews()
    {
        pastKanjis.sortByDescending { k -> k.timesSeen }
        pastKanjis = pastKanjis.take(100).toMutableList()

        for (i in 0 until pastKanjis.size)
        {
            if (i >= pastKanjiView.childCount)
            {
                break
            }
            (pastKanjiView.getChildAt(i) as TextView).text = pastKanjis[i].kanji
        }

        pastKanjiScrollView.scrollTo(0, 0)
    }

    private fun createTextView(index: Int) : TextView
    {
        val tv = TextView(context)
        val padding = dpToPx(context, 5)

        tv.setTextColor(Color.BLACK)
        tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15.toFloat())

        if (index == 0)
        {
            tv.setPadding(padding * 2, padding, padding, padding)
        }
        else if (index == maxShownHistory - 1)
        {
            tv.setPadding(padding, padding, padding * 2, padding)
        }
        else
        {
            tv.setPadding(padding, padding, padding, padding)
        }

        tv.setOnClickListener { v ->
            childKanji.visibility = View.GONE
            childKanji.requestLayout()
            showEntry(pastKanjiView.indexOfChild(v))
        }

        return tv
    }

    private fun showEntry(index: Int)
    {
        childResults.layoutParams.height = WRAP_CONTENT
        params.height = MATCH_PARENT
        windowManager.updateViewLayout(window, params)

        if (index < pastKanjis.size)
        {
            displayResults(pastKanjis[index].results)
        }
    }

    private fun displayResults(jmResults: List<JmSearchResult>)
    {
        val sb = StringBuilder()

        for ((entry, _) in jmResults)
        {
            sb.append(entry.kanji)

            if (!entry.readings.isEmpty())
            {
                if (DB_JMDICT_NAME == entry.dictionary)
                {
                    sb.append(" (")
                } else
                {
                    sb.append(" ")
                }
                sb.append(entry.readings)
                if (DB_JMDICT_NAME == entry.dictionary) sb.append(")")
            }

            sb.append("\n")
            sb.append(getMeaning(entry))
            sb.append("\n\n")
        }

        if (sb.length > 2)
        {
            sb.setLength(sb.length - 2)
        }

        pastDictResults.setText(sb.toString())
    }

    private fun getMeaning(entry: EntryOptimized): String
    {
        val meanings = entry.meanings.split("\ufffc".toRegex()).toTypedArray()
        val pos = entry.pos.split("\ufffc".toRegex()).toTypedArray()

        val sb = StringBuilder()

        for (i in meanings.indices)
        {
            if (i != 0)
            {
                sb.append(" ")
            }
            sb.append(LangUtils.ConvertIntToCircledNum(i + 1))
            sb.append(" ")
            if (DB_JMDICT_NAME == entry.dictionary && !pos[i].isEmpty())
            {
                sb.append(String.format("(%s) ", pos[i]))
            }
            sb.append(meanings[i])
        }

        return sb.toString()
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/InformationWindow.java">
package ca.fuwafuwa.gaku.Windows;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.graphics.PixelFormat;
import android.os.Build;
import android.util.Log;
import android.view.GestureDetector;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.WindowManager;
import android.widget.LinearLayout;
import android.widget.TextSwitcher;

import org.jetbrains.annotations.NotNull;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import ca.fuwafuwa.gaku.Constants;
import ca.fuwafuwa.gaku.legacy.jmdict.models.EntryOptimized;
import ca.fuwafuwa.gaku.GakuTools;
import ca.fuwafuwa.gaku.LangUtils;
import ca.fuwafuwa.gaku.R;
import ca.fuwafuwa.gaku.Search.JmSearchResult;
import ca.fuwafuwa.gaku.Search.SearchInfo;
import ca.fuwafuwa.gaku.Search.Searcher;
import ca.fuwafuwa.gaku.Windows.Data.DisplayData;
import ca.fuwafuwa.gaku.Windows.Data.ISquareChar;
import ca.fuwafuwa.gaku.Windows.Data.SquareChar;
import ca.fuwafuwa.gaku.Windows.Interfaces.ICopyText;
import ca.fuwafuwa.gaku.Windows.Interfaces.IRecalculateKanjiViews;
import ca.fuwafuwa.gaku.Windows.Interfaces.ISearchPerformer;
import ca.fuwafuwa.gaku.Windows.Views.KanjiGridView;

/**
 * Created by 0xbad1d3a5 on 4/23/2016.
 */
public class InformationWindow extends Window
        implements Searcher.SearchDictDone, IRecalculateKanjiViews, ISearchPerformer, ICopyText {

    private static final String TAG = InformationWindow.class.getName();
    private static final float FLICK_THRESHOLD = -0.05f;

    private GestureDetector mGestureDetector;
    private float mMaxFlingVelocity;
    private LinearLayout mInfoWindow;
    private KanjiGridView mKanjiGrid;
    private TextSwitcher mDictResults;
    private Searcher mSearcher;
    private boolean mTextOnlyLookup;
    private ArrayList<ISquareChar> mSearchedChars = new ArrayList<>();

    public InformationWindow(Context context, WindowCoordinator windowCoordinator) {
        super(context, windowCoordinator, R.layout.window_info);

        mMaxFlingVelocity = ViewConfiguration.get(this.context).getScaledMaximumFlingVelocity();
        mGestureDetector = new GestureDetector(this.context, this);
        mInfoWindow = window.findViewById(R.id.info_window);
        mKanjiGrid = window.findViewById(R.id.kanji_grid);
        mDictResults = window.findViewById(R.id.dict_results);

        mKanjiGrid.setDependencies(windowCoordinator, this);

        try {
            mSearcher = new Searcher(context);
            mSearcher.registerCallback(this);
        } catch (SQLException e) {
            e.printStackTrace();
        }

        show();
    }

    public void setResult(DisplayData displayData) {
        mSearchedChars = new ArrayList<>();

        mKanjiGrid.removeAllViews();
        mKanjiGrid.setText(displayData);
    }

    public void setResult(String textResult) {
        List<String> charList = GakuTools.splitTextByChar(textResult);
        List<ISquareChar> squareCharList = new ArrayList<>();
        DisplayData displayData = new DisplayData(squareCharList);
        for (String c : charList)
            squareCharList.add(new SquareChar(displayData, c));
        displayData.assignIndicies();

        mKanjiGrid.setText(displayData);
        performSearch(displayData.getSquareChars().get(0));

        mTextOnlyLookup = true;
    }

    public void copyText() {
        ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
        ClipData clip = ClipData.newPlainText(null, mKanjiGrid.getText());
        clipboard.setPrimaryClip(clip);

        hide();
    }

    @Override
    public void performSearch(@NotNull ISquareChar squareChar) {
        Log.d(TAG, squareChar.getChar());

        // 1. The KanjiCharacterView has already highlighted itself in its onSingleTapUp method.
        // 2. We call unhighlightAll(squareChar) to remove highlights from any PREVIOUSLY selected words,
        //    passing 'squareChar' as the exception so we don't turn off the one the user just touched.
        mKanjiGrid.unhighlightAll(squareChar);

        mSearcher.search(new SearchInfo(squareChar));
    }

    /**
     * InformationWindow does not need to reInit layout as its getDefaultParams()
     * are all relative. Re-initing will cause bugs.
     */
    @Override
    public void reInit(ReinitOptions options) {
        options.reinitViewLayout = false;
        super.reInit(options);
    }

    @Override
    protected WindowManager.LayoutParams getDefaultParams() {
        WindowManager.LayoutParams params = new WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT,
                Build.VERSION.SDK_INT > 25 ? WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
                        : WindowManager.LayoutParams.TYPE_PHONE,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
                PixelFormat.TRANSLUCENT);
        params.x = 0;
        params.y = 0;
        params.gravity = Gravity.TOP | Gravity.CENTER;
        params.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING
                | WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE;
        return params;
    }

    @Override
    public boolean onTouch(MotionEvent e) {
        mGestureDetector.onTouchEvent(e);

        if (e.getAction() == MotionEvent.ACTION_UP) {
            params.y = 0;
            windowManager.updateViewLayout(window, params);
            return true;
        }

        return false;
    }

    @Override
    public void show() {
        mDictResults.setText("");

        window.setVisibility(View.VISIBLE);
        params.y = 0; // onScroll changes this value
        super.show();
        window.setY(0); // translationY changes this value
    }

    @Override
    public void hide() {
        window.animate().translationY(-getRealDisplaySize().y).setListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                window.setVisibility(View.INVISIBLE);

                if (!mTextOnlyLookup) {
                    InformationWindow.super.hide();
                } else {
                    // hide() may have been called multiple times - this isn't thread-safe but
                    // whatever
                    if (windowCoordinator != null) {
                        windowCoordinator.stopAllWindows();
                    }
                }
            }
        });
    }

    @Override
    public void stop() {
        mSearcher.unregisterCallback();
        super.stop();
    }

    @Override
    public boolean onResize(MotionEvent e) {
        return false;
    }

    @Override
    public boolean onDown(MotionEvent motionEvent) {
        return true;
    }

    @Override
    public boolean onDoubleTap(MotionEvent e) {
        if (mInfoWindow.getX() < e.getX() && e.getX() < (mInfoWindow.getX() + mInfoWindow.getWidth()) &&
                mInfoWindow.getY() < e.getY() && e.getY() < (mInfoWindow.getY() + mInfoWindow.getHeight())) {
            // Do nothing
        } else {
            hide();
        }

        return true;
    }

    private void clearCurrentDefinition() {
        mKanjiGrid.clearSelection();
        mDictResults.setText("");
        // Optional: Animate the text switcher out or set visibility
    }

    @Override
    public boolean onSingleTapUp(MotionEvent e) {
        // Logic: If the tap hits a specific character, that View handles it and returns
        // true.
        // If we reach here, it means we clicked empty space or the background.

        // Check if click is inside the KanjiGrid area (but missed a char) or ScrollView
        if (e.getY() < mKanjiGrid.getY() + mKanjiGrid.getHeight()) {
            int triggerAreaSize = getViewWidth() / 8;

            // Check for scroll zones first
            if (e.getX() > getViewWidth() - triggerAreaSize) {
                mKanjiGrid.scrollNext();
            } else if (e.getX() < triggerAreaSize) {
                mKanjiGrid.scrollPrev();
            } else {
                // Clicked inside grid but not on a char (blank space)
                clearCurrentDefinition();
            }
        }
        // Check if click is inside the InfoWindow background but not on the grid
        else if (mInfoWindow.getX() < e.getX() && e.getX() < (mInfoWindow.getX() + mInfoWindow.getWidth()) &&
                mInfoWindow.getY() < e.getY() && e.getY() < (mInfoWindow.getY() + mInfoWindow.getHeight())) {
            // Clicked inside the text result area (but not a link/interaction)
            // Decide if you want this to close definition or do nothing.
            // For now: clear definition if it's just blank space in the text area
            // clearCurrentDefinition();

            // OR keep existing behavior (Do nothing)
        } else {
            // Clicked outside the floating window entirely -> Close Window
            hide();
        }

        return true;
    }

    @Override
    public boolean onScroll(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) {
        if (motionEvent == null || motionEvent1 == null) {
            return false;
        }

        params.y = (int) (motionEvent1.getRawY() - motionEvent.getRawY());
        if (params.y > 0) {
            params.y = 0;
        }
        windowManager.updateViewLayout(window, params);

        return true;
    }

    @Override
    public boolean onFling(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) {
        if (motionEvent == null || motionEvent1 == null) {
            return false;
        }

        float distanceMoved = motionEvent.getRawY() - motionEvent1.getRawY();

        Log.d(TAG, String.format("Fling strength: %f", v1 / mMaxFlingVelocity));
        Log.d(TAG, String.format("Distance moved: %f", distanceMoved));

        if ((v1 / mMaxFlingVelocity) < FLICK_THRESHOLD) {
            hide();
            return true;
        }

        return false;
    }

    @Override
    public void jmResultsCallback(List<JmSearchResult> results, SearchInfo search) {
        windowCoordinator.getWindow(Constants.WINDOW_INSTANT_KANJI).hide();

        if (results.size() > 0) {
            displayResults(results);

            if (search.getSquareChar().getUserTouched() && !mSearchedChars.contains(search.getSquareChar())) {
                // windowCoordinator.<HistoryWindow>getWindowOfType(Constants.WINDOW_HISTORY).addResult(search.getSquareChar(),
                // results);
                mSearchedChars.add(search.getSquareChar());
            }
        }

        // Highlights words in the window as long as they match
        int start = search.getIndex() - mKanjiGrid.getOffset();
        if (results.size() > 0) {
            String kanji = results.get(0).getWord();
            for (int i = start; i < start + kanji.codePointCount(0, kanji.length()); i++) {
                if (i >= mKanjiGrid.getKanjiViewList().size()) {
                    break;
                }
                mKanjiGrid.getKanjiViewList().get(i).highlight();
            }
        } else {
            mKanjiGrid.getKanjiViewList().get(start).highlight();
        }
    }

    @Override
    public void recalculateKanjiViews() {
        mKanjiGrid.recalculateKanjiViews();
    }

    private void displayResults(List<JmSearchResult> jmResults) {
        StringBuilder sb = new StringBuilder();

        for (JmSearchResult jmSearchResult : jmResults) {
            sb.append(jmSearchResult.getEntry().getKanji());

            if (!jmSearchResult.getEntry().getReadings().isEmpty()) {
                if (Constants.DB_JMDICT_NAME.equals(jmSearchResult.getEntry().getDictionary())) {
                    sb.append(" (");
                } else {
                    sb.append(" ");
                }
                sb.append(jmSearchResult.getEntry().getReadings());
                if (Constants.DB_JMDICT_NAME.equals(jmSearchResult.getEntry().getDictionary()))
                    sb.append(")");
            }

            String deinfReason = jmSearchResult.getDeinfInfo().getReason();
            if (deinfReason != null && !deinfReason.isEmpty()) {
                sb.append(String.format(" %s", deinfReason));
            }

            sb.append("\n");
            sb.append(getMeaning(jmSearchResult.getEntry()));
            sb.append("\n\n");
        }

        if (sb.length() > 2) {
            sb.setLength(sb.length() - 2);
        }

        mDictResults.setText(sb.toString());
    }

    private String getMeaning(EntryOptimized entry) {
        String[] meanings = entry.getMeanings().split("\ufffc", -1);
        String[] pos = entry.getPos().split("\ufffc", -1);

        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < meanings.length; i++) {
            if (i != 0) {
                sb.append(" ");
            }
            sb.append(LangUtils.Companion.ConvertIntToCircledNum(i + 1));
            sb.append(" ");
            if (Constants.DB_JMDICT_NAME.equals(entry.getDictionary()) && !pos[i].isEmpty()) {
                sb.append(String.format("(%s) ", pos[i]));
            }
            sb.append(meanings[i]);
        }

        return sb.toString();
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/InstantInfoWindow.kt">
package ca.fuwafuwa.gaku.Windows

import android.content.Context
import android.graphics.Color
import android.util.Log
import android.view.MotionEvent
import android.view.View.INVISIBLE
import android.view.View.VISIBLE
import android.widget.FrameLayout
import android.widget.LinearLayout
import android.widget.TextView
import ca.fuwafuwa.gaku.*
import ca.fuwafuwa.gaku.legacy.jmdict.models.EntryOptimized

import ca.fuwafuwa.gaku.Search.JmSearchResult
import ca.fuwafuwa.gaku.Search.SearchInfo
import ca.fuwafuwa.gaku.Search.Searcher
import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr
import ca.fuwafuwa.gaku.Windows.Data.ISquareChar
import ca.fuwafuwa.gaku.Windows.Enums.LayoutPosition
import ca.fuwafuwa.gaku.Windows.Interfaces.IRecalculateKanjiViews
import ca.fuwafuwa.gaku.Windows.Interfaces.ISearchPerformer

class InstantInfoWindow(context: Context,
                        windowCoordinator: WindowCoordinator,
                        private val instantKanjiWindow: InstantKanjiWindow) : Window(context, windowCoordinator, R.layout.window_instant_info), Searcher.SearchDictDone, IRecalculateKanjiViews, ISearchPerformer
{
    private val isBoxHorizontal: Boolean
        get()
        {
            return displayData.boxParams.width > displayData.boxParams.height;
        }

    private val paddingSize = dpToPx(context, 5)

    private lateinit var layoutPosition: LayoutPosition

    private lateinit var displayData: DisplayDataOcr

    private var searcher: Searcher = Searcher(context)

    private var searchedChars: MutableList<ISquareChar> = mutableListOf()

    private var textInfo = window.findViewById<TextView>(R.id.instant_window_text)

    private var textFrame = window.findViewById<LinearLayout>(R.id.instant_window_text_frame)

    private var updateView = false

    init
    {
        searcher.registerCallback(this)

        textFrame.addOnLayoutChangeListener { v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom ->
            run {
                if (updateView)
                {
                    val width = v.width + dpToPx(context, 10)
                    val height = v.height + dpToPx(context, 10)

                    if (isBoxHorizontal)
                    {
                        calcParamsForHorizontal(width, height)
                    } else
                    {
                        calcParamsForVertical(width, height)
                    }

                    window.visibility = VISIBLE
                    windowManager.updateViewLayout(window, params)
                    updateView = false
                    Log.d(TAG, "layoutChanged - InstantInfoWindow")
                }
            }
        }
    }

    override fun onDown(e: MotionEvent): Boolean
    {
        instantKanjiWindow.hide()
        return super.onDown(e)
    }

    override fun onScroll(e1: MotionEvent?, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean
    {
        return false
    }

    override fun onResize(e: MotionEvent?): Boolean
    {
        return false
    }

    override fun onShowPress(e: MotionEvent) {
    }

    override fun onSingleTapUp(e: MotionEvent): Boolean {
        return false
    }

    override fun onFling(e1: MotionEvent?, e2: MotionEvent, velocityX: Float, velocityY: Float): Boolean {
        return false
    }

    override fun show()
    {
        synchronized(this)
        {
            if (!addedToWindowManager)
            {
                textInfo.text = displayData.text
                textInfo.setTextColor(Color.BLACK)

                if (isBoxHorizontal)
                {
                    val topRectHeight = displayData.boxParams.y - statusBarHeight
                    val bottomRectHeight = realDisplaySize.y - displayData.boxParams.y - displayData.boxParams.height - (realDisplaySize.y - viewHeight - statusBarHeight)
                    val maxHeight = dpToPx(context, 600)
                    var height: Int

                    if (topRectHeight > bottomRectHeight){
                        layoutPosition = LayoutPosition.TOP
                        height = topRectHeight
                    }
                    else {
                        layoutPosition = LayoutPosition.BOTTOM
                        height = bottomRectHeight
                    }

                    height = minOf(height, maxHeight)
                    calcParamsForHorizontal(dpToPx(context, 400), height)
                } else
                {
                    val leftRectWidth = displayData.boxParams.x
                    val rightRectWidth = viewWidth - (displayData.boxParams.x + displayData.boxParams.width)
                    val maxWidth = dpToPx(context, 400)
                    var width: Int

                    if (leftRectWidth > rightRectWidth)
                    {
                        layoutPosition = LayoutPosition.LEFT
                        width = leftRectWidth
                    }
                    else {
                        layoutPosition = LayoutPosition.RIGHT
                        width = rightRectWidth
                    }

                    width = minOf(width, maxWidth)
                    calcParamsForVertical(width, dpToPx(context, 600))
                }

                window.visibility = INVISIBLE
                windowManager.addView(window, params)
                addedToWindowManager = true
            }
        }
    }

    override fun jmResultsCallback(results: MutableList<JmSearchResult>, search: SearchInfo)
    {
        show()
        updateView = true
        if (results.size > 0)
        {
            if (search.squareChar.userTouched && !searchedChars.contains(search.squareChar))
            {
                //windowCoordinator.getWindowOfType<HistoryWindow>(WINDOW_HISTORY).addResult(search.squareChar, results)
                searchedChars.add(search.squareChar)
            }

            displayResults(results)
        }
        else
        {
            textInfo.text = "No dictionary entry found"
        }

        // Highlights words in the window as long as they match
        val start = search.index - instantKanjiWindow.getKanjiView().offset
        if (results.size > 0)
        {
            val kanji = results[0].word
            for (i in start until start + kanji.codePointCount(0, kanji.length))
            {
                if (i >= instantKanjiWindow.getKanjiView().kanjiViewList.size)
                {
                    break
                }
                instantKanjiWindow.getKanjiView().kanjiViewList[i].highlight()
            }
        } else
        {
            instantKanjiWindow.getKanjiView().kanjiViewList[start].highlight()
        }
    }

    override fun recalculateKanjiViews()
    {
        instantKanjiWindow.recalculateKanjiViews()
    }

    override fun performSearch(squareChar: ISquareChar)
    {
        hide()
        instantKanjiWindow.getKanjiView().unhighlightAll(squareChar)
        searcher.search(SearchInfo(squareChar))
    }

    fun setResult(result: DisplayDataOcr)
    {
        displayData = result
        searchedChars = mutableListOf()
    }

    private fun changeLayoutForKanjiWindow()
    {
        if (instantKanjiWindow.getLayoutPosition() != layoutPosition)
        {
            setPadding(paddingSize, paddingSize, paddingSize, paddingSize)
            return
        }

        var kanjiWindowSize = if (isBoxHorizontal) instantKanjiWindow.getHeight() else instantKanjiWindow.getWidth()

        when(layoutPosition)
        {
            LayoutPosition.TOP ->
            {
                kanjiWindowSize -= dpToPx(context, 5)
                params.y -= kanjiWindowSize

                if (params.y < 0)
                {
                    params.height += params.y
                    params.y = 0
                }

                setPadding(paddingSize, paddingSize, paddingSize, 0)
            }
            LayoutPosition.BOTTOM ->
            {
                params.y += kanjiWindowSize

                if (params.y + params.height > viewHeight)
                {
                    val overflowHeight = params.y + params.height - viewHeight
                    params.height -= overflowHeight
                }

                setPadding(paddingSize, 0, paddingSize, paddingSize)
            }
            LayoutPosition.LEFT ->
            {
                kanjiWindowSize += dpToPx(context, 5)
                params.x -= kanjiWindowSize

                if (params.x < 0)
                {
                    params.width += params.x
                    params.x = 0
                }

                setPadding(paddingSize, paddingSize, 0, paddingSize)
            }
            LayoutPosition.RIGHT ->
            {
                kanjiWindowSize += dpToPx(context, 5)
                params.x += kanjiWindowSize

                if (params.x + params.width > realDisplaySize.x)
                {
                    val overflowWidth = params.x + params.width - realDisplaySize.x
                    params.width -= overflowWidth
                }

                setPadding(0, paddingSize, paddingSize, paddingSize)
            }
        }
    }

    private fun displayResults(jmResults: List<JmSearchResult>)
    {
        val sb = StringBuilder()

        for ((entry, deinfInfo) in jmResults)
        {
            sb.append(entry.kanji)

            if (!entry.readings.isEmpty())
            {
                if (DB_JMDICT_NAME == entry.dictionary)
                {
                    sb.append(" (")
                } else
                {
                    sb.append(" ")
                }
                sb.append(entry.readings)
                if (DB_JMDICT_NAME == entry.dictionary) sb.append(")")
            }

            val deinfReason = deinfInfo!!.reason
            if (deinfReason != null && !deinfReason.isEmpty())
            {
                sb.append(String.format(" %s", deinfReason))
            }

            sb.append("\n")
            sb.append(getMeaning(entry))
            sb.append("\n\n")
        }

        if (sb.length > 2)
        {
            sb.setLength(sb.length - 2)
        }

        textInfo.text = sb.toString()
    }

    private fun getMeaning(entry: EntryOptimized): String
    {
        val meanings = entry.meanings.split("\ufffc".toRegex()).toTypedArray()
        val pos = entry.pos.split("\ufffc".toRegex()).toTypedArray()

        val sb = StringBuilder()

        for (i in meanings.indices)
        {
            if (i > 2)
            {
                sb.append(" [......]")
                break
            }
            if (i != 0)
            {
                sb.append(" ")
            }
            sb.append(LangUtils.ConvertIntToCircledNum(i + 1))
            sb.append(" ")
            if (DB_JMDICT_NAME == entry.dictionary && !pos[i].isEmpty())
            {
                sb.append(String.format("(%s) ", pos[i]))
            }
            sb.append(meanings[i])
        }

        return sb.toString()
    }

    private fun setPadding(l: Int, t: Int, r: Int, b: Int)
    {
        val frameLayout = window.findViewById<FrameLayout>(R.id.instant_info_window_layout)
        frameLayout.setPadding(l, t, r, b)
    }

    private fun calcParamsForHorizontal(maxWidth: Int, maxHeight: Int)
    {
        var xPos = displayData.boxParams.x

        if (xPos + maxWidth > realDisplaySize.x)
        {
            xPos = realDisplaySize.x - maxWidth
        }

        params.width = maxWidth

        if (layoutPosition == LayoutPosition.TOP){
            params.x = xPos
            params.y = displayData.boxParams.y - maxHeight - statusBarHeight
            params.height = maxHeight
        }
        else {
            params.x = xPos
            params.y = displayData.boxParams.y + displayData.boxParams.height - statusBarHeight
            params.height = maxHeight
        }

        changeLayoutForKanjiWindow()
    }

    private fun calcParamsForVertical(maxWidth: Int, maxHeight: Int)
    {
        var yPos = displayData.boxParams.y - statusBarHeight

        if (yPos + maxHeight > realDisplaySize.y){
            yPos = viewHeight - maxHeight
        }

        params.height = maxHeight

        if (layoutPosition == LayoutPosition.LEFT)
        {
            var xPos = displayData.boxParams.x - maxWidth

            if (xPos < 0)
            {
                xPos = 0
            }

            params.x = xPos
            params.y = yPos
            params.width = maxWidth
        }
        else {
            var xPos = displayData.boxParams.x + displayData.boxParams.width

            params.x = xPos
            params.y = yPos
            params.width = maxWidth
        }

        changeLayoutForKanjiWindow()
    }

    companion object
    {
        val TAG = InstantInfoWindow::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/InstantKanjiWindow.kt">
package ca.fuwafuwa.gaku.Windows

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.util.Log
import android.view.MotionEvent
import android.view.View
import android.view.View.INVISIBLE
import android.widget.LinearLayout
import ca.fuwafuwa.gaku.R
import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr
import ca.fuwafuwa.gaku.Windows.Enums.LayoutPosition
import ca.fuwafuwa.gaku.Windows.Interfaces.ICopyText
import ca.fuwafuwa.gaku.Windows.Interfaces.IRecalculateKanjiViews
import ca.fuwafuwa.gaku.Windows.Views.KanjiGridView
import ca.fuwafuwa.gaku.dpToPx


class InstantKanjiWindow(context: Context,
                         windowCoordinator: WindowCoordinator) : Window(context, windowCoordinator, R.layout.window_instant_kanji), IRecalculateKanjiViews, ICopyText
{
    private val isBoxHorizontal: Boolean
        get()
        {
            return displayData.boxParams.width > displayData.boxParams.height;
        }

    private lateinit var displayData: DisplayDataOcr

    private lateinit var layoutPosition: LayoutPosition

    private val kanjiGrid = window.findViewById<View>(R.id.kanji_grid) as KanjiGridView

    private val kanjiFrame = window.findViewById<LinearLayout>(R.id.instant_window_kanji_frame)

    private val instantInfoWindow = InstantInfoWindow(context, windowCoordinator, this)

    private val minHeight = dpToPx(context, 65)

    private val minWidth = dpToPx(context, 65)

    init
    {
        kanjiGrid.setDependencies(windowCoordinator, instantInfoWindow)

        kanjiFrame.addOnLayoutChangeListener { v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom ->
            run {
                var count = displayData.count + 1
                if (isBoxHorizontal)
                {
                    count = if (count > 8) 8 else count
                    params.width = dpToPx(context, 37) * count
                    if (params.height < minHeight)
                    {
                        params.height = minHeight
                    }
                }
                else {
                    count = if (count > 9) 9 else count
                    params.height = dpToPx(context, 37) * count
                    if (params.width < minWidth)
                    {
                        params.width = minWidth
                    }
                }

                when (layoutPosition)
                {
                    LayoutPosition.TOP ->
                    {
                        params.y = displayData.boxParams.y - (params.height + statusBarHeight)
                    }
                    LayoutPosition.BOTTOM ->
                    {
                        params.y = displayData.boxParams.y + displayData.boxParams.height - statusBarHeight
                    }
                    LayoutPosition.LEFT ->
                    {
                        params.x = displayData.boxParams.x - params.width
                    }
                    LayoutPosition.RIGHT ->
                    {
                        params.x = displayData.boxParams.x + displayData.boxParams.width
                    }
                }

                if (isBoxHorizontal)
                {
                    calcParamsForHorizontal(params.width)
                } else
                {
                    calcParamsForVertical(params.height)
                }

                window.visibility = View.VISIBLE
                windowManager.updateViewLayout(window, params)
                Log.d(TAG, "layoutChanged - InstantKanjiWindow")
            }
        }
    }

    fun getLayoutPosition() : LayoutPosition
    {
        return layoutPosition
    }

    fun getWidth() : Int
    {
        return window.width
    }

    fun getHeight() : Int
    {
        return window.height
    }

    fun setResult(result: DisplayDataOcr)
    {
        displayData = result
        instantInfoWindow.setResult(result)
        instantInfoWindow.performSearch(displayData.squareChars[0])
    }

    override fun recalculateKanjiViews()
    {
        kanjiGrid.recalculateKanjiViews()
    }

    override fun copyText()
    {
        val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText(null, kanjiGrid.getText())
        clipboard.setPrimaryClip(clip)

        hide()
    }

    override fun hide()
    {
        instantInfoWindow.hide()
        super.hide()
    }

    override fun stop()
    {
        instantInfoWindow.stop()
        super.stop()
    }

    override fun show()
    {
        synchronized(this)
        {
            if (!addedToWindowManager)
            {
                if (isBoxHorizontal)
                {
                    kanjiGrid.setRowLimit(1)
                    calcParamsForHorizontal(dpToPx(context, 300))
                } else
                {
                    kanjiGrid.setRowLimit(2)
                    calcParamsForVertical(dpToPx(context, 320))
                }

                kanjiGrid.clearText()
                kanjiGrid.setText(displayData)

                window.visibility = INVISIBLE
                windowManager.addView(window, params)
                addedToWindowManager = true
            }
        }

        instantInfoWindow.show()
    }

    override fun reInit(options: ReinitOptions?)
    {
        instantInfoWindow.reInit(options)
        super.reInit(options)
    }

    override fun onTouch(e: MotionEvent?): Boolean
    {
        return false
    }

    override fun onDown(e: MotionEvent): Boolean {
        return false
    }

    override fun onScroll(e1: MotionEvent?, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean
    {
        return false
    }

    override fun onResize(e: MotionEvent?): Boolean
    {
        return false
    }

    fun getKanjiView() : KanjiGridView
    {
        return kanjiGrid
    }

    private fun calcParamsForHorizontal(maxWidth: Int)
    {
        val topRectHeight = displayData.boxParams.y - statusBarHeight
        val bottomRectHeight = realDisplaySize.y - displayData.boxParams.y - displayData.boxParams.height - (realDisplaySize.y - viewHeight - statusBarHeight)

        var xPos = displayData.boxParams.x
        var maxWidth = minOf(realDisplaySize.x, maxWidth)

        if (xPos + maxWidth > realDisplaySize.x)
        {
            xPos = viewWidth - maxWidth
        }

        params.width = maxWidth

        val drawOnTop = fun()
        {
            params.x = xPos
            params.y = displayData.boxParams.y - (minHeight + statusBarHeight)
            params.height = minHeight
            layoutPosition = LayoutPosition.TOP
        }

        val drawOnBottom = fun()
        {
            params.x = xPos
            params.y = displayData.boxParams.y + displayData.boxParams.height - statusBarHeight
            params.height = minHeight
            layoutPosition = LayoutPosition.BOTTOM
        }

        if (topRectHeight < bottomRectHeight)
        {
            if (topRectHeight > minHeight)
            {
                drawOnTop()
            }
            else {
                drawOnBottom()
            }
        }
        else {
            if (bottomRectHeight > minHeight)
            {
                drawOnBottom()
            }
            else {
                drawOnTop()
            }
        }
    }

    private fun calcParamsForVertical(maxHeight: Int)
    {
        val leftRectWidth = displayData.boxParams.x
        val rightRectWidth = viewWidth - (displayData.boxParams.x + displayData.boxParams.width)

        var yPos = displayData.boxParams.y - statusBarHeight

        var maxHeight = minOf(maxHeight, realDisplaySize.y)

        if (yPos + maxHeight > realDisplaySize.y)
        {
            yPos = viewHeight - maxHeight
        }

        params.height = maxHeight

        val drawOnLeftSide = fun()
        {
            var xPos = displayData.boxParams.x - minWidth

            if (xPos < 0)
            {
                xPos = 0
            }

            params.x = xPos
            params.y = yPos
            params.width = minOf(leftRectWidth, minWidth)
            layoutPosition = LayoutPosition.LEFT
        }

        val drawOnRightSide = fun()
        {
            var xPos = displayData.boxParams.x + displayData.boxParams.width

            params.x = xPos
            params.y = yPos
            params.width = minOf(rightRectWidth, minWidth)
            layoutPosition = LayoutPosition.RIGHT
        }

        if (leftRectWidth < rightRectWidth)
        {
            if (leftRectWidth > minWidth)
            {
                drawOnLeftSide()
            }
            else {
                drawOnRightSide()
            }
        }
        else {
            if (rightRectWidth > minWidth)
            {
                drawOnRightSide()
            }
            else {
                drawOnLeftSide()
            }
        }
    }

    companion object
    {
        val TAG = InstantKanjiWindow::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/KanjiChoiceWindow.kt">
package ca.fuwafuwa.gaku.Windows

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Color
import android.graphics.PixelFormat
import android.os.Build
import android.util.TypedValue
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.view.WindowManager
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.RelativeLayout
import android.widget.TextView
import androidx.core.content.ContextCompat
import ca.fuwafuwa.gaku.LangUtils
import ca.fuwafuwa.gaku.Ocr.BoxParams
import ca.fuwafuwa.gaku.R
import ca.fuwafuwa.gaku.Windows.Data.ISquareChar
import ca.fuwafuwa.gaku.Windows.Data.SquareCharOcr
import ca.fuwafuwa.gaku.dpToPx

enum class ChoiceResultType
{
    EDIT,
    DELETE,
    SWAP,
    NONE
}

class KanjiChoiceWindow(context: Context, windowCoordinator: WindowCoordinator) : Window(context, windowCoordinator, R.layout.window_kanji_choice)
{
    private val choiceWindow = window.findViewById<RelativeLayout>(R.id.kanji_choice_window)!!
    private val currentKanjiViews = mutableListOf<View>()

    private lateinit var mKanjiBoxParams : BoxParams

    private var drawnOnTop = false

    /**
     * KanjiChoiceWindow does not need to reInit layout as its getDefaultParams() are all relative. Re-initing will cause bugs.
     */
    override fun reInit(options: Window.ReinitOptions)
    {
        options.reinitViewLayout = false
        super.reInit(options)
    }

    fun onSquareScrollStart(squareChar: ISquareChar, kanjiBoxParams: BoxParams)
    {
        if (squareChar !is SquareCharOcr)
        {
            show()

            mKanjiBoxParams = kanjiBoxParams
            mKanjiBoxParams.y -= statusBarHeight

            return
        }

        val topRectHeight = kanjiBoxParams.y - statusBarHeight
        val bottomRectHeight = realDisplaySize.y - kanjiBoxParams.y - kanjiBoxParams.height - (realDisplaySize.y - viewHeight - statusBarHeight)

        if (bottomRectHeight > topRectHeight)
        {
            drawnOnTop = false
            drawOnBottom(squareChar, kanjiBoxParams, calculateBounds(kanjiBoxParams, topRectHeight, bottomRectHeight))
        }
        else
        {
            drawnOnTop = true
            drawOnTop(squareChar, kanjiBoxParams, calculateBounds(kanjiBoxParams, topRectHeight, bottomRectHeight))
        }

        mKanjiBoxParams = kanjiBoxParams
        mKanjiBoxParams.y -= statusBarHeight

        show()
    }

    fun onSquareScroll(e: MotionEvent) : Int
    {
        var inKanji = false

        for (kanjiView in currentKanjiViews)
        {
            val isTextView = kanjiView is TextView

            if (checkForSelection(kanjiView, e) && isTextView)
            {
                inKanji = true
                kanjiView.setBackgroundResource(R.drawable.bg_solid_border_0_blue_black)
            }
            else if (isTextView)
            {
                kanjiView.setBackgroundResource(R.drawable.bg_solid_border_0_white_black)
            }
        }

        return when (getResultTypeForMotionEvent(e, inKanji, drawnOnTop))
        {
            ChoiceResultType.EDIT ->
            {
                R.drawable.icon_edit
            }
            ChoiceResultType.DELETE ->
            {
                R.drawable.icon_delete
            }
            else ->
            {
                R.drawable.icon_swap
            }
        }
    }

    fun onSquareScrollEnd(e: MotionEvent) : Pair<ChoiceResultType, String>
    {
        var swappedKanji = ""

        for (kanjiView in currentKanjiViews)
        {
            if (checkForSelection(kanjiView, e) && kanjiView is TextView)
            {
                swappedKanji = kanjiView.text.toString()
            }
        }

        removeKanjiViews()
        hide()

        return Pair(getResultTypeForMotionEvent(e, swappedKanji != "", drawnOnTop), swappedKanji)
    }

    private fun getResultTypeForMotionEvent(e: MotionEvent, inKanji: Boolean, drawnOnTop: Boolean) : ChoiceResultType
    {
        if (inKanji)
        {
            return ChoiceResultType.SWAP
        }

        val midpoint = mKanjiBoxParams.x + (mKanjiBoxParams.width / 2)
        val height = if (drawnOnTop) mKanjiBoxParams.y + mKanjiBoxParams.height + statusBarHeight else mKanjiBoxParams.y + statusBarHeight

        return if (e.rawX < midpoint && heightCheckForResult(e, height, drawnOnTop))
        {
            ChoiceResultType.EDIT
        }
        else if (e.rawX > midpoint && heightCheckForResult(e, height, drawnOnTop))
        {
            ChoiceResultType.DELETE
        }
        else
        {
            ChoiceResultType.NONE
        }
    }

    private fun heightCheckForResult(e: MotionEvent, height: Int, drawnOnTop: Boolean) : Boolean
    {
        return if (drawnOnTop) e.rawY > height else e.rawY < height
    }

    private fun checkForSelection(kanjiView: View, e: MotionEvent): Boolean
    {
        var pos = IntArray(2)
        kanjiView.getLocationOnScreen(pos)

        return pos[0] < e.rawX && e.rawX < pos[0] + kanjiView.width &&
               pos[1] < e.rawY && e.rawY < pos[1] + kanjiView.height
    }

    private fun removeKanjiViews()
    {
        for (k in currentKanjiViews)
        {
            choiceWindow.removeView(k)
        }

        currentKanjiViews.clear()
    }

    private fun calculateBounds(kanjiBoxParams: BoxParams, topRectHeight: Int, bottomRectHeight: Int) : BoxParams
    {
        val midPoint = kanjiBoxParams.x + (kanjiBoxParams.width / 2)
        var maxWidth = dpToPx(context, 400)
        var xPos = 0

        if (realDisplaySize.x > maxWidth)
        {
            xPos = midPoint - (maxWidth / 2)
            if (xPos < 0)
            {
                xPos = 0
            }
            else if (xPos + maxWidth > realDisplaySize.x)
            {
                xPos = realDisplaySize.x - maxWidth
            }
        }

        maxWidth = minOf(realDisplaySize.x, maxWidth)

        if (topRectHeight > bottomRectHeight)
        {
            return BoxParams(xPos, 0, maxWidth, topRectHeight)
        }
        else
        {
            return BoxParams(xPos, kanjiBoxParams.y + kanjiBoxParams.height - statusBarHeight, maxWidth, bottomRectHeight)
        }
    }

    private fun drawOnBottom(squareChar: SquareCharOcr, kanjiBoxParams: BoxParams, choiceParams: BoxParams)
    {
        val kanjiHeight = kanjiBoxParams.height * 2
        val kanjiWidth = kanjiBoxParams.width * 2

        val outerPadding = dpToPx(context, 10)
        val startHeight = choiceParams.y + outerPadding

        val drawableWidth = choiceParams.width - outerPadding
        val minPadding = dpToPx(context, 5)
        val numColumns = minOf(calculateNumColumns(drawableWidth, kanjiWidth, minPadding), squareChar.allChoices.size + 1)
        val outerSpacing = (choiceParams.width - (kanjiWidth + minPadding * 2) * numColumns) / 2
        val innerSpacing = minPadding

        var currColumn = 0
        var currWidth = choiceParams.x + outerSpacing + innerSpacing
        var currHeight = startHeight

        drawKanjiImage(squareChar, currWidth, currHeight, kanjiWidth, kanjiHeight)
        currWidth += kanjiWidth + innerSpacing
        currColumn++

        for (choice in squareChar.allChoices)
        {
            if (currColumn >= numColumns)
            {
                currHeight += kanjiHeight + innerSpacing
                currWidth = choiceParams.x + outerSpacing + innerSpacing
                currColumn = 0
            }

            drawKanjiText(choice.first, currWidth, currHeight, kanjiWidth, kanjiHeight)
            currWidth += kanjiWidth + innerSpacing
            currColumn++
        }
    }

    private fun drawOnTop(squareChar: SquareCharOcr, kanjiBoxParams: BoxParams, choiceParams: BoxParams)
    {
        val kanjiHeight = kanjiBoxParams.height * 2
        val kanjiWidth = kanjiBoxParams.width * 2

        val outerPadding = dpToPx(context, 10)
        val startHeight = kanjiBoxParams.y - statusBarHeight - kanjiHeight - outerPadding

        val drawableWidth = choiceParams.width - outerPadding
        val minPadding = dpToPx(context, 5)
        val numColumns = minOf(calculateNumColumns(drawableWidth, kanjiWidth, minPadding), squareChar.allChoices.size + 1)
        val outerSpacing = (choiceParams.width - (kanjiWidth + minPadding * 2) * numColumns) / 2
        val innerSpacing = minPadding

        var currColumn = 0
        var currWidth = choiceParams.x + outerSpacing + innerSpacing
        var currHeight = startHeight

        drawKanjiImage(squareChar, currWidth, currHeight, kanjiWidth, kanjiHeight)
        currWidth += kanjiWidth + innerSpacing
        currColumn++

        for (choice in squareChar.allChoices)
        {
            if (currColumn >= numColumns)
            {
                currHeight -= kanjiHeight + innerSpacing
                currWidth = choiceParams.x + outerSpacing + innerSpacing
                currColumn = 0
            }

            drawKanjiText(choice.first, currWidth, currHeight, kanjiWidth, kanjiHeight)
            currWidth += kanjiWidth + innerSpacing
            currColumn++
        }
    }

    private fun drawKanjiText(kanji: String, x: Int, y: Int, kanjiWidth: Int, kanjiHeight: Int)
    {
        val tv = TextView(context)
        tv.text = kanji
        tv.gravity = Gravity.CENTER
        tv.setTextSize(TypedValue.COMPLEX_UNIT_PX, (kanjiWidth / 1.5).toFloat())

        when
        {
            LangUtils.IsHiragana(kanji[0]) -> tv.setTextColor(ContextCompat.getColor(context, R.color.kana_pink))
            LangUtils.IsKatakana(kanji[0]) -> tv.setTextColor(ContextCompat.getColor(context, R.color.kana_blue))
            LangUtils.IsKanji(kanji[0]) -> tv.setTextColor(Color.BLACK)
            else -> tv.setTextColor(Color.GRAY)
        }

        tv.setBackgroundResource(R.drawable.bg_solid_border_0_white_black)
        tv.width = kanjiWidth
        tv.height = kanjiHeight
        tv.x = x.toFloat()
        tv.y = y.toFloat()
        choiceWindow.addView(tv)
        currentKanjiViews.add(tv)
    }

    private fun drawKanjiImage(squareChar: SquareCharOcr, x: Int, y: Int, kanjiWidth: Int, kanjiHeight: Int)
    {
        // Image nonsense
        val pos = squareChar.bitmapPos
        val dp10 = dpToPx(context, 10)
        val orig = squareChar.displayData.bitmap

        val cropX = pos[0].coerceIn(0, orig.width)
        val cropY = pos[1].coerceIn(0, orig.height)

        val cropRight = pos[2].coerceIn(0, orig.width)
        val cropBottom = pos[3].coerceIn(0, orig.height)

        val width = cropRight - cropX
        val height = cropBottom - cropY

        if (width <= 0 || height <= 0) {
            return
        }

        val bitmapChar = Bitmap.createBitmap(orig, cropX, cropY, width, height)
        val charImage = ImageView(context)
        charImage.setPadding(dp10, dp10, dp10, dp10)
        charImage.layoutParams = LinearLayout.LayoutParams(kanjiWidth, kanjiHeight)
        charImage.x = x.toFloat()
        charImage.y = y.toFloat()
        charImage.scaleType = ImageView.ScaleType.FIT_CENTER
        charImage.cropToPadding = true
        charImage.setImageBitmap(bitmapChar)
        charImage.background = context.getDrawable(R.drawable.bg_translucent_border_0_black_black)
        choiceWindow.addView(charImage)
        currentKanjiViews.add(charImage)
    }

    private fun calculateNumColumns(drawableWidth: Int, columnWidth: Int, minPadding: Int) : Int
    {
        var count = 0
        var width = 0
        val columnAndPadding = columnWidth + (minPadding * 2)

        while ((width + columnAndPadding) < drawableWidth)
        {
            width += columnAndPadding
            count++
        }

        return count
    }


    override fun onTouch(e: MotionEvent): Boolean
    {
        return false
    }

    override fun onDown(e: MotionEvent): Boolean {
        return false
    }

    override fun onScroll(e1: MotionEvent?, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean
    {
        return false
    }

    override fun onResize(e: MotionEvent): Boolean
    {
        return false
    }

    override fun getDefaultParams(): WindowManager.LayoutParams
    {
        val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT,
                if (Build.VERSION.SDK_INT > 25) WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY else WindowManager.LayoutParams.TYPE_PHONE,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
                PixelFormat.TRANSLUCENT)
        params.x = 0
        params.y = 0
        return params
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/Window.java">
package ca.fuwafuwa.gaku.Windows;

import android.content.Context;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.hardware.input.InputManager;
import android.os.Build;
import androidx.core.view.GestureDetectorCompat;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.widget.RelativeLayout;
import android.view.HapticFeedbackConstants;
import android.view.ViewConfiguration;

import java.util.ArrayList;
import java.util.List;

import ca.fuwafuwa.gaku.Interfaces.Stoppable;
import ca.fuwafuwa.gaku.GakuTools;
import ca.fuwafuwa.gaku.Prefs;
import ca.fuwafuwa.gaku.R;
import ca.fuwafuwa.gaku.Windows.Interfaces.WindowListener;
import ca.fuwafuwa.gaku.Windows.Views.ResizeView;
import ca.fuwafuwa.gaku.Windows.Views.WindowView;

import static android.content.Context.WINDOW_SERVICE;

public abstract class Window implements Stoppable, WindowListener {

    private static final String TAG = Window.class.getName();

    private int mTouchSlop;
    private boolean mIsDragging = false;
    private float mInitialTouchX;
    private float mInitialTouchY;
    private boolean mSnappedX = false;
    private boolean mSnappedY = false;

    public interface OnHeightKnown {
        void performAction();
    }

    public static class ReinitOptions {
        public boolean reinitViewLayout = true;
    }

    protected final int minSize;

    protected Context context;
    protected WindowManager windowManager;
    protected View window;
    protected WindowManager.LayoutParams params;
    protected boolean addedToWindowManager;
    protected WindowCoordinator windowCoordinator;

    private Point mRealDisplaySize;
    private int mDX;
    private int mDY;
    private View mDummyViewForSize;
    private int mViewHeight;
    private int mViewWidth;
    private List<ViewTreeObserver.OnGlobalLayoutListener> mOnHeightKnownListeners;

    private boolean mWindowClosed = false;
    private long mParamUpdateTimer = System.currentTimeMillis();

    public Window(Context context, WindowCoordinator windowCoordinator, int contentView) {

        this.context = context;
        this.windowCoordinator = windowCoordinator;

        LayoutInflater inflater = (LayoutInflater) this.context.getApplicationContext()
                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);

        windowManager = (WindowManager) this.context.getSystemService(WINDOW_SERVICE);
        window = inflater.inflate(R.layout.window, null);
        mRealDisplaySize = getRealDisplaySizeFromContext();
        params = getDefaultParams();
        minSize = GakuTools.dpToPx(context, 15);
        mOnHeightKnownListeners = new ArrayList<>();

        WindowView windowView = window.findViewById(R.id.window_view);
        ResizeView resizeView = window.findViewById(R.id.resize_view);
        windowView.setWindowListener(this);
        resizeView.setWindowListener(this);
        GestureDetectorCompat detectorCompat = new GestureDetectorCompat(context, this);
        detectorCompat.setOnDoubleTapListener(this);
        windowView.setDetector(detectorCompat);

        RelativeLayout relativeLayout = window.findViewById(R.id.content_view);
        relativeLayout.addView(inflater.inflate(contentView, relativeLayout, false));

        // Hacky way to check if we are fullscreen by inserting a dummy view and seeing
        // if
        // realDisplaySize matches this view's height. Also determines the drawable view
        // size.
        WindowManager.LayoutParams heightViewParams = new WindowManager.LayoutParams();
        heightViewParams.width = WindowManager.LayoutParams.MATCH_PARENT;
        heightViewParams.height = WindowManager.LayoutParams.MATCH_PARENT;
        heightViewParams.type = Build.VERSION.SDK_INT > 25 ? WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
                : WindowManager.LayoutParams.TYPE_PHONE;
        heightViewParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
        heightViewParams.format = PixelFormat.TRANSPARENT;
        heightViewParams.gravity = Gravity.END | Gravity.TOP;
        heightViewParams.alpha = 0.0F;
        mDummyViewForSize = new View(context);
        mDummyViewForSize.getViewTreeObserver()
                .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
                    @Override
                    public void onGlobalLayout() {
                        mViewHeight = mDummyViewForSize.getMeasuredHeight();
                        mViewWidth = mDummyViewForSize.getMeasuredWidth();
                    }
                });

        windowManager.addView(mDummyViewForSize, heightViewParams);
        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();

    }

    public void reInit(ReinitOptions options) {
        Log.d(TAG, String.format("Window.reInit() for %s called", this.getClass()));

        synchronized (this) {
            mRealDisplaySize = getRealDisplaySizeFromContext();

            if (options.reinitViewLayout) {
                fixBoxBounds();

                if (addedToWindowManager) {
                    windowManager.updateViewLayout(window, params);
                }
            }
        }
    }

    private void applyMagneticAlignment(int x, int y) {
        Prefs prefs = GakuTools.getPrefs(context);
        if (!prefs.getSnapEnabled()) {
            params.x = x;
            params.y = y;
            return;
        }

        int snapGirth = 30; // pixels
        Point display = getRealDisplaySize();
        int screenWidth = display.x;
        int screenHeight = display.y;

        // X Axis Snapping (Left, Center, Right)
        int targetX = x;
        boolean nowSnappedX = false;
        if (Math.abs(x) < snapGirth) {
            targetX = 0;
            nowSnappedX = true;
        } else if (Math.abs(x + (params.width / 2) - (screenWidth / 2)) < snapGirth) {
            targetX = (screenWidth / 2) - (params.width / 2);
            nowSnappedX = true;
        } else if (Math.abs(x + params.width - screenWidth) < snapGirth) {
            targetX = screenWidth - params.width;
            nowSnappedX = true;
        }

        // Y Axis Snapping (Top, Center, Bottom)
        int targetY = y;
        boolean nowSnappedY = false;
        if (Math.abs(y) < snapGirth) {
            targetY = 0;
            nowSnappedY = true;
        } else if (Math.abs(y + (params.height / 2) - (screenHeight / 2)) < snapGirth) {
            targetY = (screenHeight / 2) - (params.height / 2);
            nowSnappedY = true;
        } else if (Math.abs(y + params.height - screenHeight + getStatusBarHeight()) < snapGirth) {
            targetY = screenHeight - params.height - getStatusBarHeight();
            nowSnappedY = true;
        }

        // Haptic Feedback on initial snap
        if ((nowSnappedX && !mSnappedX) || (nowSnappedY && !mSnappedY)) {
            window.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
            // Show guides if capture window
            if (this instanceof CaptureWindow) {
                ((CaptureWindow) this).showGuides(nowSnappedX, nowSnappedY);
            }
        }

        mSnappedX = nowSnappedX;
        mSnappedY = nowSnappedY;
        params.x = targetX;
        params.y = targetY;
        windowManager.updateViewLayout(window, params);
    }

    private Point getRealDisplaySizeFromContext() {
        Point displaySize = new Point();
        ((WindowManager) context.getSystemService(WINDOW_SERVICE)).getDefaultDisplay().getRealSize(displaySize);
        return displaySize;
    }

    /**
     * {@link #stop()} MUST be called or the window does not get removed from the
     * android screen
     * otherwise, the view remains on the screen even after you stop the service.
     *
     * If you choose to override {@link #stop()}, you should call super.stop() to
     * remove the view.
     * Try not to use WindowManager to remove the view yourself, as attempting to
     * remove the view
     * twice from WindowManager (very possible if you have a touch event closing the
     * window) will
     * cause a crash.
     */
    @Override
    public void stop() {
        Log.d(TAG, String.format("Window.stop() for %s called", this.getClass()));

        synchronized (this) {
            if (mWindowClosed)
                return;

            for (ViewTreeObserver.OnGlobalLayoutListener listener : mOnHeightKnownListeners) {
                mDummyViewForSize.getViewTreeObserver().removeOnGlobalLayoutListener(listener);
            }

            mWindowClosed = true;
            windowManager.removeView(mDummyViewForSize);
            windowCoordinator.removeWindow(this);
            if (addedToWindowManager)
                windowManager.removeView(window);

            context = null;
            windowCoordinator = null;
        }
    }

    public void show() {
        Log.d(TAG, String.format("Window.show() for %s called, %b", this.getClass(), addedToWindowManager));

        synchronized (this) {
            if (!addedToWindowManager) {
                windowManager.addView(window, params);
                addedToWindowManager = true;
            }

            windowManager.updateViewLayout(window, params);
        }
    }

    public void bringToFront() {
        synchronized (this) {
            if (addedToWindowManager) {
                windowManager.removeView(window);
                windowManager.addView(window, params);
            }
        }
    }

    public void hide() {
        Log.d(TAG, String.format("Window.hide() for %s called, %b", this.getClass(), addedToWindowManager));

        synchronized (this) {
            if (addedToWindowManager) {
                windowManager.removeView(window);
                addedToWindowManager = false;
            }
        }
    }

    /**
     * Override this and {@link #onScroll} if implementing Window does not need to
     * move around
     *
     * @param e MotionEvent for moving the Window
     * @return Returns whether the MotionEvent was handled
     */
    public boolean onTouch(MotionEvent e) {
        switch (e.getAction()) {
            case MotionEvent.ACTION_DOWN:
                mDX = params.x - (int) e.getRawX();
                mDY = params.y - (int) e.getRawY();
                return true;
            case MotionEvent.ACTION_UP:
                fixBoxBounds();
                windowManager.updateViewLayout(window, params);
                onUp(e);
                return true;
        }
        return false;
    }

    /**
     * See {@link #onTouch}
     */
    @Override
    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {

        if (e1 == null || e2 == null) {
            return false;
        }

        params.x = mDX + (int) e2.getRawX();
        params.y = mDY + (int) e2.getRawY();
        fixBoxBounds();
        windowManager.updateViewLayout(window, params);
        return true;
    }

    /**
     * Override if your implementing Window needs to deal with this touch event
     */
    @Override
    public boolean onSingleTapConfirmed(MotionEvent e) {
        return false;
    }

    /**
     * Override if your implementing Window needs to deal with this touch event
     */
    @Override
    public boolean onDoubleTap(MotionEvent e) {
        return false;
    }

    /**
     * Override if your implementing Window needs to deal with this touch event
     */
    @Override
    public boolean onDoubleTapEvent(MotionEvent e) {
        return false;
    }

    /**
     * Override if your implementing Window needs to deal with this touch event
     */
    public boolean onUp(MotionEvent e) {
        return false;
    }

    /**
     * Override if your implementing Window needs to deal with this touch event
     */
    @Override
    public boolean onDown(MotionEvent e) {
        return false;
    }

    /**
     * Override if your implementing Window needs to deal with this touch event
     */
    @Override
    public void onShowPress(MotionEvent e) {
    }

    /**
     * Override if your implementing Window needs to deal with this touch event
     */
    @Override
    public boolean onSingleTapUp(MotionEvent e) {
        return false;
    }

    /**
     * Override if your implementing Window needs to deal with this touch event
     */
    @Override
    public void onLongPress(MotionEvent e) {
    }

    /**
     * Override if your implementing Window needs to deal with this touch event
     */
    @Override
    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
        return false;
    }

    /**
     * Override this if implementing Window does not need to resize.
     *
     * Overriding {@link #onTouch} will NOT prevent this event from being triggered
     * as
     * it is bring triggered from another view (the resize view) at the current
     * moment.
     *
     * @param e MotionEvent for resizing the Window
     * @return Returns whether the MotionEvent was handled
     */
    public boolean onResize(MotionEvent e) {
        switch (e.getAction()) {
            case MotionEvent.ACTION_DOWN:
                mDX = params.width - (int) e.getRawX();
                mDY = params.height - (int) e.getRawY();
                return true;
            case MotionEvent.ACTION_UP:
                fixBoxBounds();
                windowManager.updateViewLayout(window, params);
                onUp(e);
                return true;
            case MotionEvent.ACTION_MOVE:
                params.width = mDX + (int) e.getRawX();
                params.height = mDY + (int) e.getRawY();
                fixBoxBounds();
                long currTime = System.currentTimeMillis();
                if (currTime - mParamUpdateTimer > 50) {
                    mParamUpdateTimer = currTime;
                    windowManager.updateViewLayout(window, params);
                }
                return true;
        }
        return false;
    }

    /**
     * Some Windows requires the drawable view and status bar height to be known so
     * they can position themselves appropriately
     * Set handler here if that is the case for that window
     */
    public void setOnHeightKnownAction(final OnHeightKnown onHeightKnown) {
        ViewTreeObserver.OnGlobalLayoutListener listener = new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                onHeightKnown.performAction();
            }
        };

        mDummyViewForSize.getViewTreeObserver().addOnGlobalLayoutListener(listener);
        mOnHeightKnownListeners.add(listener);
    }

    /**
     * @return Default LayoutParams for Window
     */
    protected WindowManager.LayoutParams getDefaultParams() {
        WindowManager.LayoutParams params = new WindowManager.LayoutParams();
        params.width = GakuTools.dpToPx(context, 150);
        params.height = GakuTools.dpToPx(context, 150);
        params.type = Build.VERSION.SDK_INT > 25 ? WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
                : WindowManager.LayoutParams.TYPE_PHONE;
        params.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
        params.format = PixelFormat.TRANSLUCENT;
        params.alpha = 0.8F;
        params.x = 0;
        params.y = 0;
        params.gravity = Gravity.TOP | Gravity.LEFT;
        return params;
    }

    /**
     * @return Real screen display size
     */
    protected Point getRealDisplaySize() {
        return new Point(mRealDisplaySize);
    }

    /**
     * @return System status bar height in pixels. Note that the View MUST have been
     *         drawn for this to have any meaning!
     */
    protected int getStatusBarHeight() {
        Log.d(TAG, String.format("Window - getStatusBarHeight %d vs %d", mRealDisplaySize.y, mViewHeight));

        if (mRealDisplaySize.y == mViewHeight) {
            return 0;
        }

        int result = 0;
        int resourceId = context.getResources().getIdentifier("status_bar_height", "dimen", "android");
        if (resourceId > 0) {
            result = context.getResources().getDimensionPixelSize(resourceId);
        }

        return result;
    }

    /**
     * @return The height of portions of the screen the view can be draw on. Note
     *         that the View MUST have been drawn for this to have any meaning!
     */
    protected int getViewHeight() {
        return mViewHeight;
    }

    /**
     * @return The width of portions of the screen the view can be draw on. Note
     *         that the View MUST have been drawn for this to have any meaning!
     */
    protected int getViewWidth() {
        return mViewWidth;
    }

    /**
     * Fixes window so that it stays inside the screen even if the user is trying to
     * drag it off screen
     * Also makes sure that the window size is not smaller than a specified value
     */
    private void fixBoxBounds() {
        if (params.x < 0) {
            params.x = 0;
        } else if (params.x + params.width > mRealDisplaySize.x) {
            params.x = mRealDisplaySize.x - params.width;
        }
        if (params.y < 0) {
            params.y = 0;
        } else if (params.y + params.height > mRealDisplaySize.y) {
            params.y = mRealDisplaySize.y - params.height - getStatusBarHeight();
        }
        if (params.width >= 0 && params.width > mRealDisplaySize.x) {
            params.width = mRealDisplaySize.x;
        }
        if (params.height >= 0 && params.height > mRealDisplaySize.y) {
            params.height = mRealDisplaySize.y;
        }
        if (params.width >= 0 && params.width < minSize) {
            params.width = minSize;
        }
        if (params.height >= 0 && params.height < minSize) {
            params.height = minSize;
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/WindowCoordinator.kt">
package ca.fuwafuwa.gaku.Windows

import android.content.Context
import ca.fuwafuwa.gaku.*

/**
 * It seems like opening and closing a bunch of windows causes Android to start to lag pretty hard.
 * Therefore, we should keep only one instance of each type of window in memory, and show()ing and
 * hide()ing the window when necessary. This class is to help facilitate this communication.
 *
 * Edit: The lag actually might have been caused by a memory leak. But this is here now, so might
 * as well keep it.
 */
class WindowCoordinator(private val context: Context)
{
    val windows: MutableMap<String, Window> = mutableMapOf()

    private val windowInitMap: Map<String, () -> Window> = mutableMapOf(
            WINDOW_INFO to fun(): Window { return InformationWindow(context, this) },
            WINDOW_EDIT to fun(): Window { return EditWindow(context, this) },
            WINDOW_CAPTURE to fun(): Window { return CaptureWindow(context, this) },
            WINDOW_INSTANT_KANJI to fun(): Window { return InstantKanjiWindow(context, this) },
            //WINDOW_HISTORY to fun(): Window { return HistoryWindow(context, this) },
            WINDOW_KANJI_CHOICE to fun(): Window { return KanjiChoiceWindow(context, this) },
            WINDOW_WORD_DETAIL to fun(): Window { return WordDetailWindow(context, this) }
    )

    fun getWindow(key: String) : Window
    {
        if (!windows.containsKey(key))
        {
            windows[key] = windowInitMap.getValue(key).invoke()
        }

        return windows[key]!!
    }

    fun <WindowType> getWindowOfType(key: String) : WindowType
    {
        return getWindow(key) as WindowType
    }

    /**
     * Should only be called by {@link Window#stop()} - calling this outside that method may result in a memory leak
     */
    fun removeWindow(window: Window)
    {
        var key : String? = null

        windows.forEach {
            if (it.value === window)
            {
                key = it.key
            }
        }

        if (key != null) windows.remove(key!!)
    }

    fun hasWindow(key: String) : Boolean
    {
        return windows.containsKey(key)
    }

    fun reinitAllWindows()
    {
        windows.forEach { it.value.reInit(Window.ReinitOptions()) }
    }

    fun stopAllWindows()
    {
        val windows = windows.toList()
        windows.forEach { it.second.stop() }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Windows/WordDetailWindow.java">
package ca.fuwafuwa.gaku.Windows;

import android.content.Context;
import android.graphics.Color;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.graphics.Rect;
import android.os.Build;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.TextView;
import android.util.Log;

import java.sql.SQLException;
import java.util.List;

import ca.fuwafuwa.gaku.Analysis.ParsedWord;
import ca.fuwafuwa.gaku.legacy.user.UserDatabaseHelper;
import ca.fuwafuwa.gaku.legacy.user.UserWord;
import ca.fuwafuwa.gaku.GakuTools;
import ca.fuwafuwa.gaku.R;
import ca.fuwafuwa.gaku.Windows.Views.PitchAccentGraphView;

public class WordDetailWindow extends Window {

    public interface OnStatusChangeListener {
        void onStatusChanged(ParsedWord word);
    }

    private View popupContainer;
    private TextView wordText;
    private TextView tagText;
    private PitchAccentGraphView pitchGraph;
    private TextView defText;
    private TextView freqText;

    private android.widget.LinearLayout layoutMining;
    private android.widget.LinearLayout layoutGrading;

    // Mining
    private Button btnMineAdd;
    private Button btnMineBlacklist;
    private Button btnMineNeverForget;

    // Grading
    private Button btnGradeNothing;
    private Button btnGradeSomething;
    private Button btnGradeHard;
    private Button btnGradeGood;
    private Button btnGradeEasy;

    private android.widget.ImageButton btnClose;
    private ParsedWord currentWord;
    private OnStatusChangeListener statusChangeListener;
    private ca.fuwafuwa.gaku.Logic.ReviewController reviewController;

    public WordDetailWindow(Context context, WindowCoordinator windowCoordinator) {
        super(context, windowCoordinator, R.layout.view_popup_word);
        this.reviewController = new ca.fuwafuwa.gaku.Logic.ReviewController(context);

        ViewGroup windowContent = window.findViewById(R.id.content_view);
        if (windowContent.getChildCount() > 0) {
            popupContainer = windowContent.getChildAt(0);
        }

        wordText = window.findViewById(R.id.popup_word);
        tagText = window.findViewById(R.id.popup_tag);
        pitchGraph = window.findViewById(R.id.popup_pitch_graph);
        defText = window.findViewById(R.id.popup_def);
        freqText = window.findViewById(R.id.popup_freq);
        btnClose = window.findViewById(R.id.btn_close_popup);

        layoutMining = window.findViewById(R.id.layout_mining_buttons);
        layoutGrading = window.findViewById(R.id.layout_grading_buttons);

        btnMineAdd = window.findViewById(R.id.btn_mine_add);
        btnMineBlacklist = window.findViewById(R.id.btn_mine_blacklist);
        btnMineNeverForget = window.findViewById(R.id.btn_mine_never_forget);

        btnGradeNothing = window.findViewById(R.id.btn_grade_nothing);
        btnGradeSomething = window.findViewById(R.id.btn_grade_something);
        btnGradeHard = window.findViewById(R.id.btn_grade_hard);
        btnGradeGood = window.findViewById(R.id.btn_grade_good);
        btnGradeEasy = window.findViewById(R.id.btn_grade_easy);

        // Mining Listeners
        btnMineAdd.setOnClickListener(v -> {
            reviewController.mine(currentWord);
            updateStatus(UserWord.STATUS_LEARNING);
        });
        btnMineBlacklist.setOnClickListener(v -> {
            reviewController.setJpdbFlag(currentWord, "blacklist", false);
            updateStatus(UserWord.STATUS_DISMISSED);
        });
        btnMineNeverForget.setOnClickListener(v -> {
            reviewController.setJpdbFlag(currentWord, "never-forget", false);
            updateStatus(UserWord.STATUS_MASTERED);
        });

        // Grading Listeners
        android.view.View.OnClickListener gradeListener = v -> {
            String grade = "good";
            if (v == btnGradeNothing)
                grade = "nothing";
            if (v == btnGradeSomething)
                grade = "something";
            if (v == btnGradeHard)
                grade = "hard";
            if (v == btnGradeGood)
                grade = "good";
            if (v == btnGradeEasy)
                grade = "easy";
            reviewController.grade(currentWord, grade);
        };

        btnGradeNothing.setOnClickListener(gradeListener);
        btnGradeSomething.setOnClickListener(gradeListener);
        btnGradeHard.setOnClickListener(gradeListener);
        btnGradeGood.setOnClickListener(gradeListener);
        btnGradeEasy.setOnClickListener(gradeListener);

        btnClose.setOnClickListener(v -> hide());
    }

    public void setWord(ParsedWord word) {
        this.currentWord = word;
        wordText.setText(word.getSurface());

        boolean showMining = false;

        switch (word.getStatus()) {
            case UserWord.STATUS_LEARNING:
                tagText.setText("LEARNING");
                tagText.setBackgroundColor(Color.parseColor("#e67e22"));
                break;
            case UserWord.STATUS_KNOWN:
                tagText.setText("KNOWN");
                tagText.setBackgroundColor(Color.parseColor("#2ecc71"));
                break;
            case UserWord.STATUS_MATURE:
                tagText.setText("MATURE");
                tagText.setBackgroundColor(Color.parseColor("#9b59b6"));
                break;
            case UserWord.STATUS_MASTERED:
                tagText.setText("MASTERED");
                tagText.setBackgroundColor(Color.parseColor("#27ae60"));
                break;
            case UserWord.STATUS_DUE:
                tagText.setText("DUE"); // Red?
                tagText.setBackgroundColor(Color.parseColor("#e74c3c"));
                break;
            case UserWord.STATUS_DISMISSED:
                tagText.setText("DISMISSED");
                tagText.setBackgroundColor(Color.parseColor("#95a5a6"));
                showMining = true;
                break;
            default:
                tagText.setText("UNKNOWN"); // New
                tagText.setBackgroundColor(Color.parseColor("#3498db"));
                showMining = true;
                break;
        }

        layoutMining.setVisibility(showMining ? android.view.View.VISIBLE : android.view.View.GONE);
        layoutGrading.setVisibility(!showMining ? android.view.View.VISIBLE : android.view.View.GONE);

        if (word.getPitchPattern() != null && word.getReading() != null) {
            pitchGraph.setData(word.getReading(), word.getPitchPattern());
        } else {
            pitchGraph.setData("", "");
        }

        if (word.getMeanings() != null && !word.getMeanings().isEmpty()) {
            StringBuilder sb = new StringBuilder();
            List<String> meanings = word.getMeanings();
            List<String> meaningPos = word.getMeaningPos();
            String dictionary = word.getDictionary();

            for (int i = 0; i < meanings.size(); i++) {
                if (i != 0) {
                    sb.append("\n\n");
                }
                sb.append(ca.fuwafuwa.gaku.LangUtils.Companion.ConvertIntToCircledNum(i + 1));
                sb.append(" ");

                if (ca.fuwafuwa.gaku.Constants.JMDICT_DATABASE_NAME.equals(dictionary) &&
                        meaningPos != null && i < meaningPos.size() && !meaningPos.get(i).isEmpty()) {
                    sb.append(String.format("(%s) ", meaningPos.get(i)));
                }

                sb.append(meanings.get(i));
            }
            defText.setText(sb.toString());
        } else {
            defText.setText("No definitions found.");
        }

        freqText.setText("POS: " + (word.getPos() != null ? word.getPos() : "Unknown"));
    }

    /**
     * Calculates the best position for the popup based on the side of the capture
     * window
     * that has the most available screen real estate.
     */
    public void showForWordBounds(Rect globalWordRect, Rect captureWindowRect) {
        if (popupContainer == null)
            return;

        params.x = 0;
        params.y = 0;

        popupContainer.post(() -> {
            Point displaySize = getRealDisplaySize();
            int popupWidth = popupContainer.getWidth();
            int popupHeight = popupContainer.getHeight();
            int padding = GakuTools.dpToPx(context, 10);

            // 1. Calculate gaps on all 4 sides of the Capture Window
            int topGap = captureWindowRect.top;
            int bottomGap = displaySize.y - captureWindowRect.bottom;
            int leftGap = captureWindowRect.left;
            int rightGap = displaySize.x - captureWindowRect.right;

            // 2. Find the largest gap
            int maxGap = Math.max(Math.max(topGap, bottomGap), Math.max(leftGap, rightGap));

            int finalX;
            int finalY;

            // 3. Position based on the largest gap
            if (maxGap == topGap) {
                // Place Above
                finalY = captureWindowRect.top - popupHeight - padding;
                // Align X with word center
                finalX = globalWordRect.centerX() - (popupWidth / 2);
            } else if (maxGap == bottomGap) {
                // Place Below
                finalY = captureWindowRect.bottom + padding;
                // Align X with word center
                finalX = globalWordRect.centerX() - (popupWidth / 2);
            } else if (maxGap == leftGap) {
                // Place Left
                finalX = captureWindowRect.left - popupWidth - padding;
                // Align Y with word center
                finalY = globalWordRect.centerY() - (popupHeight / 2);
            } else {
                // Place Right (Default if all equal)
                finalX = captureWindowRect.right + padding;
                // Align Y with word center
                finalY = globalWordRect.centerY() - (popupHeight / 2);
            }

            // 4. Clamping (Ensure popup stays entirely on screen)
            // Even if we picked the "best" side, the word might be near the edge of that
            // side
            if (finalX < 0)
                finalX = 0;
            if (finalX + popupWidth > displaySize.x)
                finalX = displaySize.x - popupWidth;

            if (finalY < 0)
                finalY = 0;
            if (finalY + popupHeight > displaySize.y)
                finalY = displaySize.y - popupHeight;

            popupContainer.setX(finalX);
            popupContainer.setY(finalY);
        });

        if (!addedToWindowManager) {
            show();
        } else {
            windowManager.updateViewLayout(window, params);
            bringToFront();
        }
    }

    public void setOnStatusChangeListener(OnStatusChangeListener listener) {
        this.statusChangeListener = listener;
    }

    private void updateStatus(int status) {
        if (currentWord == null)
            return;
        currentWord.setStatus(status);
        setWord(currentWord);

        if (statusChangeListener != null) {
            statusChangeListener.onStatusChanged(currentWord);
        }

        new Thread(() -> {
            try {
                UserDatabaseHelper db = UserDatabaseHelper.instance(context);
                UserWord uw = db.getUserWordDao().queryBuilder()
                        .where().eq("text", currentWord.getSurface()).queryForFirst();
                if (uw == null) {
                    uw = new UserWord(currentWord.getSurface(),
                            currentWord.getReading() != null ? currentWord.getReading() : "", status);
                    db.getUserWordDao().create(uw);
                } else {
                    uw.setStatus(status);
                    db.getUserWordDao().update(uw);
                }
            } catch (SQLException e) {
                Log.e("WordDetail", "Failed to update status", e);
            }
        }).start();
    }

    @Override
    public boolean onTouch(MotionEvent e) {
        // We only care about the release of the tap
        if (e.getAction() == MotionEvent.ACTION_UP) {
            if (popupContainer != null) {

                // 1. Get the screen bounds of the visible popup UI box
                int[] location = new int[2];
                popupContainer.getLocationOnScreen(location);
                Rect popupRect = new Rect(location[0], location[1],
                        location[0] + popupContainer.getWidth(),
                        location[1] + popupContainer.getHeight());

                float rawX = e.getRawX();
                float rawY = e.getRawY();

                // 2. If the user clicks INSIDE the popup UI (buttons/text),
                // return false. This allows the OS to pass the touch to child
                // views like your "Mine" or "Close" buttons.
                if (popupRect.contains((int) rawX, (int) rawY)) {
                    return false;
                }

                // 3. If they clicked OUTSIDE the popup, let's see if there's
                // a word underneath in the CaptureWindow.
                CaptureWindow capWin = (CaptureWindow) windowCoordinator.getWindow("WINDOW_CAPTURE");

                if (capWin != null) {
                    ParsedWord hitWord = capWin.getWordAtScreenCoords(rawX, rawY);
                    if (hitWord != null) {
                        // We found a new word!
                        // Tell CaptureWindow to trigger its click logic, which
                        // calls setWord() and showForWordBounds() on THIS instance.
                        capWin.onWordHandleExternal(hitWord);
                        return true; // Return true to keep the window open/blocking
                    }
                }

                // 4. Fallback: They clicked truly blank space. Hide the window.
                hide();
                return true;
            }
        }

        // Return true for all other actions (DOWN, MOVE) to ensure
        // this window blocks all touch input to the game/app underneath.
        return true;
    }

    @Override
    protected WindowManager.LayoutParams getDefaultParams() {
        WindowManager.LayoutParams params = new WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT,
                Build.VERSION.SDK_INT > 25 ? WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
                        : WindowManager.LayoutParams.TYPE_PHONE,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
                PixelFormat.TRANSLUCENT);
        params.x = 0;
        params.y = 0;
        params.gravity = Gravity.TOP | Gravity.LEFT;
        return params;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/BetaActivity.kt">
package ca.fuwafuwa.gaku

import android.content.Intent
import android.net.Uri
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button

class BetaActivity : AppCompatActivity()
{
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_beta)

        findViewById<Button>(R.id.beta_button_start).setOnClickListener {
            finish()
        }

        val emailIntent = Intent(android.content.Intent.ACTION_SENDTO)
        emailIntent.type = "text/plain"
        emailIntent.data = Uri.parse("mailto:")
        emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, arrayOf("carloosthuizen0@gmail.com"))
        emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, "Gaku Beta User - ${android.os.Build.BRAND + " " + android.os.Build.MODEL}")

        findViewById<Button>(R.id.beta_button_email).setOnClickListener {
            startActivity(Intent.createChooser(emailIntent, "Send e-mail using..."))
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/Constants.kt">
@file:JvmName("Constants")

package ca.fuwafuwa.gaku

// Thanks to the fact that SqliteOpenHelper.onUpgrade() doesn't work (due to multi-threading and getDao() being called before onUpgrade()),
// we version/upgrade the DBs by changing the name. Lol. Should probably fix this if this becomes an issue in the future.
const val JMDICT_DATABASE_NAME = "DB_KakuDict-02-16-2019.db"
const val JM_DICT_FURIGANA_DATABASE_NAME = "JmDictFurigana.db"
const val TESS_FOLDER_NAME = "tessdata"
const val TESS_DATA_NAME = "jpn.traineddata"
const val SCREENSHOT_FOLDER_NAME = "screenshots"

const val DB_SPLIT_CHAR = "\ufffc"
const val DB_JMDICT_NAME = "JMDICT"
const val DB_KANJIDICT_NAME = "KANJIDICT"
const val DB_ENAMEDICT_NAME = "ENAMEDICT"

const val GAKU_PREF_FILE = "ca.fuwafuwa.gaku"
const val GAKU_PREF_SHOW_HIDE = "ShowHide"
const val GAKU_PREF_IMAGE_FILTER = "ImageFilter"
const val GAKU_PREF_TEXT_DIRECTION = "TextDirection"
const val GAKU_PREF_INSTANT_MODE = "InstantMode"
const val GAKU_PREF_FIRST_LAUNCH = "FirstLaunch"
const val GAKU_PREF_TIMES_LAUNCHED = "TimesLaunched"
const val GAKU_PREF_PLAY_STORE_RATED = "PlayStoreRated"

const val GAKU_PREF_SNAP_ENABLED = "pref_snap_enabled"
const val GAKU_PREF_BORDER_THICKNESS = "pref_border_thickness"
const val GAKU_PREF_BORDER_COLOR = "pref_border_color"
const val GAKU_PREF_SHOW_PRESET_BAR = "pref_show_preset_bar"

// Preset definitions (REQ-007)
enum class CapturePreset(val label: String, val widthDp: Int, val heightDp: Int) {
    SINGLE_LINE("Line", 320, 45),
    PARAGRAPH("Para", 250, 180),
    SUBTITLE("Sub", 380, 65),
    MANGA_BUBBLE("Bubble", 140, 140)
}

const val EXTRA_PROJECTION_RESULT_CODE = "ca.fuwafuwa.gaku.PROJECTION_RESULT_CODE"
const val EXTRA_PROJECTION_RESULT_INTENT = "ca.fuwafuwa.gaku.PROJECTION_RESULT_INTENT"

const val WINDOW_CAPTURE = "WINDOW_CAPTURE"
const val WINDOW_INFO = "WINDOW_INFO"
const val WINDOW_EDIT = "WINDOW_EDIT"
const val WINDOW_INSTANT_KANJI = "WINDOW_INSTANT_KANJI"
const val WINDOW_KANJI_CHOICE = "WINDOW_KANJI_CHOICE"
const val WINDOW_HISTORY = "WINDOW_HISTORY"
const val WINDOW_WORD_DETAIL = "WINDOW_WORD_DETAIL"

const val GAKU_CHANNEL_ID = "gaku_notification_channel_id"
const val GAKU_CHANNEL_NAME = "Show Gaku Notification"

const val REQUEST_SCREENSHOT = 100
const val REQUEST_DRAW_ON_TOP = 200
const val REQUEST_SERVICE_TOGGLE_IMAGE_PREVIEW = 300
const val REQUEST_SERVICE_TOGGLE_PAGE_MODE = 400
const val REQUEST_SERVICE_TOGGLE_INSTANT_MODE = 500
const val REQUEST_SERVICE_SHUTDOWN = 600
const val REQUEST_SERVICE_TOGGLE_SHOW_HIDE = 700
</file>

<file path="main/java/ca/fuwafuwa/gaku/GakuTools.kt">
@file:JvmName("GakuTools")

package ca.fuwafuwa.gaku

import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.DisplayMetrics
import android.util.Log
import android.widget.Toast

import com.google.gson.GsonBuilder
import java.io.File
import java.io.FileOutputStream
import java.lang.Exception

import java.util.ArrayList

private const val TAG = "GakuTools"
private val gson = GsonBuilder().setPrettyPrinting().disableHtmlEscaping().excludeFieldsWithoutExposeAnnotation().create()

enum class TextDirection(val value: Int) {
    AUTO(0),
    HORIZONTAL(1),
    VERTICAL(2);

    companion object {
        private val values = values();
        fun getByValue(value: Int) = values.firstOrNull { it.value == value }
    }
}

data class Prefs(
    val textDirectionSetting: TextDirection,
    val imageFilterSetting: Boolean,
    val instantModeSetting: Boolean,
    val showHideSetting: Boolean,
    val snapEnabled: Boolean,          // New
    val showPresetBar: Boolean,       // New
    val borderThickness: Int,         // New
    val borderColor: String           // New
)

fun getPrefs(context: Context): Prefs {
    val prefs = context.getSharedPreferences(GAKU_PREF_FILE, Context.MODE_PRIVATE)
    val defaultPrefs = androidx.preference.PreferenceManager.getDefaultSharedPreferences(context)

    return Prefs(
        TextDirection.valueOf(prefs.getString(GAKU_PREF_TEXT_DIRECTION, TextDirection.AUTO.toString())!!),
        prefs.getBoolean(GAKU_PREF_IMAGE_FILTER, true),
        prefs.getBoolean(GAKU_PREF_INSTANT_MODE, true),
        prefs.getBoolean(GAKU_PREF_SHOW_HIDE, true),
        defaultPrefs.getBoolean(GAKU_PREF_SNAP_ENABLED, true),
        defaultPrefs.getBoolean(GAKU_PREF_SHOW_PRESET_BAR, true),
        defaultPrefs.getString(GAKU_PREF_BORDER_THICKNESS, "2")!!.toInt(),
        defaultPrefs.getString(GAKU_PREF_BORDER_COLOR, "#0064ff")!!
    )
}


fun toJson(obj: Any): String
{
    return gson.toJson(obj)
}

fun dpToPx(context: Context, dp: Int): Int
{
    val displayMetrics = context.resources.displayMetrics
    return Math.round(dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT))
}

fun pxToDp(context: Context, px: Int): Int
{
    val displayMetrics = context.resources.displayMetrics
    return Math.round(px / (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT))
}

/**
 * Splits `text` into individual unicode characters as a list of strings
 * @param text Text to split
 * @return List of strings with each string representing one unicode character
 */
fun splitTextByChar(text: String): List<String>
{
    val charList = ArrayList<String>()

    val length = text.length
    var offset = 0
    while (offset < length)
    {
        val curr = text.codePointAt(offset)
        val charz = String(intArrayOf(curr), 0, 1)
        charList.add(charz)
        offset += Character.charCount(curr)
    }

    return charList
}

fun startGakuService(context: Context, i: Intent)
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
    {
        context.startForegroundService(i)
    }
    else
    {
        context.startService(i)
    }
}

fun setupGakuDatabasesAndFiles(context: Context)
{
    try {
        val filesAndPaths = hashMapOf(
                JMDICT_DATABASE_NAME to context.filesDir.absolutePath,
                JM_DICT_FURIGANA_DATABASE_NAME to context.filesDir.absolutePath,
                TESS_DATA_NAME to "${context.filesDir.absolutePath}/$TESS_FOLDER_NAME")

        if (shouldResetData(filesAndPaths))
        {
            Log.d(TAG, "Resetting Data")
            for (fileAndPath in filesAndPaths){
                File("${fileAndPath.value}/${fileAndPath.key}").delete()
            }
        }

        copyFilesIfNotExists(context, filesAndPaths)

        var screenshotPath: String = context.filesDir.absolutePath + "/$SCREENSHOT_FOLDER_NAME"
        createDirIfNotExists(screenshotPath)
        deleteScreenshotsOlderThanOneDay(screenshotPath)
    }
    catch (e: Exception)
    {
        Toast.makeText(context, "Unable to setup Gaku database", Toast.LENGTH_LONG).show()
        return
    }
}

fun shouldResetData(filesAndPaths: Map<String, String>) : Boolean
{
    for (fileAndPath in filesAndPaths){
        if (!File("${fileAndPath.value}/${fileAndPath.key}").exists()) return true
    }
    return false
}

fun resetGakuDatabases(context: Context) {
    try {
        val filesAndPaths = hashMapOf(
            JMDICT_DATABASE_NAME to context.filesDir.absolutePath,
            JM_DICT_FURIGANA_DATABASE_NAME to context.filesDir.absolutePath,
            TESS_DATA_NAME to "${context.filesDir.absolutePath}/$TESS_FOLDER_NAME"
        )
        
        for (fileAndPath in filesAndPaths) {
            val file = File("${fileAndPath.value}/${fileAndPath.key}")
            if (file.exists()) {
                file.delete()
            }
        }
        
        copyFilesIfNotExists(context, filesAndPaths)
    } catch (e: Exception) {
        Log.e(TAG, "Error resetting databases", e)
    }
}

fun createDirIfNotExists(path: String)
{
    val dir = File(path)
    if (!dir.exists())
    {
        dir.mkdirs()
    }
}

fun copyFilesIfNotExists(context: Context, filesAndPaths: Map<String, String>)
{
    for (fileAndPath in filesAndPaths)
    {
        val path = fileAndPath.value
        val fileName = fileAndPath.key
        val filePath = "$path/$fileName"

        if (File(filePath).exists())
        {
            continue
        }

        createDirIfNotExists(path)

        try {
            val input = context.assets.open(fileName)
            val output = FileOutputStream(filePath)

            input.copyTo(output);
            output.close()
            Log.d(TAG, "Copied $filePath")
        } catch (e: java.io.FileNotFoundException) {
            Log.w(TAG, "Asset $fileName not found, skipping copy.")
        }
    }
}

fun deleteScreenshotsOlderThanOneDay(path: String)
{
    try {
        var dir = File(path)
        if (dir.exists())
        {
            Log.d(TAG, dir.absolutePath)
            var listFileNames = dir.list()
            var purgeTime = System.currentTimeMillis() - 1 * 24 * 60 * 60 * 1000
            for (fileName in listFileNames)
            {
                val file = File(fileName)
                if (file.isFile && file.lastModified() < purgeTime)
                {
                    file.delete()
                }
            }
        }
    }
    catch (e: Exception)
    {
        Log.d(TAG, e.toString())
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/LangUtils.kt">
package ca.fuwafuwa.gaku

class LangUtils {

    companion object {

        private val KanaHalf: IntArray = intArrayOf(
                0x3092, 0x3041, 0x3043, 0x3045, 0x3047, 0x3049, 0x3083, 0x3085,
                0x3087, 0x3063, 0x30FC, 0x3042, 0x3044, 0x3046, 0x3048, 0x304A,
                0x304B, 0x304D, 0x304F, 0x3051, 0x3053, 0x3055, 0x3057, 0x3059,
                0x305B, 0x305D, 0x305F, 0x3061, 0x3064, 0x3066, 0x3068, 0x306A,
                0x306B, 0x306C, 0x306D, 0x306E, 0x306F, 0x3072, 0x3075, 0x3078,
                0x307B, 0x307E, 0x307F, 0x3080, 0x3081, 0x3082, 0x3084, 0x3086,
                0x3088, 0x3089, 0x308A, 0x308B, 0x308C, 0x308D, 0x308F, 0x3093
        )

        private val KanaVoiced: IntArray = intArrayOf(
                0x30F4, 0xFF74, 0xFF75, 0x304C, 0x304E, 0x3050, 0x3052, 0x3054,
                0x3056, 0x3058, 0x305A, 0x305C, 0x305E, 0x3060, 0x3062, 0x3065,
                0x3067, 0x3069, 0xFF85, 0xFF86, 0xFF87, 0xFF88, 0xFF89, 0x3070,
                0x3073, 0x3076, 0x3079, 0x307C
        )

        private val KanaSemiVoiced: IntArray = intArrayOf(
                0x3071, 0x3074, 0x3077, 0x307A, 0x307D
        )

        fun IsHiragana(char: Char) : Boolean
        {
            return Character.UnicodeBlock.of(char) == Character.UnicodeBlock.HIRAGANA
        }

        fun IsKatakana(char: Char) : Boolean
        {
            return Character.UnicodeBlock.of(char) == Character.UnicodeBlock.KATAKANA
        }

        fun IsKanji(char: Char) : Boolean
        {
            val block = Character.UnicodeBlock.of(char)
            return block == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS ||
                   block == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A ||
                   block == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B ||
                   block == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C ||
                   block == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D
        }

        fun IsJapaneseChar(char: Char) : Boolean
        {
            return IsHiragana(char) || IsKatakana(char) || IsKanji(char)
        }

        fun ConvertKanatanaToHiragana(text: String): String
        {
            var result: StringBuilder = StringBuilder()
            var ordPrev: Int = 0;

            for (i in text){

                var ordCurr: Int = i.code

                // Full-width katakana to hiragana
                if ((ordCurr >= 0x30A1) && (ordCurr <= 0x30F3))
                {
                    ordCurr -= 0x60
                }
                // Half-width katakana to hiragana
                else if ((ordCurr >= 0xFF66) && (ordCurr <= 0xFF9D))
                {
                    ordCurr = KanaHalf[ordCurr - 0xFF66]
                }
                // Voiced (used in half-width katakana) to hiragana
                else if (ordCurr == 0xFF9E)
                {
                    if (ordPrev >= 0xFF73 && ordPrev <= 0xFF8E)
                    {
                        result.setLength(result.length - 1)
                        ordCurr = KanaVoiced[ordPrev - 0xFF73]
                    }
                }
                // Semi-voiced (used in half-width katakana) to hiragana
                else if (ordCurr == 0xFF9F)
                {
                    if (ordPrev >= 0xFF8A && ordPrev <= 0xFF8E)
                    {
                        result.setLength(result.length - 1)
                        ordCurr = KanaSemiVoiced[ordPrev - 0xFF8A]
                    }
                }
                // Ignore Japanese ~
                else if (ordCurr == 0xFF5E)
                {
                    ordPrev = 0
                    continue
                }

                result.append(ordCurr.toChar())
                ordPrev = ordCurr
            }

            return result.toString()
        }

        fun ConvertIntToCircledNum(num: Int): String
        {
            var circledNum: String = "($num)"

            if (num == 0)
            {
                circledNum = ""
            } else if ((num >= 1) && (num <= 20))
            {
                circledNum = (('' - 1) + num).toString()
            }
            // Note: Numbers over 20 may depend on font
            else if ((num >= 21) && (num <= 35))
            {
                circledNum = (('' - 21) + num).toString()
            }
            else if ((num >= 36) && (num <= 50))
            {
                circledNum = (('' - 36) + num).toString()
            }

            return circledNum
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/MainActivity.kt">
package ca.fuwafuwa.gaku

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.media.projection.MediaProjectionManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.CountDownTimer
import android.provider.Settings
import android.util.Log
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import ca.fuwafuwa.gaku.Dialogs.StarRatingDialogFragment


class MainActivity : AppCompatActivity()
{
    private var mIsActivityVisible = false
    private var mShownRating = false

    private lateinit var mPrefs : SharedPreferences
    private lateinit var mStartGakuIntent: Intent

    // Replacement for REQUEST_DRAW_ON_TOP
    private val drawOverlayLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {
        Log.d(TAG, "Recieved ACTION_MANAGE_OVERLAY_PERMISSION result")
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !Settings.canDrawOverlays(this)) {
            val relaunchAppText = "Relaunch Gaku after verifying permission"
            Toast.makeText(this, "Check Permission: Draw on Other Apps\n$relaunchAppText", Toast.LENGTH_LONG).show()
            finish()
        }
    }

    // Replacement for REQUEST_SCREENSHOT
    private val screenCaptureLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
        Log.d(TAG, "Recieved REQUEST_SCREENSHOT result")
        val relaunchAppText = "Relaunch Gaku after verifying permission"

        if (result.resultCode != Activity.RESULT_OK) {
            Toast.makeText(this, "Check Permission: Record Screen\n$relaunchAppText", Toast.LENGTH_LONG).show()
            finish()
        } else {
            mStartGakuIntent = Intent(this, MainService::class.java)
                    .putExtra(EXTRA_PROJECTION_RESULT_CODE, result.resultCode)
                    .putExtra(EXTRA_PROJECTION_RESULT_INTENT, result.data)
        }
    }

    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)

        if (isBeta())
        {
            startActivity(Intent(this, BetaActivity::class.java))
        }

        mPrefs = getSharedPreferences(GAKU_PREF_FILE, Context.MODE_PRIVATE)

        if (isFirstLaunch())
        {
            startActivity(Intent(this, TutorialActivity::class.java))
            finish()
        }
        else {
            supportActionBar?.hide()
            setContentView(R.layout.activity_main)

            setupGakuDatabasesAndFiles(this)
        }
    }

    override fun onStart()
    {
        super.onStart()

        checkDrawOnTopPermissions()
        checkScreenRecordPermissions()

        showRatingDialog()
    }

    override fun onPause()
    {
        super.onPause()
        Log.d(TAG, "ACTIVITY INVISIBLE")
        mIsActivityVisible = false
    }

    override fun onResume()
    {
        super.onResume()
        Log.d(TAG, "ACTIVITY VISIBLE")
        mIsActivityVisible = true
    }

    fun startGaku(startFragment: MainStartFragment)
    {
        if (MainService.IsRunning())
        {
            return
        }

        if (!mIsActivityVisible)
        {
            return
        }

        if (::mStartGakuIntent.isInitialized)
        {
            startFragment.onGakuLoadStart()

            val totalDuration = 2000
            object : CountDownTimer(totalDuration.toLong(), 10)
            {
                override fun onFinish()
                {
                    startFragment.onGakuLoaded()
                    startGakuService(this@MainActivity, mStartGakuIntent)
                }

                override fun onTick(millisUntilFinished: Long)
                {
                }
            }.start()
        }
        else {
            // Permission might have just been granted, intent not ready yet
            Toast.makeText(this, "Initializing service...", Toast.LENGTH_SHORT).show()
        }
    }

    private fun checkDrawOnTopPermissions()
    {
        var checkPermissions = "Check \"Draw on Top of Other Apps\" permission"
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
        {
            if (!Settings.canDrawOverlays(this))
            {
                Log.d(TAG, "Sending ACTION_MANAGE_OVERLAY_PERMISSION Intent")
                drawOverlayLauncher.launch(Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:$packageName")))
            }
        }
        else
        {
            Toast.makeText(this, "Manually $checkPermissions\nGaku might not work on this device", Toast.LENGTH_LONG).show()
        }
    }

    private fun checkScreenRecordPermissions()
    {
        Log.d(TAG, "Sending REQUEST_SCREENSHOT Intent")
        val mediaProjectionManager: MediaProjectionManager? = getSystemService(Context.MEDIA_PROJECTION_SERVICE) as MediaProjectionManager
        if (mediaProjectionManager != null) {
            screenCaptureLauncher.launch(mediaProjectionManager.createScreenCaptureIntent())
        }
    }

    private fun showRatingDialog()
    {
        if (mShownRating)
        {
            return
        }

        mShownRating = true

        val timesLaunched = mPrefs.getInt(GAKU_PREF_TIMES_LAUNCHED, 1)
        val rated = mPrefs.getBoolean(GAKU_PREF_PLAY_STORE_RATED, false)

        if (timesLaunched % 20 == 0 && !rated)
        {
            StarRatingDialogFragment().show(supportFragmentManager, "StarRating")
        }
    }

    private fun isFirstLaunch() : Boolean
    {
        return mPrefs.getBoolean(GAKU_PREF_FIRST_LAUNCH, true)
    }

    private fun isBeta() : Boolean
    {
        val CURRENT_PROD_VERSION = 73 // just hardcoded, change when a build is ready to be rolled out to prod
        return BuildConfig.VERSION_CODE > CURRENT_PROD_VERSION
    }

    companion object
    {
        private val TAG = MainActivity::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/MainService.java">
package ca.fuwafuwa.gaku;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.hardware.display.DisplayManager;
import android.hardware.display.VirtualDisplay;
import android.media.Image;
import android.media.ImageReader;
import android.media.projection.MediaProjection;
import android.media.projection.MediaProjectionManager;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import androidx.annotation.RequiresApi;
import androidx.core.app.NotificationCompat;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.WindowManager;
import android.widget.Toast;

import ca.fuwafuwa.gaku.Interfaces.Stoppable;
import ca.fuwafuwa.gaku.Windows.Window;
import ca.fuwafuwa.gaku.Windows.WindowCoordinator;

import static androidx.core.app.NotificationCompat.FLAG_FOREGROUND_SERVICE;
import static androidx.core.app.NotificationCompat.FLAG_ONGOING_EVENT;

/**
 * Created by 0xbad1d3a5 on 4/9/2016.
 */
public class MainService extends Service implements Stoppable {

    private static final String TAG = MainService.class.getName();

    public static class CloseMainService extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.d(TAG, "GOT CLOSE");
            context.stopService(new Intent(context, MainService.class));
        }
    }

    public static class ToggleImagePreviewMainService extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            SharedPreferences prefs = context.getSharedPreferences(Constants.GAKU_PREF_FILE, Context.MODE_PRIVATE);
            boolean imagePreview = prefs.getBoolean(Constants.GAKU_PREF_IMAGE_FILTER, true);
            prefs.edit().putBoolean(Constants.GAKU_PREF_IMAGE_FILTER, !imagePreview).apply();

            GakuTools.startGakuService(context, new Intent(context, MainService.class));
        }
    }

    public static class ToggleShowHideMainService extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            SharedPreferences prefs = context.getSharedPreferences(Constants.GAKU_PREF_FILE, Context.MODE_PRIVATE);
            boolean shown = prefs.getBoolean(Constants.GAKU_PREF_SHOW_HIDE, true);
            prefs.edit().putBoolean(Constants.GAKU_PREF_SHOW_HIDE, !shown).apply();

            GakuTools.startGakuService(context, new Intent(context, MainService.class));
        }
    }

    public static class TogglePageModeMainService extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            SharedPreferences prefs = context.getSharedPreferences(Constants.GAKU_PREF_FILE, Context.MODE_PRIVATE);
            TextDirection textDirection = TextDirection
                    .valueOf(prefs.getString(Constants.GAKU_PREF_TEXT_DIRECTION, TextDirection.AUTO.toString()));
            textDirection = TextDirection.Companion.getByValue((textDirection.ordinal() + 1) % 3);
            prefs.edit().putString(Constants.GAKU_PREF_TEXT_DIRECTION, textDirection.toString()).apply();

            GakuTools.startGakuService(context, new Intent(context, MainService.class));
        }
    }

    public static class ToggleInstantModeMainService extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            SharedPreferences prefs = context.getSharedPreferences(Constants.GAKU_PREF_FILE, Context.MODE_PRIVATE);
            boolean pageMode = prefs.getBoolean(Constants.GAKU_PREF_INSTANT_MODE, true);
            prefs.edit().putBoolean(Constants.GAKU_PREF_INSTANT_MODE, !pageMode).apply();

            GakuTools.startGakuService(context, new Intent(context, MainService.class));
        }
    }

    public static class ScreenOffReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            SharedPreferences prefs = context.getSharedPreferences(Constants.GAKU_PREF_FILE, Context.MODE_PRIVATE);
            prefs.edit().putBoolean(Constants.GAKU_PREF_SHOW_HIDE, false).apply();

            GakuTools.startGakuService(context, new Intent(context, MainService.class));
        }
    }

    private class MediaProjectionStopCallback extends MediaProjection.Callback {
        @Override
        public void onStop() {
            Log.d(TAG, "Stopping projection");
            mHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (MediaProjectionStopCallback.this == mMediaProjectionStopCallback) {
                        if (mVirtualDisplay != null) {
                            mVirtualDisplay.release();
                        }
                        mMediaProjection.unregisterCallback(MediaProjectionStopCallback.this);
                        mMediaProjection = null;
                        mImageReader.close();
                    }
                }
            });
        }
    }

    private static boolean isGakuRunning = false;

    private static final int VIRTUAL_DISPLAY_FLAGS = DisplayManager.VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY
            | DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC;
    private static final int NOTIFICATION_ID = 1;

    private final Object mScreenshotLock = new Object();

    private IntentFilter mIntentFilter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
    private ScreenOffReceiver mScreenOffReceiver = new ScreenOffReceiver();

    private Intent mProjectionResultIntent;
    private int mProjectionResultCode;

    private WindowManager mWindowManager;
    private MediaProjectionManager mMediaProjectionManager;
    private MediaProjection mMediaProjection;
    private ImageReader mImageReader;
    private Display mDisplay;
    private VirtualDisplay mVirtualDisplay;
    private MainServiceHandler mHandler;

    private int mRotation;
    private Point mRealDisplaySize = new Point();

    private MediaProjectionStopCallback mMediaProjectionStopCallback;
    private WindowCoordinator mWindowCoordinator = new WindowCoordinator(this);

    @Override
    public IBinder onBind(Intent intent) {
        // Not used
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();

        if (!isGakuRunning) {
            SharedPreferences prefs = getSharedPreferences(Constants.GAKU_PREF_FILE, Context.MODE_PRIVATE);
            prefs.edit().putBoolean(Constants.GAKU_PREF_SHOW_HIDE, true).apply();
        }

        Log.d(TAG, "CREATING MAINSERVICE: " + System.identityHashCode(this));
        Toast.makeText(this, "Starting capture window...", Toast.LENGTH_LONG).show();

        mMediaProjectionManager = (MediaProjectionManager) getSystemService(MEDIA_PROJECTION_SERVICE);
        mHandler = new MainServiceHandler(this, mWindowCoordinator);

        // Set preferences for ratings
        SharedPreferences prefs = getSharedPreferences(Constants.GAKU_PREF_FILE, Context.MODE_PRIVATE);
        int timesLaunched = prefs.getInt(Constants.GAKU_PREF_TIMES_LAUNCHED, 1);
        prefs.edit().putInt(Constants.GAKU_PREF_TIMES_LAUNCHED, timesLaunched + 1).apply();

        registerReceiver(mScreenOffReceiver, mIntentFilter);

        startForeground(NOTIFICATION_ID, getNotification());
        isGakuRunning = true;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d(TAG, "onStartCommand");

        if (intent.getExtras() != null &&
                intent.getExtras().containsKey(Constants.EXTRA_PROJECTION_RESULT_CODE) &&
                intent.getExtras().containsKey(Constants.EXTRA_PROJECTION_RESULT_INTENT)) {
            mProjectionResultIntent = (Intent) intent.getExtras().get(Constants.EXTRA_PROJECTION_RESULT_INTENT);
            mProjectionResultCode = intent.getExtras().getInt(Constants.EXTRA_PROJECTION_RESULT_CODE);
        }

        // Determine if we need to start/stop the capture service
        SharedPreferences prefs = getSharedPreferences(Constants.GAKU_PREF_FILE, Context.MODE_PRIVATE);
        Boolean shown = prefs.getBoolean(Constants.GAKU_PREF_SHOW_HIDE, true);
        if (shown) {
            // Re-init CaptureWindow as well as prefs may have changed (BroadcastReceiver go
            // to onStartCommand())
            mWindowCoordinator.getWindow(Constants.WINDOW_CAPTURE).reInit(new Window.ReinitOptions());
        } else {
            mWindowCoordinator.stopAllWindows();
            stop();
        }

        // Set notification text
        NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        notificationManager.notify(NOTIFICATION_ID, getNotification());

        return START_NOT_STICKY;
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);

        if (mWindowCoordinator.hasWindow(Constants.WINDOW_CAPTURE) && mMediaProjection != null) {
            final int rotation = mDisplay.getRotation();
            if (rotation != mRotation) {
                Log.d(TAG, "Orientation changed. Re-creating Virtual Display.");
                mRotation = rotation;
                createVirtualDisplay(); // This will now use the new rotation
                mWindowCoordinator.reinitAllWindows();
            }
        }
    }

    @Override
    public void onDestroy() {
        unregisterReceiver(mScreenOffReceiver);
        stopForeground(true);
        Log.d(TAG, "DESTORYING MAINSERVICE: " + System.identityHashCode(this));

        stop();
        mWindowCoordinator.stopAllWindows();
        mWindowCoordinator = null;
        isGakuRunning = false;

        Log.d(TAG, String.format("MAINSERVICE: %s DESTROYED", System.identityHashCode(this)));
        super.onDestroy();
    }

    @Override
    public void stop() {
        if (mMediaProjection != null) {
            mMediaProjection.stop();
        }
    }

    public static boolean IsRunning() {
        return isGakuRunning;
    }

    /**
     * This function is here as a bug fix against
     * {@link #onConfigurationChanged(Configuration)} not
     * triggering when the app is first started and immediately switches to another
     * orientation. In
     * such a case onConfigurationChanged will not trigger and
     * {@link Window#reInit(ca.fuwafuwa.gaku.Windows.Window.ReinitOptions)} will not
     * update the LayoutParams.
     */
    public void onCaptureWindowFinishedInitializing() {
        if (mMediaProjection == null) {
            Log.d(TAG, "mMediaProjection is null");
            mMediaProjection = mMediaProjectionManager.getMediaProjection(mProjectionResultCode,
                    mProjectionResultIntent);
            mMediaProjectionStopCallback = new MediaProjectionStopCallback();
            mMediaProjection.registerCallback(mMediaProjectionStopCallback, mHandler);
        }
        createVirtualDisplay();
    }

    public Handler getHandler() {
        return mHandler;
    }

    public Bitmap getScreenshotBitmap() {
        synchronized (mScreenshotLock) {
            if (mImageReader == null) {
                return null;
            }

            try {
                // Try to get the latest image
                Image image = mImageReader.acquireLatestImage();
                if (image == null) {
                    long startTime = System.nanoTime();
                    while (image == null && System.nanoTime() < startTime + 2000000000) {
                        try {
                            mScreenshotLock.wait(20);
                        } catch (InterruptedException e) {
                            return null;
                        }
                        if (mImageReader == null)
                            return null;
                        image = mImageReader.acquireLatestImage();
                    }
                }

                if (image != null) {
                    try {
                        return convertImageToBitmap(image);
                    } finally {
                        image.close();
                    }
                }
            } catch (Exception e) {
                Log.e(TAG, "Error getting screenshot", e);
            }
            return null;
        }
    }

    private Bitmap convertImageToBitmap(Image image) {
        Image.Plane[] planes = image.getPlanes();
        java.nio.ByteBuffer buffer = planes[0].getBuffer();
        int pixelStride = planes[0].getPixelStride();
        int rowStride = planes[0].getRowStride();
        int rowPadding = rowStride - pixelStride * image.getWidth();

        Bitmap bitmap = Bitmap.createBitmap(image.getWidth() + rowPadding / pixelStride, image.getHeight(),
                Bitmap.Config.ARGB_8888);
        bitmap.copyPixelsFromBuffer(buffer);
        return bitmap;
    }

    private Notification getNotification() {
        String channelId;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            channelId = createNotificationChannel();
        } else {
            channelId = "";
        }

        PendingIntent toggleShowHide = PendingIntent.getBroadcast(this, Constants.REQUEST_SERVICE_TOGGLE_SHOW_HIDE,
                new Intent(this, ToggleShowHideMainService.class), PendingIntent.FLAG_IMMUTABLE);
        PendingIntent toggleImagePreview = PendingIntent.getBroadcast(this,
                Constants.REQUEST_SERVICE_TOGGLE_IMAGE_PREVIEW, new Intent(this, ToggleImagePreviewMainService.class),
                PendingIntent.FLAG_IMMUTABLE);
        PendingIntent togglePageMode = PendingIntent.getBroadcast(this, Constants.REQUEST_SERVICE_TOGGLE_PAGE_MODE,
                new Intent(this, TogglePageModeMainService.class), PendingIntent.FLAG_IMMUTABLE);
        PendingIntent toggleInstantMode = PendingIntent.getBroadcast(this,
                Constants.REQUEST_SERVICE_TOGGLE_INSTANT_MODE, new Intent(this, ToggleInstantModeMainService.class),
                PendingIntent.FLAG_IMMUTABLE);
        PendingIntent closeMainService = PendingIntent.getBroadcast(this, Constants.REQUEST_SERVICE_SHUTDOWN,
                new Intent(this, CloseMainService.class), PendingIntent.FLAG_IMMUTABLE);

        Prefs prefs = GakuTools.getPrefs(this);

        String contentTitle = "Gaku";
        switch (prefs.getTextDirectionSetting()) {
            case AUTO:
                contentTitle = "Gaku is determining text direction automatically";
                break;
            case VERTICAL:
                contentTitle = "Gaku is reading text vertically";
                break;
            case HORIZONTAL:
                contentTitle = "Gaku is reading text horizontally";
                break;
        }

        Notification n;
        if (prefs.getShowHideSetting()) {
            n = new NotificationCompat.Builder(this, channelId)
                    .setSmallIcon(R.drawable.gaku_notification_icon)
                    .setContentTitle(contentTitle)
                    .setContentText(String.format("Instant mode %s, black and white filter %s",
                            prefs.getInstantModeSetting() ? "on" : "off", prefs.getImageFilterSetting() ? "on" : "off"))
                    .setContentIntent(toggleShowHide)
                    .addAction(0, "Instant Mode", toggleInstantMode)
                    .addAction(0, "Image Filter", toggleImagePreview)
                    .addAction(0, "Shutdown", closeMainService)
                    .build();
        } else {
            n = new NotificationCompat.Builder(this, channelId)
                    .setSmallIcon(R.drawable.gaku_notification_icon)
                    .setContentTitle("Gaku is hidden and in power-saving mode")
                    .setContentIntent(toggleShowHide)
                    .build();
        }

        n.flags = FLAG_ONGOING_EVENT | FLAG_FOREGROUND_SERVICE;

        return n;
    }

    private void createVirtualDisplay() {
        // display metrics
        mWindowManager = (WindowManager) getSystemService(WINDOW_SERVICE);
        DisplayMetrics metrics = getResources().getDisplayMetrics();
        int mDensity = metrics.densityDpi;
        mDisplay = mWindowManager.getDefaultDisplay();

        // get width and height
        mDisplay.getRealSize(mRealDisplaySize);

        // start capture reader
        Log.d(TAG, String.format("Starting Projection: %dx%d", mRealDisplaySize.x, mRealDisplaySize.y));

        synchronized (mScreenshotLock) {
            if (mVirtualDisplay == null) {
                mImageReader = ImageReader.newInstance(mRealDisplaySize.x, mRealDisplaySize.y, PixelFormat.RGBA_8888,
                        2);
                mVirtualDisplay = mMediaProjection.createVirtualDisplay(getClass().getName(), mRealDisplaySize.x,
                        mRealDisplaySize.y, mDensity, VIRTUAL_DISPLAY_FLAGS, mImageReader.getSurface(), null, mHandler);
            } else {
                ImageReader newImageReader = ImageReader.newInstance(mRealDisplaySize.x, mRealDisplaySize.y,
                        PixelFormat.RGBA_8888, 2);
                mVirtualDisplay.resize(mRealDisplaySize.x, mRealDisplaySize.y, mDensity);
                mVirtualDisplay.setSurface(newImageReader.getSurface());
                if (mImageReader != null) {
                    mImageReader.close();
                }
                mImageReader = newImageReader;
            }
        }
    }

    private void stopVirtualDisplay() {
        synchronized (mScreenshotLock) {
            if (mVirtualDisplay != null) {
                mVirtualDisplay.release();
                mVirtualDisplay = null;
            }
            if (mImageReader != null) {
                mImageReader.close();
                mImageReader = null;
            }
        }
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private String createNotificationChannel() {
        String channelId = Constants.GAKU_CHANNEL_ID;
        String channelName = Constants.GAKU_CHANNEL_NAME;

        NotificationChannel channel = new NotificationChannel(channelId, channelName,
                NotificationManager.IMPORTANCE_LOW);
        NotificationManager service = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        service.createNotificationChannel(channel);

        return channelId;
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/MainServiceHandler.java">
package ca.fuwafuwa.gaku;

import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.widget.Toast;

import ca.fuwafuwa.gaku.Ocr.OcrResult;
import ca.fuwafuwa.gaku.Analysis.ParsedResult;
import ca.fuwafuwa.gaku.Windows.CaptureWindow;
import ca.fuwafuwa.gaku.Windows.InformationWindow;
import ca.fuwafuwa.gaku.Windows.InstantKanjiWindow;
import ca.fuwafuwa.gaku.Windows.WindowCoordinator;

/**
 * Created by 0xbad1d3a5 on 4/15/2016.
 */
public class MainServiceHandler extends Handler {

    private static final String TAG = MainServiceHandler.class.getName();

    private MainService mGakuService;
    private WindowCoordinator mWindowCoordinator;

    public MainServiceHandler(MainService mainService, WindowCoordinator windowCoordinator) {
        mGakuService = mainService;
        mWindowCoordinator = windowCoordinator;
    }

    @Override
    public void handleMessage(Message message) {
        if (message.obj instanceof String) {
            Toast.makeText(mGakuService, message.obj.toString(), Toast.LENGTH_SHORT).show();
        } else if (message.obj instanceof OcrResult) {
            OcrResult result = (OcrResult) message.obj;

            Log.d(TAG, result.toString());

            if (result.getDisplayData().getInstantMode()) {
                InstantKanjiWindow instantKanjiWindow = mWindowCoordinator
                        .getWindowOfType(Constants.WINDOW_INSTANT_KANJI);
                instantKanjiWindow.setResult(result.getDisplayData());
                instantKanjiWindow.show();
            } else {
                InformationWindow infoWindow = mWindowCoordinator.getWindowOfType(Constants.WINDOW_INFO);
                infoWindow.setResult(result.getDisplayData());
                infoWindow.show();
            }
        } else if (message.obj instanceof ParsedResult) {
            ParsedResult result = (ParsedResult) message.obj;
            Log.d(TAG, result.toString());

            if (result.getDisplayData().getInstantMode()) {
                // For instant mode, we might still want the old popup or the new one?
                // Mockup suggests we want the new one when we CLICK.
                // But ML Kit is fast enough for instant overlay.
            } else {
                CaptureWindow captureWindow = mWindowCoordinator.getWindowOfType(Constants.WINDOW_CAPTURE);
                captureWindow.setParsedResult(result);
            }
        } else {
            Toast.makeText(mGakuService, String.format("Unable to handle type: %s", message.obj.getClass().getName()),
                    Toast.LENGTH_SHORT).show();
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/MainStartFragment.kt">
package ca.fuwafuwa.gaku

import android.content.Intent
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Bundle
import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.TextPaint
import android.text.method.LinkMovementMethod
import android.text.style.ClickableSpan
import android.util.TypedValue
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.ProgressBar
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import java.util.*


data class ImgData(val res: Int, val name: String, val nameLink: String, val imgLink: String, val hasImg: Boolean = true)

class MainStartFragment : Fragment()
{
    private lateinit var mainActivity : MainActivity
    private lateinit var rootView : View

    private lateinit var gakuLogo : TextView
    private lateinit var gakuTitle : TextView
    private lateinit var tutorialText : TextView
    private lateinit var githubText : TextView
    private lateinit var settingsText : TextView
    private lateinit var syncText : TextView

    private lateinit var supportText : TextView
    private lateinit var progressBar : ProgressBar

    private lateinit var promoView : ViewGroup
    private lateinit var saeView : ImageView

    private lateinit var imgData : ImgData


    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View?
    {
        mainActivity = activity as MainActivity

        rootView = inflater.inflate(R.layout.fragment_start, container, false)

        gakuLogo = rootView.findViewById(R.id.gaku_logo)
        gakuTitle = rootView.findViewById(R.id.gaku_title)
        tutorialText = rootView.findViewById(R.id.gaku_tutorial)
        githubText = rootView.findViewById(R.id.gaku_github)
        settingsText = rootView.findViewById(R.id.gaku_settings)
        syncText = rootView.findViewById(R.id.gaku_sync)

        supportText = rootView.findViewById(R.id.support_text)
        progressBar = rootView.findViewById(R.id.progress_bar)

        promoView = rootView.findViewById(R.id.promoView)
        saeView = rootView.findViewById(R.id.saeView)

        configureBottomPromo()

        tutorialText.setOnClickListener {
            startActivity(Intent(mainActivity, TutorialActivity::class.java))
        }

        githubText.setOnClickListener {
            val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/0xbad1d3a5/gaku"))
            startActivity(browserIntent)
        }

        settingsText.setOnClickListener {
            startActivity(Intent(mainActivity, SettingsActivity::class.java))
        }

        syncText.setOnClickListener {
            ca.fuwafuwa.gaku.Logic.ReviewController(requireContext()).sync()
        }

        return rootView
    }

    override fun onStart()
    {
        super.onStart()

        supportText.viewTreeObserver.addOnGlobalLayoutListener {
            var pos = IntArray(2)
            supportText.getLocationInWindow(pos)
            val drawableHeight = rootView.height - pos[1] - dpToPx(mainActivity, 30)

            val logoSize = drawableHeight.toFloat() / 2
            val titleSize = logoSize / 5
            val textSize = titleSize / 2

            gakuLogo.setTextSize(TypedValue.COMPLEX_UNIT_PX, logoSize)
            gakuTitle.setTextSize(TypedValue.COMPLEX_UNIT_PX, titleSize)
            tutorialText.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize)
            supportText.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize)
        }
    }

    override fun onResume()
    {
        super.onResume()

        if (!MainService.IsRunning())
        {
            onGakuLoadStart()
        }

        Timer().schedule(object : TimerTask()
        {
            override fun run()
            {
                mainActivity.runOnUiThread {
                    mainActivity.startGaku(this@MainStartFragment)
                }
            }
        }, 3000)
    }

    fun onGakuLoadStart()
    {
        progressBar.isIndeterminate = true
        progressBar.progress = 0
        supportText.text = getString(R.string.gaku_loading)
    }

    fun onGakuLoaded()
    {
        progressBar.isIndeterminate = false
        progressBar.progress = 100
        writeSupportText()
    }

    private fun configureBottomPromo()
    {
        setupImage()

        if (MainService.IsRunning())
        {
            onGakuLoaded()
        }
    }

    private fun setupImage()
    {
        imgData = getImageResources()

        if (imgData.hasImg)
        {
            saeView.setImageBitmap(BitmapFactory.decodeStream(resources.openRawResource(imgData.res)))
            saeView.setOnClickListener {
                val i = Intent(Intent.ACTION_VIEW)
                i.data = Uri.parse(imgData.imgLink)
                startActivity(i)
            }
        }
    }

    private fun getImageResources(): ImgData
    {
        val imgs = listOf(
                ImgData(R.raw.sae0001, "@ultonesan", "https://twitter.com/ultonesan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62885659"),
                ImgData(R.raw.sae0002, "@ultonesan", "https://twitter.com/ultonesan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68641857"),
                ImgData(R.raw.sae0003, "@ultonesan", "https://twitter.com/ultonesan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71950613"),
                ImgData(R.raw.sae0021, "@ultonesan", "https://twitter.com/ultonesan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73297155"),
                ImgData(R.raw.sae0044, "@ultonesan", "https://twitter.com/ultonesan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60987977"),
                ImgData(R.raw.sae0004, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73628894"),
                ImgData(R.raw.sae0005, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72424727"),
                ImgData(R.raw.sae0009, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72008999"),
                ImgData(R.raw.sae0016, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66871255"),
                ImgData(R.raw.sae0022, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72822939"),
                ImgData(R.raw.sae0023, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71623460"),
                ImgData(R.raw.sae0024, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71994817"),
                ImgData(R.raw.sae0025, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73311041"),
                ImgData(R.raw.sae0026, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73166793"),
                ImgData(R.raw.sae0027, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73056502"),
                ImgData(R.raw.sae0028, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71894148"),
                ImgData(R.raw.sae0029, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71741734"),
                ImgData(R.raw.sae0030, "@yamoyamo18", "https://twitter.com/yamoyamo18", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71550295"),
                ImgData(R.raw.sae0006, "@Sutoroa_", "https://twitter.com/Sutoroa_", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72284325"),
                ImgData(R.raw.sae0098, "@Sutoroa_", "https://twitter.com/Sutoroa_", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73191911"),
                ImgData(R.raw.sae0007, "", "https://www.pixiv.net/member.php?id=7231087", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=70943811"),
                ImgData(R.raw.sae0008, "fevri", "https://www.pixiv.net/member.php?id=23625153", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71230492"),
                ImgData(R.raw.sae0010, "@ultimate_force6", "https://twitter.com/ultimate_force6", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68200934"),
                ImgData(R.raw.sae0019, "@ultimate_force6", "https://twitter.com/ultimate_force6", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65491060"),
                ImgData(R.raw.sae0020, "@ultimate_force6", "https://twitter.com/ultimate_force6", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71977064"),
                ImgData(R.raw.sae0057, "@ultimate_force6", "https://twitter.com/ultimate_force6", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=74363079"),
                ImgData(R.raw.sae0011, "@RomanticGACHA", "https://twitter.com/RomanticGACHA", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71885557"),
                ImgData(R.raw.sae0013, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=70193706"),
                ImgData(R.raw.sae0014, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=69105225"),
                ImgData(R.raw.sae0015, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=64939768"),
                ImgData(R.raw.sae0065, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57615504"),
                ImgData(R.raw.sae0066, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57126244"),
                ImgData(R.raw.sae0067, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57126244"),
                ImgData(R.raw.sae0068, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62991879"),
                ImgData(R.raw.sae0075, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59695678"),
                ImgData(R.raw.sae0076, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59695678"),
                ImgData(R.raw.sae0096, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73671294"),
                ImgData(R.raw.sae0097, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73262536"),
                ImgData(R.raw.sae0103, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59882410"),
                ImgData(R.raw.sae0017, "@kusanosinta", "https://twitter.com/kusanosinta", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66630846"),
                ImgData(R.raw.sae0018, "@jksh5056", "https://twitter.com/jksh5056", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66503611"),
                ImgData(R.raw.sae0012, "@syounenkross", "https://twitter.com/syounenkross", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=64177621"),
                ImgData(R.raw.sae0031, "@Nb_mk2", "https://twitter.com/Nb_mk2", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63674704"),
                ImgData(R.raw.sae0032, "@Hachita888", "https://twitter.com/Hachita888", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68277697"),
                ImgData(R.raw.sae0033, "@Hachita888", "https://twitter.com/Hachita888", "https://twitter.com/Hachita888/status/1101056129159749632"),
                ImgData(R.raw.sae0034, "Toffee", "https://www.pixiv.net/member.php?id=13274275", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62893744"),
                ImgData(R.raw.sae0035, "@N1__03", "https://twitter.com/N1__03", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63248104"),
                ImgData(R.raw.sae0036, "@yu_hi0420", "https://twitter.com/yu_hi0420", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60998374"),
                ImgData(R.raw.sae0037, "@nike_abc", "https://twitter.com/nike_abc", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63199962"),
                ImgData(R.raw.sae0038, "iwawo", "https://www.pixiv.net/member.php?id=1926865", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62945449"),
                ImgData(R.raw.sae0039, "tamamooon", "https://www.pixiv.net/member.php?id=3796056", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62176436"),
                ImgData(R.raw.sae0040, "Ametama", "https://www.pixiv.net/member.php?id=10122880", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61738328"),
                ImgData(R.raw.sae0041, "@2cFirefly", "https://twitter.com/2cFirefly", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61109132"),
                ImgData(R.raw.sae0042, "LP", "https://www.pixiv.net/member.php?id=9774145", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60911262"),
                ImgData(R.raw.sae0043, "@haikimono", "https://twitter.com/haikimono", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60871513"),
                ImgData(R.raw.sae0045, "@xx__lotus", "https://twitter.com/xx__lotus", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60860221"),
                ImgData(R.raw.sae0046, "@kamonabe_44", "https://twitter.com/kamonabe_44", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60254903"),
                ImgData(R.raw.sae0047, "@Yunagi_Amane", "https://twitter.com/Yunagi_Amane", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60128230"),
                ImgData(R.raw.sae0048, "@Azmo_dan", "https://twitter.com/Azmo_dan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59980990"),
                ImgData(R.raw.sae0049, "@takeashiro", "https://twitter.com/takeashiro", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59770209"),
                ImgData(R.raw.sae0050, "@watanseru", "https://twitter.com/watanseru", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59521673"),
                ImgData(R.raw.sae0051, "@gin_no_te", "https://twitter.com/gin_no_te", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59907147"),
                ImgData(R.raw.sae0052, "miazi", "https://www.pixiv.net/member.php?id=2551745", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59536025"),
                ImgData(R.raw.sae0053, "", "https://www.pixiv.net/member.php?id=15933874", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59420528"),
                ImgData(R.raw.sae0054, "@shiredo326", "https://twitter.com/shiredo326", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59213920"),
                ImgData(R.raw.sae0055, "@kashinoshishi", "https://twitter.com/kashinoshishi", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59283209"),
                ImgData(R.raw.sae0056, "@xxSuite_Peexx", "https://twitter.com/xxSuite_Peexx", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=74367771"),
                ImgData(R.raw.sae0058, "@minami_nyan", "https://twitter.com/minami_nyan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59145679"),
                ImgData(R.raw.sae0059, "@magchomp8", "https://twitter.com/magchomp8", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58950389"),
                ImgData(R.raw.sae0060, "", "https://www.pixiv.net/member.php?id=4939449", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58574011"),
                ImgData(R.raw.sae0061, "@k_nishiwaki", "https://twitter.com/k_nishiwaki", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58034287"),
                ImgData(R.raw.sae0062, "Koji", "https://www.pixiv.net/member.php?id=19228899", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57976156"),
                ImgData(R.raw.sae0063, "@P_KiGiSi", "https://twitter.com/P_KiGiSi", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57758102"),
                ImgData(R.raw.sae0064, "@TakahashiMitama", "https://twitter.com/Takahashimitama", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63206782"),
                ImgData(R.raw.sae0069, "", "https://www.pixiv.net/member.php?id=28781", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=53882354"),
                ImgData(R.raw.sae0072, "", "https://www.pixiv.net/member.php?id=28781", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=54029940"),
                ImgData(R.raw.sae0070, "@25irohaxx", "https://twitter.com/25irohaxx", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59642129"),
                ImgData(R.raw.sae0071, "@pizzasi7", "https://twitter.com/pizzasi7", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59989777"),
                ImgData(R.raw.sae0073, "@frenchmaid_", "https://twitter.com/frenchmaid_", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=53105182"),
                ImgData(R.raw.sae0074, "P-", "https://www.pixiv.net/member.php?id=1032188", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=51178608"),
                ImgData(R.raw.sae0077, "P-", "https://www.pixiv.net/member.php?id=1032188", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=51344144"),
                ImgData(R.raw.sae0106, "P-", "https://www.pixiv.net/member.php?id=1032188", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57042341"),
                ImgData(R.raw.sae0078, "@__KFR", "https://twitter.com/__KFR", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=49375938"),
                ImgData(R.raw.sae0079, "AGG", "https://www.pixiv.net/member.php?id=12310765", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=49664984"),
                ImgData(R.raw.sae0080, "", "https://www.pixiv.net/member.php?id=770137", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=47906259"),
                ImgData(R.raw.sae0081, "@mazakaaaan", "https://twitter.com/mazakaaaan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=47913066"),
                ImgData(R.raw.sae0083, "@mazakaaaan", "https://twitter.com/mazakaaaan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=46008331"),
                ImgData(R.raw.sae0086, "@mazakaaaan", "https://twitter.com/mazakaaaan", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=41998732"),
                ImgData(R.raw.sae0082, "H2O", "https://www.pixiv.net/member.php?id=18180240", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59537085"),
                ImgData(R.raw.sae0084, "@natuya777", "https://twitter.com/natuya777", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=43285880"),
                ImgData(R.raw.sae0085, "@natuya777", "https://twitter.com/natuya777", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=46606608"),
                ImgData(R.raw.sae0087, "", "https://www.pixiv.net/member.php?id=35037", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=36906360"),
                ImgData(R.raw.sae0088, "", "https://www.pixiv.net/member.php?id=383657", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=33659173"),
                ImgData(R.raw.sae0089, "@mckeeeeelog", "https://twitter.com/mckeeeeelog", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=29860757"),
                ImgData(R.raw.sae0090, "@miyakoazu", "https://twitter.com/miyakoazu", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=32349060"),
                ImgData(R.raw.sae0091, "@WzK7VHEGkO0J4E4", "https://twitter.com/WzK7VHEGkO0J4E4", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59587222"),
                ImgData(R.raw.sae0092, "@yuntayu", "https://twitter.com/yuntayu", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=32728220"),
                ImgData(R.raw.sae0093, "@jackallllllllll", "https://twitter.com/jackallllllllll", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=42247716"),
                ImgData(R.raw.sae0094, "@akihiko_05", "https://twitter.com/akihiko_05", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68160948"),
                ImgData(R.raw.sae0095, "Manyo", "https://www.pixiv.net/member.php?id=5940914", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73269188"),
                ImgData(R.raw.sae0099, "@migi_mawashi", "https://twitter.com/migi_mawashi", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73112698"),
                ImgData(R.raw.sae0100, "@syatly", "https://twitter.com/syatly", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=56959669"),
                ImgData(R.raw.sae0101, "@syatly", "https://twitter.com/syatly", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=56959669"),
                ImgData(R.raw.sae0102, "@ponyui0728", "https://twitter.com/ponyui0728", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=56880664"),
                ImgData(R.raw.sae0104, "", "https://www.pixiv.net/member.php?id=6454840", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72524370"),
                ImgData(R.raw.sae0105, "@elesake", "https://twitter.com/elesake", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=44565332")

                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72574413"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72300606"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72319649"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72091546"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72010515"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71846364"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71576086"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71445592"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61286524"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71264363"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=71223663"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68815242"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=72880878"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=69776652"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=70563899"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=69883575"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61621521"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=69759435"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=69644506"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=69541575"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=67888363"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=69598154"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=69176611"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=69297967"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68515979"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=55885699"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66886065"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=67197908"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=67050561"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61808784"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62053790"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=55045464"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68054335"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61583824"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66970564"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66662471"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61854663"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61246834"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66365255"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66254674"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66285209"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=46928698"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66066299"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65987865"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65879293"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62559423"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65712553"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61596965"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=46623623"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63860848"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61191380"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65481843"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60867649"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63856945"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65490674"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63372013"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63350634"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=64114259"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61097071"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=41853425"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=27614826"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61628173"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63524058"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61897582"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62103143"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65479372"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=25326404"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65479726"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=26138046"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60727676"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61046820"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65479738"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63951102"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=65028532"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=24908091"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=64290897"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58546816"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62556140"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59703065"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=64076559"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=36896429"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=31847612"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=52125154"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=32441611"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57866673"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=54074753"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=56498215"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57458361"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60134647"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58973257"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=52640454"),
                //ImgData(R.raw.sae, "", "", "https://www.pixiv.net/member_illust.php?mode=medium&illust_id=51140952"),
                //ImgData(R.raw.sae, "", "", "https://twitter.com/_citrusmikan/status/1084315711516770305"),
                //ImgData(R.raw.sae, "", "", "https://twitter.com/frenchmaid_/status/794449492128825344"),

                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=46620217
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60477054
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=63879982
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60685026
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=54111389
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60556417
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61999933
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=61127239
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59531868
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=60211876
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62135077
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59731482
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58925725
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=53024162
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66740209
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68011261
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=43284648
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59848031
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73629542
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=56041501
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=70976755
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=67062837
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=42178521
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=70270394
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=62495444
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68958428
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68433759
                //https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57793633
        )

        return imgs.random()
    }

    private fun writeSupportText()
    {
        if (imgData.hasImg)
        {
            val saeName = ""
            val artText = "\uD83C\uDF38 $saeName by ${imgData.name} \uD83C\uDF38"
            val spannableStringBuilder = SpannableStringBuilder(artText)

            val clickableSae = object : ClickableSpan()
            {
                override fun onClick(view: View)
                {
                    val i = Intent(Intent.ACTION_VIEW)
                    i.data = Uri.parse("https://twitter.com/hashtag/%E5%B0%8F%E6%97%A9%E5%B7%9D%E7%B4%97%E6%9E%9D")
                    startActivity(i)
                }

                override fun updateDrawState(ds: TextPaint)
                {
                    ds.color = ContextCompat.getColor(activity!!, R.color.blue_dark)
                    ds.isUnderlineText = false;
                }
            }
            spannableStringBuilder.setSpan(clickableSae, artText.indexOf(saeName), artText.indexOf(saeName) + saeName.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

            val clickableLink = object : ClickableSpan()
            {
                override fun onClick(view: View)
                {
                    val i = Intent(Intent.ACTION_VIEW)
                    i.data = Uri.parse(imgData.nameLink)
                    startActivity(i)
                }

                override fun updateDrawState(ds: TextPaint)
                {
                    ds.color = ContextCompat.getColor(activity!!, R.color.blue_dark)
                    ds.isUnderlineText = false;
                }
            }
            spannableStringBuilder.setSpan(clickableLink, artText.indexOf(imgData.name), artText.indexOf(imgData.name) + imgData.name.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

            supportText.text = spannableStringBuilder
            supportText.movementMethod = LinkMovementMethod.getInstance()
        }
        else
        {
            supportText.text = getString(R.string.support_text)
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/PassthroughActivity.kt">
package ca.fuwafuwa.gaku

import android.content.Intent
import android.os.Bundle
import android.view.Window
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.NotificationCompat
import ca.fuwafuwa.gaku.Windows.InformationWindow
import ca.fuwafuwa.gaku.Windows.WindowCoordinator

class PassthroughActivity : AppCompatActivity()
{
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        requestWindowFeature(Window.FEATURE_NO_TITLE);

        setupGakuDatabasesAndFiles(this)

        var processText : String? = null
        when {
            intent?.action == Intent.ACTION_PROCESS_TEXT ->
            {
                processText = intent.getStringExtra(Intent.EXTRA_PROCESS_TEXT)
            }
            intent?.action == Intent.ACTION_SEND ->
            {
                if ("text/plain" == intent.type)
                {
                    processText = intent.getStringExtra(Intent.EXTRA_TEXT)
                }
            }
        }

        if (processText != null)
        {
            val windowCoordinator = WindowCoordinator(applicationContext)
            val infoWindow = windowCoordinator.getWindow(WINDOW_INFO) as InformationWindow

            infoWindow.setResult(processText)
            infoWindow.show()

            finish()
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/SettingsActivity.kt">
package ca.fuwafuwa.gaku

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity

class SettingsActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_settings)
        
        if (savedInstanceState == null) {
            supportFragmentManager
                .beginTransaction()
                .replace(R.id.settings_container, SettingsFragment())
                .commit()
        }
        
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.title = "Settings"
    }

    override fun onSupportNavigateUp(): Boolean {
        finish()
        return true
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/SettingsFragment.kt">
package ca.fuwafuwa.gaku

import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.preference.Preference
import androidx.preference.PreferenceFragmentCompat
import ca.fuwafuwa.gaku.legacy.user.UserDatabaseHelper

class SettingsFragment : PreferenceFragmentCompat() {

    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        setPreferencesFromResource(R.xml.preferences, rootKey)

        // New Preference to open Dictionary Manager
        // Fix: Use requireContext() instead of context
        val dictPref = Preference(requireContext())
        dictPref.key = "manage_dictionaries"
        dictPref.title = "Manage Dictionaries (Yomitan)"
        dictPref.summary = "Import and remove offline dictionaries"
        dictPref.order = 0
        dictPref.setOnPreferenceClickListener {
            startActivity(Intent(requireContext(), DictionaryActivity::class.java))
            true
        }
        preferenceScreen.addPreference(dictPref)

        findPreference<Preference>("db_reinit")?.setOnPreferenceClickListener {
            resetGakuDatabases(requireContext())
            Toast.makeText(context, "Databases re-initialized", Toast.LENGTH_SHORT).show()
            true
        }

        findPreference<Preference>("db_clear_user")?.setOnPreferenceClickListener {
            try {
                val dbHelper = UserDatabaseHelper.instance(requireContext())
                dbHelper.userWordDao.queryForAll().forEach { dbHelper.userWordDao.delete(it) }
                Toast.makeText(context, "User progress cleared", Toast.LENGTH_SHORT).show()
            } catch (e: Exception) {
                Toast.makeText(context, "Clear failed: ${e.message}", Toast.LENGTH_SHORT).show()
            }
            true
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/TutorialActivity.kt">
package ca.fuwafuwa.gaku

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.FragmentStatePagerAdapter
import ca.fuwafuwa.gaku.databinding.ActivityTutorialBinding

class TutorialActivity : AppCompatActivity()
{
    inner class SectionsPagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm)
    {
        override fun getItem(position: Int): Fragment
        {
            if (position == 0){
                return TutorialWelcomeFragment.newInstance()
            }
            if (position in 1..9)
            {
                return TutorialFragment.newInstance(position)
            }

            return TutorialEndFragment.newInstance()
        }

        override fun getCount(): Int
        {
            return 11
        }
    }

    private lateinit var mSectionsPagerAdapter: FragmentStatePagerAdapter
    private lateinit var mBinding: ActivityTutorialBinding

    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        mBinding = ActivityTutorialBinding.inflate(layoutInflater)

        supportActionBar?.hide()
        setContentView(mBinding.root)

        mSectionsPagerAdapter = SectionsPagerAdapter(supportFragmentManager)
        mBinding.container.adapter = mSectionsPagerAdapter
        mBinding.container.offscreenPageLimit = 1
        mBinding.tabIndicator.setupWithViewPager(mBinding.container)
    }

    companion object
    {
        private val TAG = TutorialActivity::class.java.name
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/TutorialEndFragment.kt">
package ca.fuwafuwa.gaku

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import androidx.fragment.app.Fragment
import ca.fuwafuwa.gaku.Dialogs.GrantPermissionDialogFragment

class TutorialEndFragment : Fragment()
{
    private lateinit var rootView : View

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View?
    {
        rootView = inflater.inflate(R.layout.fragment_end, container, false)

        val button = rootView.findViewById<Button>(R.id.tutorial_end_start_gaku)

        button.setOnClickListener {
            GrantPermissionDialogFragment().show(fragmentManager!!, "GrantPermission")
        }

        return rootView
    }

    companion object
    {
        fun newInstance() : TutorialEndFragment {
            return TutorialEndFragment()
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/TutorialFragment.kt">
package ca.fuwafuwa.gaku

import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.*
import android.view.ViewGroup.LayoutParams.WRAP_CONTENT
import android.widget.Button
import android.widget.LinearLayout
import android.widget.VideoView
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.Fragment
import ca.fuwafuwa.gaku.Dialogs.TutorialExplainDialogFragment

class TutorialFragment : Fragment()
{
    private lateinit var mRootView : View
    private lateinit var mVideoView : VideoView
    private lateinit var mButtonLayout : LinearLayout
    private lateinit var mExplainButton: Button
    private var mPos : Int = -1

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View?
    {
        mRootView = inflater.inflate(R.layout.fragment_tutorial, container, false)

        mVideoView = mRootView.findViewById(R.id.instruction_video_view) as VideoView
        mButtonLayout = mRootView.findViewById(R.id.tutorial_buttons) as LinearLayout
        mExplainButton = mRootView.findViewById(R.id.tutorial_button_explain)

        mPos = arguments?.getInt(ARG_SECTION_NUMBER)!!

        mExplainButton.setOnClickListener {
            getExplainDialogForFragment(mPos).show(fragmentManager!!, "ExplainDialog$mPos")
        }

        Log.d(TAG, "onCreateView $mPos")

        return mRootView
    }

    override fun onStart()
    {
        super.onStart()

        mButtonLayout.viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener
        {
            override fun onGlobalLayout()
            {
                val drawableHeight = mButtonLayout.y.toInt()

                val params = LinearLayout.LayoutParams(WRAP_CONTENT, drawableHeight - dpToPx(context!!, 20))
                params.gravity = Gravity.CENTER_HORIZONTAL
                params.setMargins(0, dpToPx(context!!, 20), 0, 0)
                mVideoView.layoutParams = params
                mVideoView.requestLayout()

                mButtonLayout.viewTreeObserver.removeOnGlobalLayoutListener(this)
            }
        })
    }

    override fun onResume()
    {
        super.onResume()

        mVideoView.setVideoURI(Uri.parse("android.resource://ca.fuwafuwa.gaku/${getVideoForSectionNumber(mPos)}"))
        mVideoView.setOnPreparedListener { it.isLooping = true }
        mVideoView.start()
    }

    private fun getExplainDialogForFragment(num: Int) : DialogFragment
    {
        return TutorialExplainDialogFragment.newInstance(getTitleTextForSectionNumber(num), getTextForSectionNumber(num))
    }

    private fun getVideoForSectionNumber(num: Int): Int
    {
        when (num){
            1 -> return R.raw.tut1
            2 -> return R.raw.tut2
            3 -> return R.raw.tut3
            4 -> return R.raw.tut4
            5 -> return R.raw.tut5
            6 -> return R.raw.tut6
            7 -> return R.raw.tut7
            8 -> return R.raw.tut8
            9 -> return R.raw.tut9
        }

        return 0
    }

    private fun getTitleTextForSectionNumber(num: Int): String
    {
        when (num){
            1 -> return "BASIC USAGE"
            2 -> return "INSTANT MODE"
            3 -> return "QUICK IMAGE ACTION - FILTER"
            4 -> return "QUICK TEXT ACTION - SWAP"
            5 -> return "QUICK TEXT ACTION - EDIT"
            6 -> return "QUICK TEXT ACTION - DELETE"
            7 -> return "SEND TO GOOGLE TRANSLATE"
            8 -> return "NOTIFICATION CONTROLS"
            9 -> return "SELECT TO LOOKUP"
        }

        return ""
    }

    private fun getTextForSectionNumber(num: Int): String
    {
        when (num){
            1 -> return "Drag the capture window to move the window. Drag the bottom right corner to resize. Double tap to start OCR and recognize text. Tip: resize area is inside the capture window."
            2 -> return "If instant mode is turned on in the settings and the capture window is fairly small, OCR will start immediately. This mode was intended to recognize words, not sentences."
            3 -> return "If the background of the text you want to recognize is translucent, you can try adjusting the image filter settings by doing a long press, then dragging left or right. Note: image filter setting must be turned on."
            4 -> return "Sometimes Gaku misrecognizes the kanji but can be easily corrected. Perform a quick swipe downward on the kanji for possible alternate recognitions."
            5 -> return "In the case that the correct kanji was not present in the swap quick action, perform a quick swipe to the upper-left to manually input the kanji. For manual correction, you must have a handwriting keyboard installed - for example, Gboard w/ Japanese Handwriting by Google."
            6 -> return "If you need to delete any extraneous characters, swipe to the upper right. For all text quick actions, the swipe direction may be reversed in instant mode when there is not enough screen space."
            7 -> return "Tap and hold on any kanji to copy recognized text to the clipboard. If you have \"Tap to Translate\" enabled in the Google Translate app, that will also be brought up."
            8 -> return "Quickly show/hide Gaku or change Gaku's settings through the notification."
            9 -> return "In the case that you can select the text and don't need OCR, simply select the text and send it to Gaku to bring up the dictionary."
        }

        return ""
    }

    companion object
    {
        private val TAG = TutorialFragment::class.java.name
        private val ARG_SECTION_NUMBER = "section_number"

        fun newInstance(sectionNumber: Int): TutorialFragment
        {
            val fragment = TutorialFragment()
            val args = Bundle()
            args.putInt(ARG_SECTION_NUMBER, sectionNumber)
            fragment.arguments = args
            return fragment
        }
    }
}
</file>

<file path="main/java/ca/fuwafuwa/gaku/TutorialWelcomeFragment.kt">
package ca.fuwafuwa.gaku

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment

class TutorialWelcomeFragment : Fragment()
{
    private lateinit var rootView : View

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View?
    {
        rootView = inflater.inflate(R.layout.fragment_welcome, container, false)

        return rootView
    }

    companion object
    {
        fun newInstance() : TutorialWelcomeFragment {
            return TutorialWelcomeFragment()
        }
    }
}
</file>

<file path="main/java/DictionaryActivity.kt">
package ca.fuwafuwa.gaku

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import ca.fuwafuwa.gaku.data.AppDatabase
import ca.fuwafuwa.gaku.data.dao.DictionarySummary
import ca.fuwafuwa.gaku.data.importer.YomitanImporter
import com.google.android.material.floatingactionbutton.FloatingActionButton
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.text.NumberFormat

class DictionaryActivity : AppCompatActivity() {

    private lateinit var db: AppDatabase
    private lateinit var adapter: DictionaryAdapter
    private lateinit var progressBar: ProgressBar
    private lateinit var statusText: TextView
    private val scope = CoroutineScope(Dispatchers.Main)

    private val importLauncher = registerForActivityResult(ActivityResultContracts.OpenDocument()) { uri: Uri? ->
        uri?.let { importDictionary(it) }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_dictionary)

        db = AppDatabase.getDatabase(this)
        progressBar = findViewById(R.id.import_progress)
        statusText = findViewById(R.id.import_status)

        val recycler = findViewById<RecyclerView>(R.id.dict_list)
        recycler.layoutManager = LinearLayoutManager(this)
        adapter = DictionaryAdapter { dict -> deleteDictionary(dict.dictionary.id, dict.dictionary.name) }
        recycler.adapter = adapter

        findViewById<FloatingActionButton>(R.id.btn_add_dict).setOnClickListener {
            importLauncher.launch(arrayOf("application/zip", "application/x-zip-compressed", "application/octet-stream"))
        }

        loadDictionaries()
    }

    private fun loadDictionaries() {
        scope.launch(Dispatchers.IO) {
            val dicts = db.dictionaryDao().getDictionariesWithStats()
            withContext(Dispatchers.Main) {
                adapter.submitList(dicts)
            }
        }
    }

    private fun importDictionary(uri: Uri) {
        val stream = contentResolver.openInputStream(uri) ?: return
        
        progressBar.visibility = View.VISIBLE
        statusText.visibility = View.VISIBLE
        statusText.text = "Preparing import..."
        progressBar.isIndeterminate = false
        
        scope.launch(Dispatchers.IO) {
            val startTime = System.currentTimeMillis()
            var lastUpdate = 0L

            try {
                val importer = YomitanImporter(db)
                importer.importDictionary(stream) { progress ->
                    val now = System.currentTimeMillis()
                    // Update UI every 100ms max to prevent stutter
                    if (now - lastUpdate > 100 || progress.currentFileIndex == progress.totalFiles) {
                        lastUpdate = now
                        val processed = progress.currentFileIndex
                        val total = progress.totalFiles
                        
                        val elapsedTime = now - startTime
                        val eta = if (processed > 0) {
                            val timePerFile = elapsedTime / processed.toDouble()
                            val remainingFiles = total - processed
                            (timePerFile * remainingFiles).toLong()
                        } else 0L

                        val etaSec = eta / 1000
                        val etaStr = if (etaSec > 60) "${etaSec / 60}m ${etaSec % 60}s" else "${etaSec}s"

                        runOnUiThread {
                            progressBar.max = total
                            progressBar.progress = processed
                            statusText.text = "Importing: ${progress.fileName}\n(${processed}/${total}) - ETA: $etaStr"
                        }
                    }
                }
                loadDictionaries()
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@DictionaryActivity, "Import Successful", Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@DictionaryActivity, "Import Failed: ${e.message}", Toast.LENGTH_LONG).show()
                    e.printStackTrace()
                }
            } finally {
                withContext(Dispatchers.Main) {
                    progressBar.visibility = View.GONE
                    statusText.visibility = View.GONE
                }
            }
        }
    }

    private fun deleteDictionary(id: Long, name: String) {
        AlertDialog.Builder(this)
            .setTitle("Delete Dictionary")
            .setMessage("Are you sure you want to delete '$name'? This cannot be undone.")
            .setPositiveButton("Delete") { _, _ ->
                scope.launch(Dispatchers.IO) {
                    db.dictionaryDao().deleteDictionary(id)
                    loadDictionaries()
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
}

class DictionaryAdapter(
    private val onDelete: (DictionarySummary) -> Unit
) : RecyclerView.Adapter<DictionaryAdapter.ViewHolder>() {

    private var list = listOf<DictionarySummary>()

    fun submitList(newList: List<DictionarySummary>) {
        list = newList
        notifyDataSetChanged()
    }

    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val name: TextView = view.findViewById(R.id.dict_name)
        val meta: TextView = view.findViewById(R.id.dict_meta)
        val delete: ImageButton = view.findViewById(R.id.btn_delete_dict)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_dictionary, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val item = list[position]
        holder.name.text = item.dictionary.name
        
        val numberFormat = NumberFormat.getInstance()
        val terms = numberFormat.format(item.termCount)
        val kanji = numberFormat.format(item.kanjiCount)
        
        holder.meta.text = "Rev: ${item.dictionary.revision} | $terms Terms | $kanji Kanji"
        holder.delete.setOnClickListener { onDelete(item) }
    }

    override fun getItemCount() = list.size
}
</file>

<file path="main/res/anim/fade_repeat.xml">
<?xml version="1.0" encoding="utf-8"?>
<alpha xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromAlpha="0.0"
    android:toAlpha="1.0"
    android:duration="500"
    android:repeatCount="infinite"
    android:repeatMode="reverse"
    />
</file>

<file path="main/res/anim/slide_in.xml">
<?xml version="1.0" encoding="utf-8"?>
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="250"
    android:fromYDelta="-100%"
    android:toYDelta="0%"
     />
</file>

<file path="main/res/drawable/bg_solid_border_0_blue_black.xml">
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
       android:shape="rectangle">
    <stroke
        android:width="1dp"
        android:color="@color/PrimaryDark"/>
    <solid android:color="@color/blue_solid_highlight"/>
</shape>
</file>

<file path="main/res/drawable/bg_solid_border_0_nil_white.xml">
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#FFFFFF" />
    <corners android:radius="8dp" />
</shape>
</file>

<file path="main/res/drawable/bg_solid_border_0_white_black.xml">
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
       android:shape="rectangle">
    <stroke
        android:width="1dp"
        android:color="@color/PrimaryDark"/>
    <solid android:color="@android:color/white"/>
</shape>
</file>

<file path="main/res/drawable/bg_solid_border_corners_0_white_black_round.xml">
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="rectangle">
            <solid android:color="#CABBBBBB"/>
            <corners android:radius="2dp" />
        </shape>
    </item>

    <item
        android:left="1dp"
        android:right="1dp"
        android:top="1dp"
        android:bottom="1dp">
        <shape android:shape="rectangle">
            <solid android:color="@android:color/white"/>
            <corners android:radius="1dp" />
        </shape>
    </item>
</layer-list>
</file>

<file path="main/res/drawable/bg_translucent_border_0_black_black.xml">
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
       android:shape="rectangle">
    <stroke
        android:width="1dp"
        android:color="@color/PrimaryDark"/>
    <solid android:color="@color/black100a"/>
</shape>
</file>

<file path="main/res/drawable/bg_translucent_border_0_blue_blue.xml">
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <corners
        android:radius="0dp"/>
    <stroke
        android:width="1dp"
        android:color="@color/blue_dark"/>
    <solid android:color="@color/blue_dark_translucent"/>
</shape>
</file>

<file path="main/res/drawable/bg_transparent_border_0_nil_black.xml">
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
       android:shape="rectangle">
    <stroke
        android:width="1dp"
        android:color="@color/black100a"/>
    <solid android:color="@android:color/transparent"/>
</shape>
</file>

<file path="main/res/drawable/bg_transparent_border_0_nil_default.xml">
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
       android:shape="rectangle">
    <corners
        android:radius="0dp"/>
    <stroke
        android:width="1dp"
        android:color="@color/blue_dark"/>
    <solid android:color="@android:color/transparent"/>
</shape>
</file>

<file path="main/res/drawable/bg_transparent_border_0_nil_ready.xml">
<!-- app/src/main/res/drawable/bg_transparent_border_0_nil_ready.xml -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="rectangle">
            <stroke
                android:width="2dp" 
                android:color="@color/blue_dark" />
            <solid android:color="#110064ff" />
        </shape>
    </item>
</layer-list>
</file>

<file path="main/res/drawable/bg_word_selection.xml">
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#220064ff"/> <!-- Slight transparent blue fill -->
    <stroke
        android:width="2dp"
        android:color="@color/blue_dark"/> <!-- 2dp border as requested -->
    <corners android:radius="4dp"/>
</shape>
</file>

<file path="main/res/drawable-anydpi/icon_delete.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="33.6"
    android:viewportHeight="33.6"
    android:tint="#C80000">
  <group android:translateX="4.8"
      android:translateY="4.8">
      <path
          android:fillColor="#FF000000"
          android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2V7H6v12zM19,4h-3.5l-1,-1h-5l-1,1H5v2h14V4z"/>
  </group>
</vector>
</file>

<file path="main/res/drawable-anydpi/icon_edit.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="33.6"
    android:viewportHeight="33.6"
    android:tint="#C80000">
  <group android:translateX="4.8"
      android:translateY="4.8">
      <path
          android:fillColor="#FF000000"
          android:pathData="M3,17.25V21h3.75L17.81,9.94l-3.75,-3.75L3,17.25zM20.71,7.04c0.39,-0.39 0.39,-1.02 0,-1.41l-2.34,-2.34c-0.39,-0.39 -1.02,-0.39 -1.41,0l-1.83,1.83 3.75,3.75 1.83,-1.83z"/>
  </group>
</vector>
</file>

<file path="main/res/drawable-anydpi/icon_swap.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="33.6"
    android:viewportHeight="33.6"
    android:tint="#C80000">
  <group android:translateX="4.8"
      android:translateY="4.8">
      <path
          android:fillColor="#FF000000"
          android:pathData="M6.99,11L3,15l3.99,4v-3H14v-2H6.99v-3zM21,9l-3.99,-4v3H10v2h7.01v3L21,9z"/>
  </group>
</vector>
</file>

<file path="main/res/layout/activity_beta.xml">
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".BetaActivity"
    android:background="@android:color/black"
    android:orientation="vertical">

    <TextView
        android:id="@+id/hello"
        android:layout_width="wrap_content"
        android:layout_height="0dp"
        android:layout_marginStart="24dp"
        android:text="Hello,  Beta User!"
        android:textColor="@android:color/white"
        android:gravity="center_vertical"
        android:textSize="25sp"
        android:layout_weight="1" />

    <ScrollView
        android:id="@+id/scroll_message"
        android:layout_width="wrap_content"
        android:layout_height="0dp"
        android:layout_weight="5"
        android:paddingLeft="24dp"
        android:paddingRight="24dp">
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/beta_screen"
            android:textColor="@android:color/white"
            android:textSize="14sp" />
    </ScrollView>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:orientation="horizontal"
        android:layout_weight="1">
        <Button
            android:id="@+id/beta_button_email"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="20dp"
            android:layout_gravity="center_vertical"
            android:text="E-mail Dev" />
        <View
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_weight="1" />
        <Button
            android:id="@+id/beta_button_start"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="20dp"
            android:layout_gravity="center_vertical"
            android:text="Start Gaku" />
    </LinearLayout>
</LinearLayout>
</file>

<file path="main/res/layout/activity_dictionary.xml">
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/dict_list"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/btn_add_dict"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:src="@android:drawable/ic_input_add"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/import_status"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_margin="24dp"
        android:gravity="center"
        android:text="Initializing..."
        android:textColor="@android:color/black"
        android:background="#DDFFFFFF"
        android:padding="8dp"
        android:elevation="4dp"
        android:visibility="gone"
        app:layout_constraintBottom_toTopOf="@+id/import_progress"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent" />

    <ProgressBar
        android:id="@+id/import_progress"
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_margin="24dp"
        android:visibility="gone"
        android:indeterminate="true"
        app:layout_constraintBottom_toTopOf="@+id/btn_add_dict"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>
</file>

<file path="main/res/layout/activity_main.xml">
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

<fragment
    android:id="@+id/main_fragment"
    android:name="ca.fuwafuwa.gaku.MainStartFragment"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
</LinearLayout>
</file>

<file path="main/res/layout/activity_passthrough.xml">
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
</file>

<file path="main/res/layout/activity_settings.xml">
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/settings_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
</file>

<file path="main/res/layout/activity_tutorial.xml">
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"

    android:orientation="vertical">

    <com.google.android.material.tabs.TabLayout
        android:id="@+id/tab_indicator"
        android:layout_width="match_parent"
        android:layout_height="10dp"
        app:tabMaxWidth="0dp"
        app:tabGravity="fill"
        app:tabMode="fixed"
        app:tabIndicatorHeight="10dp"
        app:tabBackground="@android:color/background_dark"
        app:tabIndicatorColor="@android:color/darker_gray"/>

    <androidx.viewpager.widget.ViewPager
        android:id="@+id/container"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior" />

</LinearLayout>
</file>

<file path="main/res/layout/dialog_rating_stars.xml">
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal"
    android:gravity="center">
    <TextView
        android:id="@+id/dialog_rating_star1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:layout_marginLeft="5dp"
        android:layout_marginRight="5dp"
        android:textSize="40sp"
        android:text=""/>
    <TextView
        android:id="@+id/dialog_rating_star2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:layout_marginLeft="5dp"
        android:layout_marginRight="5dp"
        android:textSize="40sp"
        android:text=""/>
    <TextView
        android:id="@+id/dialog_rating_star3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:layout_marginLeft="5dp"
        android:layout_marginRight="5dp"
        android:textSize="40sp"
        android:text=""/>
    <TextView
        android:id="@+id/dialog_rating_star4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:layout_marginLeft="5dp"
        android:layout_marginRight="5dp"
        android:textSize="40sp"
        android:text=""/>
    <TextView
        android:id="@+id/dialog_rating_star5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:layout_marginLeft="5dp"
        android:layout_marginRight="5dp"
        android:textSize="40sp"
        android:text=""/>
</LinearLayout>
</file>

<file path="main/res/layout/fragment_end.xml">
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="@color/Primary"
    tools:context=".TutorialWelcomeFragment">

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.25">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:text=""
            android:textColor="@color/PrimaryDark"
            android:textSize="200dp" />

        <TextView
            android:layout_width="300dp"
            android:layout_height="wrap_content"
            android:text="Enjoy Gaku!"
            android:textColor="@color/PrimaryDark"
            android:textSize="32dp" />

        <TextView
            android:id="@+id/tutorial_end_text"
            android:layout_width="300dp"
            android:layout_height="wrap_content"
            android:layout_marginTop="20dp"
            android:text="Good luck in your Japanese journey. The road will be long and hard, but it will be worth it."
            android:textColor="@color/PrimaryDark"
            android:textSize="20dp" />

        <Button
            android:id="@+id/tutorial_end_start_gaku"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:layout_marginTop="30dp"
            android:text="Start Gaku"/>
    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>
</file>

<file path="main/res/layout/fragment_start.xml">
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="@color/Primary"
    tools:context=".MainStartFragment">

    <TextView
        android:id="@+id/gaku_logo"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text=""
        android:textColor="@color/PrimaryDark"
        android:textSize="150sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <TextView
        android:id="@+id/gaku_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="Japanese OCR Dictionary"
        android:textColor="@color/PrimaryDark"
        android:textSize="20sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/gaku_logo" />

    <TextView
        android:id="@+id/gaku_tutorial"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:layout_marginTop="10dp"
        android:padding="10dp"
        android:text="Tap Here to View Tutorial"
        android:textColor="@color/blue_dark"
        android:textSize="12sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/gaku_title" />

    <TextView
        android:id="@+id/gaku_github"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:padding="10dp"
        android:text="Dev? GitHub Here"
        android:textColor="@color/blue_dark"
        android:textSize="12sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/gaku_tutorial" />

    <TextView
        android:id="@+id/gaku_settings"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:padding="10dp"
        android:text="Settings / API / DB"
        android:textColor="@color/blue_dark"
        android:textSize="12sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/gaku_github" />

    <TextView
        android:id="@+id/gaku_sync"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:padding="10dp"
        android:text="Sync Jiten Status"
        android:textColor="@color/blue_dark"
        android:textSize="12sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/gaku_settings" />

    <TextView
        android:id="@+id/support_text"
        android:layout_width="300dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:layout_marginStart="8dp"
        android:layout_marginEnd="8dp"
        android:layout_marginBottom="15dp"
        android:gravity="center"
        android:text="@string/gaku_loading"
        android:textColor="@color/PrimaryDark"
        android:textSize="12sp"
        app:layout_constraintBottom_toBottomOf="@+id/horizontal_line"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent" />

    <FrameLayout
        android:id="@+id/frameLayout"
        android:layout_width="300dp"
        android:layout_height="4dp"
        android:layout_marginStart="8dp"
        android:layout_marginEnd="8dp"
        app:layout_constraintBottom_toTopOf="@+id/horizontal_line"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent">

        <ProgressBar
            android:id="@+id/progress_bar"
            style="?android:attr/progressBarStyleHorizontal"
            android:layout_width="300dp"
            android:layout_height="32dp"
            android:layout_gravity="center"
            android:indeterminate="true"
            android:indeterminateOnly="false" />
    </FrameLayout>

    <FrameLayout
        android:id="@+id/horizontal_line"
        android:layout_width="300dp"
        android:layout_height="1dp"
        android:background="@android:color/black"
        app:layout_constraintBottom_toTopOf="@+id/promoView"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent">
    </FrameLayout>

    <FrameLayout
        android:id="@+id/promoView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="25dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent">
        <ImageView
            android:id="@+id/saeView"
            android:layout_width="300dp"
            android:layout_height="250dp"
            android:background="@android:color/holo_red_dark"/>
    </FrameLayout>

</androidx.constraintlayout.widget.ConstraintLayout>
</file>

<file path="main/res/layout/fragment_tutorial.xml">
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="@color/Primary">

    <VideoView
            android:id="@+id/instruction_video_view"
            android:layout_marginTop="20dp"
            android:layout_width="wrap_content"
            android:layout_height="0dp"
            android:layout_gravity="center_horizontal"
            tools:ignore="Suspicious0dp" />

    <View
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_weight="1"/>

    <LinearLayout
        android:id="@+id/tutorial_buttons"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:orientation="horizontal">
        <View
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_weight="4" />
        <Button
            android:id="@+id/tutorial_button_explain"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="15dp"
            android:layout_gravity="center_vertical"
            android:text="Explain" />
        <!--
        <View
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_weight="1" />
        <Button
            android:id="@+id/tutorial_button_next"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="10dp"
            android:layout_gravity="center_vertical"
            android:enabled="false"
            android:text="Next" />
            -->
        <View
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_weight="4" />
    </LinearLayout>

</LinearLayout>
</file>

<file path="main/res/layout/fragment_welcome.xml">
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="@color/Primary"
    tools:context=".TutorialWelcomeFragment">

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.25">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:text=""
            android:textColor="@color/PrimaryDark"
            android:textSize="200dp" />

        <TextView
            android:layout_width="300dp"
            android:layout_height="wrap_content"
            android:text="Welcome to Gaku!"
            android:textColor="@color/PrimaryDark"
            android:textSize="28dp" />

        <TextView
            android:layout_width="300dp"
            android:layout_height="wrap_content"
            android:layout_marginTop="20dp"
            android:text="Please take the next few minutes to read through the tutorial and familiarize yourself with Gaku. There's a lot to learn!\n\nTo begin, slide right."
            android:textColor="@color/PrimaryDark"
            android:textSize="20dp" />
    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>
</file>

<file path="main/res/layout/item_dictionary.xml">
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="16dp"
    android:gravity="center_vertical"
    android:background="?android:attr/selectableItemBackground">

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:orientation="vertical">

        <TextView
            android:id="@+id/dict_name"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Dictionary Name"
            android:textSize="16sp"
            android:textStyle="bold"
            android:textColor="#000000" />

        <TextView
            android:id="@+id/dict_meta"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Revision"
            android:textSize="12sp"
            android:textColor="#666666" />
    </LinearLayout>

    <ImageButton
        android:id="@+id/btn_delete_dict"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/icon_delete"
        android:background="?android:attr/selectableItemBackgroundBorderless"
        android:padding="8dp"
        android:tint="#FF0000" />

</LinearLayout>
</file>

<file path="main/res/layout/view_popup_word.xml">
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="300dp"
    android:layout_height="wrap_content"
    android:background="@drawable/bg_solid_border_0_nil_white"
    android:padding="12dp"
    android:elevation="12dp"
    android:id="@+id/popup_root_layout">

    <!-- Header Area (Fixed) -->
    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="8dp">

        <ImageButton
            android:id="@+id/btn_close_popup"
            android:layout_width="24dp"
            android:layout_height="24dp"
            android:layout_alignParentTop="true"
            android:layout_alignParentStart="true"
            android:background="?android:attr/selectableItemBackgroundBorderless"
            android:src="@android:drawable/ic_menu_close_clear_cancel"
            android:tint="#e74c3c"
            android:padding="2dp"
            android:scaleType="centerInside"
            android:contentDescription="Close" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="bottom"
            android:layout_toEndOf="@id/btn_close_popup"
            android:layout_marginStart="8dp">

            <TextView
                android:id="@+id/popup_word"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text=""
                android:textSize="24sp"
                android:fontFamily="sans-serif-medium"
                android:textColor="#2c3e50" />

            <TextView
                android:id="@+id/popup_tag"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="KNOWN"
                android:paddingStart="8dp"
                android:paddingEnd="8dp"
                android:paddingTop="2dp"
                android:paddingBottom="2dp"
                android:textSize="10sp"
                android:letterSpacing="0.1"
                android:textStyle="bold"
                android:textColor="#FFFFFF"
                android:background="@drawable/bg_solid_border_corners_0_white_black_round" />
        </LinearLayout>
    </RelativeLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="#f5f5f5"
        android:layout_marginBottom="8dp"/>

    <!-- Scrollable Content Area -->
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:fadeScrollbars="false"
        android:scrollbarStyle="insideOverlay">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <!-- Pitch Accent Visualization -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:layout_marginBottom="8dp">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="ACCENT"
                    android:textSize="9sp"
                    android:textColor="#FFFFFF"
                    android:textStyle="bold"
                    android:paddingStart="4dp"
                    android:paddingEnd="4dp"
                    android:paddingTop="1dp"
                    android:paddingBottom="1dp"
                    android:background="#9b59b6"
                    android:layout_marginEnd="8dp"/>

                <ca.fuwafuwa.gaku.Windows.Views.PitchAccentGraphView
                    android:id="@+id/popup_pitch_graph"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:background="#00000000"/>
            </LinearLayout>

            <!-- Definition Area -->
            <TextView
                android:id="@+id/popup_def"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Definition text goes here..."
                android:textSize="14sp"
                android:textColor="#34495e"
                android:lineSpacingMultiplier="1.1"/>

            <TextView
                android:id="@+id/popup_freq"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Freq: Top 100"
                android:textSize="9sp"
                android:textColor="#95a5a6"
                android:background="#f8f9fa"
                android:paddingStart="4dp"
                android:paddingEnd="4dp"
                android:paddingTop="1dp"
                android:paddingBottom="1dp"
                android:layout_marginTop="8dp"
                android:layout_gravity="end"/>

        </LinearLayout>
    </ScrollView>

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="#f5f5f5"
        android:layout_marginTop="8dp"
        android:layout_marginBottom="4dp"/>

    <!-- Mining Buttons (New / Unknown words) -->
    <LinearLayout
        android:id="@+id/layout_mining_buttons"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="0dp"
        android:gravity="center"
        android:visibility="gone">

        <Button
            android:id="@+id/btn_mine_add"
            android:layout_width="0dp"
            android:layout_height="36dp"
            android:layout_weight="1"
            android:text="Add"
            style="?android:attr/borderlessButtonStyle"
            android:textSize="11sp"
            android:textColor="#2ecc71"
            android:textAllCaps="false"/>

        <Button
            android:id="@+id/btn_mine_blacklist"
            android:layout_width="0dp"
            android:layout_height="36dp"
            android:layout_weight="1"
            android:text="Block"
            style="?android:attr/borderlessButtonStyle"
            android:textSize="11sp"
            android:textColor="#e74c3c"
            android:textAllCaps="false"/>

        <Button
            android:id="@+id/btn_mine_never_forget"
            android:layout_width="0dp"
            android:layout_height="36dp"
            android:layout_weight="1"
            android:text="Forget-Me-Not"
            style="?android:attr/borderlessButtonStyle"
            android:textSize="9sp"
            android:textColor="#f1c40f"
            android:textAllCaps="false"/>
    </LinearLayout>

    <!-- Grading Buttons (Known / Learning / Due / Mastered words) -->
    <LinearLayout
        android:id="@+id/layout_grading_buttons"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="0dp"
        android:gravity="center"
        android:visibility="gone">

        <Button
            android:id="@+id/btn_grade_nothing"
            android:layout_width="0dp"
            android:layout_height="36dp"
            android:layout_weight="1"
            android:text="Nothing"
            style="?android:attr/borderlessButtonStyle"
            android:textSize="9sp"
            android:textColor="#95a5a6"
            android:padding="0dp"
            android:textAllCaps="false"/>
        <Button
            android:id="@+id/btn_grade_something"
            android:layout_width="0dp"
            android:layout_height="36dp"
            android:layout_weight="1"
            android:text="Smt"
            style="?android:attr/borderlessButtonStyle"
            android:textSize="9sp"
            android:textColor="#e67e22"
            android:padding="0dp"
            android:textAllCaps="false"/>
        <Button
            android:id="@+id/btn_grade_hard"
            android:layout_width="0dp"
            android:layout_height="36dp"
            android:layout_weight="1"
            android:text="Hard"
            style="?android:attr/borderlessButtonStyle"
            android:textSize="9sp"
            android:textColor="#e74c3c"
            android:padding="0dp"
            android:textAllCaps="false"/>
        <Button
            android:id="@+id/btn_grade_good"
            android:layout_width="0dp"
            android:layout_height="36dp"
            android:layout_weight="1"
            android:text="Good"
            style="?android:attr/borderlessButtonStyle"
            android:textSize="9sp"
            android:textColor="#2ecc71"
            android:padding="0dp"
            android:textAllCaps="false"/>
        <Button
            android:id="@+id/btn_grade_easy"
            android:layout_width="0dp"
            android:layout_height="36dp"
            android:layout_weight="1"
            android:text="Easy"
            style="?android:attr/borderlessButtonStyle"
            android:textSize="9sp"
            android:textColor="#3498db"
            android:padding="0dp"
            android:textAllCaps="false"/>
    </LinearLayout>

</LinearLayout>
</file>

<file path="main/res/layout/window_capture.xml">
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- Snap Guides  -->
    <View android:id="@+id/guide_h" android:layout_width="match_parent" android:layout_height="1dp" 
          android:background="#44FF0000" android:layout_gravity="center_vertical" android:visibility="gone"/>
    <View android:id="@+id/guide_v" android:layout_width="1dp" android:layout_height="match_parent" 
          android:background="#44FF0000" android:layout_gravity="center_horizontal" android:visibility="gone"/>

    <RelativeLayout android:id="@+id/capture_box"
        android:layout_width="match_parent" android:layout_height="match_parent"
        android:background="@drawable/bg_transparent_border_0_nil_ready" />

    <!-- Corner Indicators -->
    <View android:layout_width="6dp" android:layout_height="6dp" android:background="@color/blue_dark" android:layout_gravity="top|left"/>
    <View android:layout_width="6dp" android:layout_height="6dp" android:background="@color/blue_dark" android:layout_gravity="top|right"/>
    <View android:layout_width="6dp" android:layout_height="6dp" android:background="@color/blue_dark" android:layout_gravity="bottom|left"/>
    <View android:layout_width="6dp" android:layout_height="6dp" android:background="@color/blue_dark" android:layout_gravity="bottom|right" android:backgroundTint="#FF0000"/> <!-- Resize corner -->

    <!-- Preset Bar -->
    <HorizontalScrollView
        android:id="@+id/preset_bar"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="top|center_horizontal"
        android:background="#AA000000"
        android:padding="2dp"
        android:visibility="gone">
        <LinearLayout android:id="@+id/preset_container" android:orientation="horizontal" android:layout_width="wrap_content" android:layout_height="wrap_content" />
    </HorizontalScrollView>


    <ImageView
        android:id="@+id/capture_image"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <ca.fuwafuwa.gaku.Windows.Views.WordOverlayView
        android:id="@+id/word_overlay"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:visibility="gone"/>

</FrameLayout>
</file>

<file path="main/res/layout/window_edit.xml">
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/edit_text_linear_layout">

    <ImageView
        android:id="@+id/edit_kanji_image"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="@android:color/white"
        android:scaleType="fitCenter"
        android:layout_above="@+id/edit_text" />

    <ca.fuwafuwa.gaku.Windows.Views.ChoiceEditText
        android:id="@+id/edit_text"
        android:imeOptions="flagNoExtractUi"
        android:maxLines="1"
        android:inputType="text"
        android:padding="10dp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:focusable="true"
        android:hint="Handwrite Here"
        android:textColor="@android:color/black"
        android:background="@android:color/white"
        android:layout_alignParentBottom="true"/>

</RelativeLayout>
</file>

<file path="main/res/layout/window_history.xml">
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/history_window_container"
    android:animateLayoutChanges="false"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:id="@+id/history_window_kanji"
        android:layout_width="match_parent"
        android:layout_height="30dp"
        android:orientation="horizontal"
        android:layout_marginTop="5dp"
        android:layout_marginLeft="5dp"
        android:layout_marginRight="5dp"
        android:background="@drawable/bg_solid_border_corners_0_white_black_round">

        <HorizontalScrollView
            android:id="@+id/past_kanji_scroll_view"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:scrollbars="none">
            <LinearLayout
                android:id="@+id/past_kanji"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:orientation="horizontal">
            </LinearLayout>
        </HorizontalScrollView>

        <TextView
            android:id="@+id/history_window_layout_button"
            android:textColor="@android:color/black"
            android:layout_width="30dp"
            android:layout_height="30dp"
            android:background="@drawable/bg_solid_border_corners_0_white_black_round"
            android:textSize="10dp"
            android:padding="5dp"
            android:gravity="center"
            android:text=""/>

    </LinearLayout>

    <LinearLayout
        android:id="@+id/history_window_results"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:background="@drawable/bg_solid_border_corners_0_white_black_round">
        <TextView
            android:padding="5dp"
            android:id="@+id/history_dict_result"
            android:textColor="@android:color/black"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />
    </LinearLayout>

</LinearLayout>
</file>

<file path="main/res/layout/window_info.xml">
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:id="@+id/info_window"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="10dp"
        android:layout_marginLeft="10dp"
        android:layout_marginRight="10dp"
        android:layout_marginBottom="100dp"
        android:background="@drawable/bg_solid_border_corners_0_white_black_round">

        <LinearLayout
            android:orientation="vertical"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_marginLeft="5dp"
            android:layout_marginRight="5dp"
            android:layout_marginBottom="5dp">

            <LinearLayout
                android:orientation="vertical"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_margin="10dp">

                <ca.fuwafuwa.gaku.Windows.Views.KanjiGridView
                    android:id="@+id/kanji_grid"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_margin="5dp" />

                <ScrollView
                    android:layout_width="match_parent"
                    android:layout_height="0dp"
                    android:layout_weight="1"
                    android:layout_margin="5dp"
                    android:animateLayoutChanges="true"
                    android:scrollbars="vertical">

                    <LinearLayout
                        android:id="@+id/info_text"
                        android:animateLayoutChanges="true"
                        android:orientation="vertical"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content">
                        <TextSwitcher
                            android:id="@+id/dict_results"
                            android:measureAllChildren="false"
                            android:animateLayoutChanges="true"
                            android:inAnimation="@anim/slide_in"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content">
                            <TextView
                                android:textColor="@android:color/black"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content" />
                            <TextView
                                android:textColor="@android:color/black"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content" />
                        </TextSwitcher>

                    </LinearLayout>

                </ScrollView>

            </LinearLayout>

        </LinearLayout>

    </LinearLayout>

</FrameLayout>
</file>

<file path="main/res/layout/window_instant_info.xml">
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/instant_info_window_layout"
    android:paddingTop="5dp"
    android:paddingBottom="5dp"
    android:paddingLeft="5dp"
    android:paddingRight="5dp">

    <LinearLayout
        android:id="@+id/instant_window_text_frame"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="@drawable/bg_solid_border_corners_0_white_black_round">

        <TextView
            android:id="@+id/instant_window_text"
            android:layout_margin="5dp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:background="@android:color/transparent"
            android:text="TEST"/>

    </LinearLayout>

</FrameLayout>
</file>

<file path="main/res/layout/window_instant_kanji.xml">
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/instant_kanji_window_layout"
    android:padding="5dp">

    <LinearLayout
        android:id="@+id/instant_window_kanji_frame"
        android:layout_height="wrap_content"
        android:layout_width="wrap_content"
        android:background="@drawable/bg_solid_border_corners_0_white_black_round">

    <ca.fuwafuwa.gaku.Windows.Views.KanjiGridView
        android:id="@+id/kanji_grid"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"/>

    </LinearLayout>

</FrameLayout>
</file>

<file path="main/res/layout/window_kanji_choice.xml">
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/kanji_choice_window"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
</RelativeLayout>
</file>

<file path="main/res/layout/window.xml">
<?xml version="1.0" encoding="utf-8"?>
<ca.fuwafuwa.gaku.Windows.Views.WindowView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/window_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <RelativeLayout
        android:id="@+id/content_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
    <ca.fuwafuwa.gaku.Windows.Views.ResizeView
        android:id="@+id/resize_view"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_alignParentBottom="true"
        android:layout_alignParentRight="true" />
</ca.fuwafuwa.gaku.Windows.Views.WindowView>
</file>

<file path="main/res/mipmap-anydpi-v26/ic_launcher_round.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="main/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="main/res/values/arrays.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="text_direction_entries">
        <item>Auto Detect</item>
        <item>Horizontal Only</item>
        <item>Vertical Only</item>
    </string-array>
    <string-array name="text_direction_values">
        <item>AUTO</item>
        <item>HORIZONTAL</item>
        <item>VERTICAL</item>
    </string-array>
    <string-array name="parser_backend_entries">
        <item>Offline (Kuromoji)</item>
        <item>Jiten.moe API</item>
        <item>JPDB API</item>
    </string-array>
    <string-array name="parser_backend_values">
        <item>offline</item>
        <item>jiten</item>
        <item>jpdb</item>
    </string-array>

    <string-array name="border_thickness_entries">
        <item>Thin (1px)</item>
        <item>Default (2px)</item>
        <item>Thick (4px)</item>
        <item>Extra Thick (6px)</item>
    </string-array>
    <string-array name="border_thickness_values">
        <item>1</item>
        <item>2</item>
        <item>4</item>
        <item>6</item>
    </string-array>

    <string-array name="border_color_entries">
        <item>Gaku Blue</item>
        <item>Ruby Red</item>
        <item>Emerald Green</item>
        <item>Highlight Yellow</item>
    </string-array>
    <string-array name="border_color_values">
        <item>#0064ff</item>
        <item>#ff0000</item>
        <item>#00ff00</item>
        <item>#ffff00</item>
    </string-array>
</resources>
</file>

<file path="main/res/values/colors.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="Primary">#FFFFFF</color>
    <color name="Accent">#FF4081</color>
    <color name="ic_launcher_background">#FFFFFF</color>

    <color name="PrimaryDark">#000000</color>
    <color name="AccentDark">#FF4081</color>

    <color name="important">#ff0000</color>

    <color name="black100a">#64000000</color>
    <color name="translucent">#22000000</color>
    <color name="info_window_color">#AA000000</color>
    <color name="blue_dark">#0064ff</color>
    <color name="blue_dark_translucent">#330064ff</color>
    <color name="blue_solid_highlight">#cce0ff</color>
    <color name="red_capture_window_ready">#ffd50000</color>

    <color name="kana_pink">#C71585</color>
    <color name="kana_blue">#0000CD</color>

    <color name="status_unknown">#3498db</color>
    <color name="status_learning">#FFFF00</color> <!-- Young -->
    <color name="status_known">#2ecc71</color>
    <color name="status_mature">#00FF00</color> <!-- Mature -->
    <color name="status_mastered">#006400</color> <!-- Mastered -->
    <color name="status_due">#FF0000</color> <!-- Due -->
    <color name="status_dismissed">#95a5a6</color>
</resources>
</file>

<file path="main/res/values/dimens.xml">
<resources>
    <!-- Default screen margins, per the Android Design guidelines. -->
    <dimen name="activity_horizontal_margin">16dp</dimen>
    <dimen name="activity_vertical_margin">16dp</dimen>
</resources>
</file>

<file path="main/res/values/strings.xml">
<resources>
    <string name="app_name">Gaku</string>
    <string name="support_text">"Like Gaku? Rate the app (no store yet)!"</string>
    <string name="gaku_loading">Gaku is loading</string>
    <string name="beta_screen">"Thanks for installing Gaku! This program is a fork of the no-longer maintained Kaku app, with the goal of replacing the OCR engine with a more reliable one from Google. I do not intend to maintain this project, so feel free to contribute however you see fit. Note that the codebase was largely vibe-coded to produce a minimum-viable-product, as I am not an android developer. I'm sorry if the changes cause any future maintainers headache.


BETA UPDATES (Gaku):

vLATEST
- Fix crash when choosing Kanji alternatives
- Fix crash in edit window
- Fix crash on screen rotation
- Global rename from Kaku to Gaku
- Replace OCR backend with Google MLKit (Offline)
- Remove screenshot preprocessing, as this is handled by MLKit
- Upgrade gradle to use more modern Android practices and dependencies.

v1.3.72
- Emergency fix for Android 12
- Update Tesseract libraries

v1.3.66
- Stop screen capture when device is put to sleep
- Minor bugfixes

v1.3.62
- Updating beta version of Kaku will longer remove the icon from the home screen after this update
- Improve artist text

v1.3.59
- Temporarily disable ads

v1.3.56
- Minor bugfixes
- Added dialog in tutorial explaining Kaku's permissions

v1.3.55
- No Kaku updates, just backend changes
- Bump Kotlin version, use Triple-T for automated Play Console uploads

v1.3.47
- Fix minor crashes in Kaku

v1.3.46
- Improve recognition of commonly mis-recognized kana such as  or 
- Improved normal mode so that the entire sentence can be copied, tap the sides of the normal mode window to scroll

v1.3.45
- Improve recognition of commonly mis-recognized kana such as  or 

v1.3.43
- Add similar kana to swap quick text action in case that OCR engine doesn't give that recommendation

v1.3.42
- Reduce size of tutorial videos

v1.3.40
- Revamped tutorial and shows on first start of the app
- Fix minor bugs

v1.3.38
- Fixed entry ranking issue with dictionary - less common readings of a kanji will rank lower.
- Fixed icon placement bug with select-to-swap actions in certain cases when the status bar / navigation bar is showing.

v1.3.37
- Removed history window. Not ready for prime time and I didn't particularly find it useful.
- Added ability to completely hide Kaku's capture window through the notification.

v1.3.34
- Added history window. This window shows previous kanji that you have looked up.
- You can now share text to Kaku to trigger the popup window as well.

v1.3.33
- One ad added to start screen. Sorry! But it's to help support development. It should be fairly out of the way, but let me know if it causes problems.
- Adding the ad does get rid of the 'Close Capture Window' button, but a reminder to all that you can close Kaku by simply tapping on Kaku's notification in the status bar. If you are unable to close Kaku because the notification is missing, please send me an e-mail!
- Fixed instant mode rotation bug where positioning was incorrect after device rotation.
- Fixed bug where Kaku does not start on some devices (particularly Xiaomi devices).

v1.3.32
- Instant Mode window positioning logic has been implemented. If things look off here, please let me know!

Note that if you try to leave feedback on the Play Store as a beta user, it is not shown to all users."</string>
</resources>
</file>

<file path="main/res/values/styles.xml">
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.NoActionBar">
        <!-- Customize your theme here. -->
        <!--<item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>-->
    </style>

</resources>
</file>

<file path="main/res/values-w820dp/dimens.xml">
<resources>
    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
         (such as screen margins) for screens with more than 820dp of available width. This
         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
    <dimen name="activity_horizontal_margin">64dp</dimen>
</resources>
</file>

<file path="main/res/xml/preferences.xml">
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <PreferenceCategory android:title="General Settings">
        <EditTextPreference
            android:key="pref_young_threshold"
            android:title="Young Interval Threshold (Days)"
            android:summary="Words with interval less than this are considered 'Young'"
            android:defaultValue="21"
            android:inputType="number"
            android:singleLine="true" />
    </PreferenceCategory>

    <PreferenceCategory android:title="Parsing Settings">
        <ListPreference
            android:key="pref_parser_backend"
            android:title="Parsing Backend"
            android:summary="Choose the engine used for sentence parsing"
            android:entries="@array/parser_backend_entries"
            android:entryValues="@array/parser_backend_values"
            android:defaultValue="offline" />
    </PreferenceCategory>

    <PreferenceCategory android:title="Jiten API Settings">
        <EditTextPreference
            android:key="jiten_api_url"
            android:title="API Base URL"
            android:summary="The URL of the Jiten.moe API (default: https://api.jiten.moe)"
            android:defaultValue="https://api.jiten.moe" />

        <EditTextPreference
            android:key="jiten_api_key"
            android:title="API Key / Token"
            android:summary="Your Jiten auth token"
            android:defaultValue="" />
    </PreferenceCategory>

    <PreferenceCategory android:title="JPDB API Settings">
        <EditTextPreference
            android:key="jpdb_api_key"
            android:title="API Key"
            android:summary="Your JPDB API key"
            android:defaultValue="" />
    </PreferenceCategory>

    <PreferenceCategory android:title="Database Management">
        <Preference
            android:key="db_reinit"
            android:title="Re-initialize Databases"
            android:summary="Recopy dictionary files from assets (fixes missing files)" />

        <Preference
            android:key="db_clear_user"
            android:title="Clear User Progress"
            android:summary="Reset all learned/unknown word statuses locally" />
    </PreferenceCategory>

    <PreferenceCategory android:title="OCR Settings">
        <ListPreference
            android:key="TextDirection"
            android:title="Text Direction"
            android:summary="Preferred reading direction for OCR"
            android:entries="@array/text_direction_entries"
            android:entryValues="@array/text_direction_values"
            android:defaultValue="AUTO" />

        <SwitchPreferenceCompat
            android:key="InstantMode"
            android:title="Instant Mode"
            android:summary="Perform OCR immediately on selection"
            android:defaultValue="true" />
    </PreferenceCategory>

    <PreferenceCategory android:title="Capture Window Mechanics">
        <SwitchPreferenceCompat
            android:key="pref_snap_enabled"
            android:title="Magnetic Alignment (Snapping)"
            android:summary="Snap window to edges and screen center while dragging"
            android:defaultValue="true" />

        <SwitchPreferenceCompat
            android:key="pref_show_preset_bar"
            android:title="Show Preset Bar"
            android:summary="Show size presets (Line, Paragraph, etc) when touching the window"
            android:defaultValue="true" />
    </PreferenceCategory>

    <PreferenceCategory android:title="Capture Window Appearance">
        <ListPreference
            android:key="pref_border_thickness"
            android:title="Border Thickness"
            android:summary="Thickness of the capture area boundary"
            android:entries="@array/border_thickness_entries"
            android:entryValues="@array/border_thickness_values"
            android:defaultValue="2" />

        <ListPreference
            android:key="pref_border_color"
            android:title="Border Color"
            android:summary="Color of the capture area boundary"
            android:entries="@array/border_color_entries"
            android:entryValues="@array/border_color_values"
            android:defaultValue="#0064ff" />
    </PreferenceCategory>

</PreferenceScreen>
</file>

<file path="main/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- REQUIRED for floating windows -->
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />

    <!-- REQUIRED for general Foreground Services -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />

    <!-- REQUIRED for Android 14+ Screen Capture-->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PROJECTION" />

    <!-- REQUIRED for Android 13+ to show the Foreground Service Notification -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:largeHeap="true"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

        <meta-data
            android:name="com.google.android.gms.ads.APPLICATION_ID"
            android:value="@string/ads_app_id" />

        <meta-data
            android:name="com.google.mlkit.vision.DEPENDENCIES"
            android:value="ocr_japanese" />

        <receiver android:name=".MainService$CloseMainService" />
        <receiver android:name=".MainService$TogglePageModeMainService" />
        <receiver android:name=".MainService$ToggleInstantModeMainService" />
        <receiver android:name=".MainService$ToggleImagePreviewMainService" />
        <receiver android:name=".MainService$ToggleShowHideMainService" />

        <activity
            android:name=".MainActivity"
            android:label="Gaku"
            android:noHistory="false"
            android:launchMode="standard"
            android:screenOrientation="portrait"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity android:name=".BetaActivity"
            android:label="Gaku Beta"
            android:noHistory="false"
            android:launchMode="standard"
            android:screenOrientation="portrait">
        </activity>

        <activity
            android:name=".TutorialActivity"
            android:label="Gaku Tutorial"
            android:noHistory="false"
            android:launchMode="standard"
            android:screenOrientation="portrait">
        </activity>

        <activity
            android:name=".SettingsActivity"
            android:label="Settings"
            android:screenOrientation="portrait">
        </activity>

        <activity
            android:name=".DictionaryActivity"
            android:label="Dictionaries"
            android:screenOrientation="portrait">
        </activity>

        <activity
            android:name=".PassthroughActivity"
            android:label="Gaku"
            android:launchMode="singleInstance"
            android:noHistory="true"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.PROCESS_TEXT" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="text/plain" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="text/plain" />
            </intent-filter>
        </activity>

        <!-- Defines the type for Android 10-14+ compatibility -->
        <service
            android:name=".MainService"
            android:foregroundServiceType="mediaProjection"
            android:exported="true" />
    </application>

</manifest>
</file>

<file path="test/java/ca/fuwafuwa/gaku/data/YomitanImporterTest.kt">
package ca.fuwafuwa.gaku.data

import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import ca.fuwafuwa.gaku.data.dao.TermDao
import ca.fuwafuwa.gaku.data.importer.YomitanImporter
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileInputStream
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

@RunWith(RobolectricTestRunner::class)
@Config(manifest = Config.NONE)
class YomitanImporterTest {

    private lateinit var db: AppDatabase
    private lateinit var importer: YomitanImporter

    @Before
    fun setup() {
        db = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            AppDatabase::class.java
        ).allowMainThreadQueries().build()
        importer = YomitanImporter(db)
    }

    @After
    fun tearDown() {
        db.close()
    }

    @Test
    fun import_validDictionary_populatesCoreAndMetaTables() {
        val zipBytes = createZipFromDirectory(File("yomichan tests/data/dictionaries/valid-dictionary1"))

        importer.importDictionary(zipBytes.inputStream())

        val dictionaries = db.dictionaryDao().getAllDictionaries()
        assertEquals(1, dictionaries.size)
        val dictionary = dictionaries.first()
        assertEquals("Test Dictionary", dictionary.name)
        assertEquals("test", dictionary.revision)
        assertEquals(3, dictionary.format)
        assertTrue(dictionary.sequenced)

        assertEquals(34, db.termDao().count())
        assertEquals(2, db.kanjiDao().count())
        assertEquals(40, db.termMetaDao().count())
        assertEquals(6, db.kanjiMetaDao().count())
        assertEquals(15, db.tagMetaDao().count())
    }

    @Test
    fun import_validDictionary_supportsPortedFindTermsBulkCases() {
        val zipBytes = createZipFromDirectory(File("yomichan tests/data/dictionaries/valid-dictionary1"))
        importer.importDictionary(zipBytes.inputStream())

        val exact = db.termDao().findTermsExact(listOf("", "", ""))
        assertEquals(10, exact.size)

        val byExpression = exact.groupingBy { it.expression }.eachCount()
        assertEquals(2, byExpression[""])
        assertEquals(4, byExpression[""])
        assertEquals(4, byExpression[""])

        val byReading = exact.groupingBy { it.reading }.eachCount()
        assertEquals(1, byReading[""])
        assertEquals(1, byReading[""])
        assertEquals(2, byReading[""])
        assertEquals(2, byReading[""])
        assertEquals(2, byReading[""])
        assertEquals(2, byReading[""])

        val prefix = db.termDao().findTermsByPrefix("")
        assertEquals(10, prefix.size)

        val suffix = db.termDao().findTermsBySuffix("")
        assertEquals(4, suffix.size)

        val noExactMatch = db.termDao().findTermsExact(listOf(""))
        assertTrue(noExactMatch.isEmpty())
    }

    @Test
    fun import_validDictionary_supportsPortedFindTermsExactAndSequenceCases() {
        val zipBytes = createZipFromDirectory(File("yomichan tests/data/dictionaries/valid-dictionary1"))
        importer.importDictionary(zipBytes.inputStream())

        val termsExact = db.termDao().findTermsExactByPairs(listOf("" to "", "" to "", "" to ""))
        assertEquals(5, termsExact.size)

        val wrongReading = db.termDao().findTermsExactByPairs(listOf("" to ""))
        assertTrue(wrongReading.isEmpty())

        val sequenceResults = db.termDao().findTermsBySequence(listOf(1, 2, 3, 4, 5))
        assertEquals(11, sequenceResults.size)
        val seqByExpression = sequenceResults.groupingBy { it.expression }.eachCount()
        assertEquals(2, seqByExpression[""])
        assertEquals(4, seqByExpression[""])
        assertEquals(4, seqByExpression[""])
        assertEquals(1, seqByExpression[""])
    }

    @Test
    fun import_validDictionary_supportsPortedMetaAndKanjiLookupCases() {
        val zipBytes = createZipFromDirectory(File("yomichan tests/data/dictionaries/valid-dictionary1"))
        importer.importDictionary(zipBytes.inputStream())

        val termMeta = db.termMetaDao().findByExpressions(listOf(""))
        assertEquals(13, termMeta.size)
        assertEquals(10, termMeta.count { it.mode == "freq" })
        assertEquals(3, termMeta.count { it.mode == "pitch" })

        val kanji = db.kanjiDao().findKanjiBulk(listOf("", ""))
        assertEquals(2, kanji.size)

        val kanjiMeta = db.kanjiMetaDao().findByCharacters(listOf(""))
        assertEquals(3, kanjiMeta.size)
        assertEquals(3, kanjiMeta.count { it.mode == "freq" })

        val e1Tag = db.tagMetaDao().findTagByNameAndDictionary("E1", "Test Dictionary")
        assertNotNull(e1Tag)
        assertEquals("default", e1Tag?.category)
        assertEquals("example tag 1", e1Tag?.notes)

        val missingTag = db.tagMetaDao().findTagByNameAndDictionary("invalid", "Test Dictionary")
        assertNull(missingTag)
    }


    @Test
    fun import_dictionaryFileWithIndexAtEnd_succeeds() {
        val sourceDir = File("yomichan tests/data/dictionaries/valid-dictionary1")
        val tempZip = File.createTempFile("yomitan-test-", ".zip")

        try {
            ZipOutputStream(tempZip.outputStream()).use { zip ->
                val files = sourceDir.listFiles()?.filter { it.isFile }?.sortedBy { it.name }.orEmpty()
                files.filter { it.name != "index.json" }.forEach { file ->
                    zip.putNextEntry(ZipEntry(file.name))
                    FileInputStream(file).use { input -> input.copyTo(zip) }
                    zip.closeEntry()
                }
                val indexFile = files.first { it.name == "index.json" }
                zip.putNextEntry(ZipEntry(indexFile.name))
                FileInputStream(indexFile).use { input -> input.copyTo(zip) }
                zip.closeEntry()
            }

            importer.importDictionary(tempZip)

            assertEquals(1, db.dictionaryDao().getAllDictionaries().size)
            assertEquals(34, db.termDao().count())
        } finally {
            tempZip.delete()
        }
    }

    @Test
    fun import_supportsNestedArchivePaths() {
        val zipBytes = createZipFromDirectory(
            directory = File("yomichan tests/data/dictionaries/valid-dictionary1"),
            prefix = "nested/"
        )

        importer.importDictionary(zipBytes.inputStream())

        assertEquals(1, db.dictionaryDao().getAllDictionaries().size)
        assertEquals(34, db.termDao().count())
    }

    @Test(expected = IllegalStateException::class)
    fun import_missingIndex_throws() {
        val out = ByteArrayOutputStream()
        ZipOutputStream(out).use { zip ->
            zip.putNextEntry(ZipEntry("term_bank_1.json"))
            zip.write("[]".toByteArray())
            zip.closeEntry()
        }

        importer.importDictionary(out.toByteArray().inputStream())
    }

    private fun createZipFromDirectory(directory: File, prefix: String = ""): ByteArray {
        val out = ByteArrayOutputStream()
        ZipOutputStream(out).use { zip ->
            directory.listFiles()
                ?.filter { it.isFile }
                ?.sortedBy { it.name }
                ?.forEach { file ->
                    zip.putNextEntry(ZipEntry(prefix + file.name))
                    FileInputStream(file).use { input -> input.copyTo(zip) }
                    zip.closeEntry()
                }
        }
        return out.toByteArray()
    }
}

private fun TermDao.findTermsExactByPairs(pairs: List<Pair<String, String>>): List<Term> {
    if (pairs.isEmpty()) return emptyList()

    val result = mutableListOf<Term>()
    for ((expression, reading) in pairs) {
        result += findTermExact(expression, reading)
    }
    return result
}
</file>

<file path="test/java/ca/fuwafuwa/kaku/ExampleUnitTest.java">
package ca.fuwafuwa.gaku;

import android.util.Xml;

import com.atilika.kuromoji.ipadic.Token;
import com.atilika.kuromoji.ipadic.Tokenizer;

import org.junit.Test;
import java.util.List;

import ca.fuwafuwa.gaku.Deinflictor.PosMap;

/**
 * To work on unit tests, switch the Test Artifact in the Build Variants view.
 */
public class ExampleUnitTest {

    private String GetTokenString(Token token) {
        return String.format("%s,%s,%s,%s,%s,%s,%s,%s,%s",
                PosMap.Companion.GetPosMapVal(token.getPartOfSpeechLevel1()),
                PosMap.Companion.GetPosMapVal(token.getPartOfSpeechLevel2()),
                PosMap.Companion.GetPosMapVal(token.getPartOfSpeechLevel3()),
                PosMap.Companion.GetPosMapVal(token.getPartOfSpeechLevel4()),
                PosMap.Companion.GetPosMapVal(token.getConjugationType()),
                PosMap.Companion.GetPosMapVal(token.getConjugationForm()),
                token.getBaseForm(),
                token.getReading(),
                token.getPronunciation());
    }

    @Test
    public void test() {
        Tokenizer tokenizer = new Tokenizer();
        List<Token> tokens = tokenizer.tokenize("");
        for (Token token : tokens) {
            System.out.println(token.getSurface() + "\t" + GetTokenString(token));
        }
    }

    @Test
    public void TestCircledNum() {
        for (int i = 1; i <= 100; i++) {
            System.out.println(LangUtils.Companion.ConvertIntToCircledNum(i));
        }
    }
}
</file>

<file path="test/java/ca/fuwafuwa/kaku/GenerateDictionary.java">
package ca.fuwafuwa.gaku;

import android.util.Xml;

import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.dao.DaoManager;
import com.j256.ormlite.jdbc.JdbcConnectionSource;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.table.TableUtils;

import org.junit.Ignore;
import org.junit.Test;
import org.kxml2.io.KXmlParser;
import org.xmlpull.v1.XmlPullParser;

import java.io.File;
import java.io.FileInputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.SQLException;

import ca.fuwafuwa.gaku.legacy.core.IDatabaseHelper;
import ca.fuwafuwa.gaku.legacy.jmdict.models.EntryOptimized;
import ca.fuwafuwa.gaku.data.parser.JmDictLegacyParser;

public class GenerateDictionary {
    class DatabaseHelperImpl implements IDatabaseHelper {

        ConnectionSource mConnectionSource;

        DatabaseHelperImpl(ConnectionSource connectionSource) {
            mConnectionSource = connectionSource;
        }

        @Override
        public <T> Dao<T, Integer> getDbDao(Class clazz) throws SQLException {
            return DaoManager.createDao(mConnectionSource, clazz);
        }
    }

    /**
     * This isn't actually a test, it generates the SQLite dictionary for the gaku
     * app
     * I'm just too lazy to have it be in another project so it's in this here as a
     * test instead. Sorry.
     *
     * Wtf fuck Android this doesn't even work.
     *
     * @throws Exception
     */
    @Ignore("Legacy utility test: JMdict XML parser was removed during Room migration")
    @Test
    public void generateDic() throws Exception {

        String dbPath = "D:/Dev/gakuFiles/gaku_edict.sqlite";
        String xmlPath = "D:/Dev/gakuFiles/JMdictOriginal.xml";
        String databaseUrl = String.format("jdbc:sqlite:%s", dbPath);

        Files.deleteIfExists(Paths.get(dbPath));

        FileInputStream mDictXml = new FileInputStream(xmlPath);
        XmlPullParser mParser = new KXmlParser();
        mParser.setInput(mDictXml, null);

        ConnectionSource connectionSource = null;
        try {
            connectionSource = new JdbcConnectionSource(databaseUrl);
            TableUtils.createTable(connectionSource, EntryOptimized.class);

            DatabaseHelperImpl dbHelper = new DatabaseHelperImpl(connectionSource);

            JmDictLegacyParser jmParser = new JmDictLegacyParser(dbHelper);
            jmParser.parse(mParser);
        } finally {
            if (connectionSource != null) {
                connectionSource.close();
            }
        }
    }
}
</file>

</files>
