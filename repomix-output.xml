This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
BoxParams.java
OcrCorrection.kt
OcrParams.kt
OcrResult.kt
OcrRunnable.kt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="BoxParams.java">
package ca.fuwafuwa.gaku.Ocr;

/**
 * Created by 0xbad1d3a5 on 4/16/2016.
 */
public final class BoxParams {

    public int x;
    public int y;
    public int width;
    public int height;

    public BoxParams(int x, int y, int width, int height){
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public String toString(){
        return String.format("X:%d Y:%d (%dx%d)", x, y, width, height);
    }
}
</file>

<file path="OcrCorrection.kt">
package ca.fuwafuwa.gaku.Ocr

class OcrCorrection
{
    companion object
    {
        val CommonLookalikes: List<List<String>> = listOf(

                // Hiragana
                listOf("あ", "ぁ", "お", "ぉ"),
                listOf("い", "ぃ"),
                listOf("う", "ぅ"),
                listOf("え", "ぇ", "z", "Z"),
                listOf("お", "ぉ", "あ", "ぁ"),

                listOf("か", "が", "カ", "ガ", "ヵ", "力"),
                listOf("き", "ぎ", "さ", "ざ"),
                listOf("く", "ぐ", "〈", "<", "＜", "("),
                listOf("け", "げ"),
                listOf("こ", "ご"),

                listOf("さ", "ざ", "き", "ぎ"),
                listOf("し", "じ", "L", "Ｌ", "U"),
                listOf("す", "ず"),
                listOf("せ", "ぜ"),
                listOf("そ", "ぞ"),

                listOf("た", "だ"),
                listOf("ち", "ぢ"),
                listOf("つ", "づ", "っ", "ウ", "ゥ", "ワ", "ヮ"),
                listOf("て", "で"),
                listOf("と", "ど"),

                listOf("な"),
                listOf("に"),
                listOf("ぬ"),
                listOf("ね"),
                listOf("の"),

                listOf("は", "ば", "ぱ"),
                listOf("ひ", "び", "ぴ"),
                listOf("ふ", "ぶ", "ぷ"),
                listOf("へ", "べ", "ぺ"),
                listOf("ほ", "ぼ", "ぽ"),

                listOf("ま"),
                listOf("み"),
                listOf("む"),
                listOf("め"),
                listOf("も"),

                listOf("や", "ゃ"),
                listOf("ゆ", "ゅ"),
                listOf("よ", "ょ"),

                listOf("ら"),
                listOf("り", "リ", "ㇼ"),
                listOf("る"),
                listOf("れ"),
                listOf("ろ"),

                listOf("わ", "ゎ"),
                listOf("を"),
                listOf("ん"),

                // Katakana
                listOf("ア", "ァ"),
                listOf("イ", "ィ"),
                listOf("ウ", "ゥ", "つ", "づ", "っ", "ワ", "ヮ"),
                listOf("エ", "ェ"),
                listOf("オ", "ォ"),

                listOf("カ", "ガ", "ヵ", "か", "が", "力"),
                listOf("キ", "ギ"),
                listOf("ク", "グ", "ㇰ"),
                listOf("ケ", "ゲ", "ヶ"),
                listOf("コ", "ゴ"),

                listOf("サ", "ザ"),
                listOf("シ", "ジ", "ㇱ"),
                listOf("ス", "ズ", "ㇲ"),
                listOf("セ", "ゼ"),
                listOf("ソ", "ゾ"),

                listOf("タ", "ダ", "夕"),
                listOf("チ", "ヂ"),
                listOf("ツ", "ヅ", "ッ"),
                listOf("テ", "デ"),
                listOf("ト", "ド", "ㇳ"),

                listOf("ナ"),
                listOf("ニ"),
                listOf("ヌ", "ㇴ"),
                listOf("ネ"),
                listOf("ノ"),

                listOf("ハ", "バ", "パ", "ㇵ"),
                listOf("ヒ", "ビ", "ピ", "ㇶ"),
                listOf("フ", "ブ", "プ", "ㇷ", "ン"), //, "\u31f7\u309a"),
                listOf("ヘ", "ベ", "ペ", "ㇸ"),
                listOf("ホ", "ボ", "ポ", "ㇹ"),

                listOf("マ"),
                listOf("ミ"),
                listOf("ム", "ㇺ"),
                listOf("メ"),
                listOf("モ"),

                listOf("ヤ", "ャ"),
                listOf("ユ", "ュ"),
                listOf("ヨ", "ョ"),

                listOf("ラ", "ㇻ"),
                listOf("リ", "ㇼ", "り"),
                listOf("ル", "ㇽ"),
                listOf("レ", "ㇾ"),
                listOf("ロ", "ㇿ", "口"),

                listOf("ワ", "ヮ", "ウ", "ゥ", "つ", "づ", "っ"),
                listOf("ヲ"),
                listOf("ン"),

                // Other
                listOf("ー", "一", "―", "‐", "—", "－", "-", "_", "|"),
                listOf("、", "`", "ヽ"),
                listOf("。", "o")
        )

        val CommonMistakes : List<Pair<List<String>, String>> = listOf(

                Pair(listOf("〈", "<", "＜"), "く"),
                Pair(listOf("L", "Ｌ"), "し"),
                Pair(listOf("z", "Z"), "え"),
                Pair(listOf("U"), "じ"),
                Pair(listOf("`", "ヽ"), "、"),
                Pair(listOf("o"), "。"),

                // Special cases for multiple mappings
                Pair(listOf("ー", "一", "―", "‐", "—", "－", "-", "_", "|"), "")
        )
    }
}
</file>

<file path="OcrParams.kt">
package ca.fuwafuwa.gaku.Ocr

import android.graphics.Bitmap

data class OcrParams(val bitmap: Bitmap,
                     val originalBitmap: Bitmap,
                     val box: BoxParams,
                     val offsetX: Int,
                     val offsetY: Int,
                     val instantMode: Boolean)
{
    override fun toString() : String {
        return "Box: $box InstantOCR: $instantMode Offset: ($offsetX, $offsetY)"
    }
}
</file>

<file path="OcrResult.kt">
package ca.fuwafuwa.gaku.Ocr

import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr

/**
 * Created by 0xbad1d3a5 on 5/2/2016.
 */
class OcrResult(val displayData: DisplayDataOcr,
                private val mOcrTime: Long)
{
    val text: String get() = displayData.text
    val message: String get() = String.format("OCR Time: %.2fs", mOcrTime / 1000.0)

    override fun toString(): String
    {
        return String.format("%s\nOcrTime: %d\nInstant: %b", text, mOcrTime, displayData.instantMode)
    }
}
</file>

<file path="OcrRunnable.kt">
package ca.fuwafuwa.gaku.Ocr

import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.os.Message
import android.util.Log
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import com.google.android.gms.tasks.Tasks
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.japanese.JapaneseTextRecognizerOptions
import java.io.FileNotFoundException
import java.io.FileOutputStream
import java.util.concurrent.ExecutionException
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException
import ca.fuwafuwa.gaku.*
import ca.fuwafuwa.gaku.Interfaces.Stoppable
import ca.fuwafuwa.gaku.MainService
import ca.fuwafuwa.gaku.Windows.CaptureWindow
import ca.fuwafuwa.gaku.Windows.Data.ChoiceCertainty
import ca.fuwafuwa.gaku.Windows.Data.SquareCharOcr
import ca.fuwafuwa.gaku.Windows.Data.DisplayDataOcr
import ca.fuwafuwa.gaku.Analysis.TextAnalyzer
import ca.fuwafuwa.gaku.Analysis.ParsedResult

class OcrRunnable(context: Context, private var mCaptureWindow: CaptureWindow?) : Runnable, Stoppable {
    private val mContext: MainService = context as MainService
    private val mOcrLock = java.lang.Object()
    private val mSimilarChars = loadSimilarChars()
    private val mCommonMistakes = loadCommonMistakes()
    private val mTextAnalyzer = TextAnalyzer(context)
    private var mTextRecognizer: com.google.mlkit.vision.text.TextRecognizer? = null
    private var mThreadRunning = true
    private var mOcrParams: OcrParams? = null
    private var mIsReady = false

    val isReadyForOcr: Boolean
    get() = mOcrParams == null

    init {
        mOcrParams = null
    }

    fun warmUp() {
        if (mIsReady) return

        Log.d(TAG, "Warming up OCR engine.")

        // safeInitClient returns true if successful, false if it crashed
        if (!safeInitClient()) {
            sendToastToContext("Failed to initialize MLKit (Check Logs)")
            return
        }

        // ML Kit requires input images to be at least 32x32 pixels.
        val dummyBitmap = Bitmap.createBitmap(32, 32, Bitmap.Config.ARGB_8888)
        val image = InputImage.fromBitmap(dummyBitmap, 0)

        // Force non-null assertion (!!) is safe here because safeInitClient returned true
        mTextRecognizer!!.process(image)
            .addOnSuccessListener {
                Log.d(TAG, "OCR engine is ready.")
                mIsReady = true
                sendModelReadyBroadcast()
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "OCR engine warm-up failed.", e)
                mIsReady = true // Mark ready anyway to unblock UI
                sendModelReadyBroadcast()
            }
    }

    private fun safeInitClient(): Boolean {
        if (mTextRecognizer != null) return true

        return try {
            val options = JapaneseTextRecognizerOptions.Builder().build()
            mTextRecognizer = TextRecognition.getClient(options)
            true
        } catch (e: Throwable) {
            // This catch block is CRITICAL. It catches UnsatisfiedLinkError (Native crash)
            // and standard Exceptions, printing them to Logcat so you can finally see them.
            Log.e(TAG, "CRITICAL ERROR: Could not create TextRecognition client", e)
            e.printStackTrace()
            false
        }
    }

    private fun sendModelReadyBroadcast() {
        val intent = Intent(ACTION_MODEL_READY)
        LocalBroadcastManager.getInstance(mContext).sendBroadcast(intent)
    }

    override fun run() {
        // 1. Initialize safely on the background thread.
        // If this fails, we exit the thread to prevent a crash loop.
        if (!safeInitClient()) {
            Log.e(TAG, "Stopping OcrRunnable because OCR Client failed to initialize.")
            return
        }

        while (mThreadRunning) {
            try {
                synchronized(mOcrLock) {
                    if (mOcrParams == null) {
                        mOcrLock.wait()
                    }

                    if (!mThreadRunning) return

                    // Local capture to ensure thread safety
                    val ocrParams = mOcrParams
                    // Safely unwrap the recognizer (we know it's not null due to safeInitClient)
                    val recognizer = mTextRecognizer

                    if (ocrParams != null && recognizer != null) {
                        Log.d(TAG, "Processing OCR with params $ocrParams")
                        val startTime = System.currentTimeMillis()
                        mCaptureWindow?.showLoadingAnimation()

                        try {
                            // 2. Prepare the InputImage
                            val image = InputImage.fromBitmap(ocrParams.bitmap, 0)

                            // 3. Process blocking (Tasks.await is safe here in background thread)
                            val result = Tasks.await(recognizer.process(image), 10, TimeUnit.SECONDS)

                            val displayData = getDisplayData(ocrParams, result)
                            processDisplayData(displayData)

                            val ocrTime = System.currentTimeMillis() - startTime
                            val parsedResult = mTextAnalyzer.analyze(result, displayData, ocrTime)

                            if (displayData.text.isNotEmpty()) {
                                sendOcrResultToContext(parsedResult)
                            } else {
                                sendToastToContext("No Characters Recognized.")
                            }
                        } catch (e: Exception) {
                            when (e) {
                                is ExecutionException, is InterruptedException, is TimeoutException -> {
                                    Log.e(TAG, "OCR failed", e)
                                    sendToastToContext("OCR Failed: ${e.message}")
                                }
                                else -> {
                                    Log.e(TAG, "Unexpected OCR Error", e)
                                    // Don't throw; just log so the thread keeps living
                                }
                            }
                        } finally {
                            mCaptureWindow?.stopLoadingAnimation(ocrParams.instantMode)
                            mOcrParams = null
                        }
                    }
                }
            } catch (e: InterruptedException) {
                Log.d(TAG, "OcrRunnable interrupted, shutting down.")
                mThreadRunning = false
            } catch (e: Exception) {
                // Catch global exceptions to keep the thread alive
                Log.e(TAG, "General Error in OcrRunnable Loop", e)
                e.printStackTrace()
            }
        }

        Log.d(TAG, "THREAD STOPPED")
        mTextRecognizer?.close()
    }

    fun runTess(ocrParams: OcrParams) {
        synchronized(mOcrLock) {
            if (!mThreadRunning) return
            mOcrParams = ocrParams
            mOcrLock.notify()
            Log.d(TAG, "NOTIFIED")
        }
    }

    fun cancel() {
        Log.d(TAG, "CANCELED (Not implemented for ML Kit)")
    }

    override fun stop() {
        synchronized(mOcrLock) {
            mThreadRunning = false
            mCaptureWindow = null
            mOcrParams = null
            mOcrLock.notify()
        }
    }

    private fun processDisplayData(displayData: DisplayDataOcr) {
        val squareChars = displayData.squareChars.filterIsInstance<SquareCharOcr>()
        for (squareChar in squareChars) {
            mSimilarChars[squareChar.char]?.forEach {
                squareChar.addChoice(it, ChoiceCertainty.UNCERTAIN)
            }
        }

        for (squareChar in squareChars) {
            correctCommonMistake(squareChar, "く")
            correctCommonMistake(squareChar, "し")
            correctCommonMistake(squareChar, "じ")
            correctCommonMistake(squareChar, "え")
            correctCommonMistake(squareChar, "、")
            correctCommonMistake(squareChar, "。")
            correctKanjiOne(squareChar)
            correctKatakanaDash(squareChar)
        }
    }

    private fun correctCommonMistake(squareChar: SquareCharOcr, char: String) {
        if (mCommonMistakes[squareChar.char] == char) {
            val prev = squareChar.prev
            val next = squareChar.next
            if (prev?.char?.let { LangUtils.IsJapaneseChar(it[0]) } == true ||
                next?.char?.let { LangUtils.IsJapaneseChar(it[0]) } == true) {
                squareChar.addChoice(char, ChoiceCertainty.CERTAIN)
            }
        }
    }

    private fun correctKatakanaDash(squareChar: SquareCharOcr) {
        if (mCommonMistakes[squareChar.char] != null) {
            val prev = squareChar.prev
            if (prev?.char?.let { LangUtils.IsKatakana(it[0]) } == true) {
                squareChar.addChoice("ー", ChoiceCertainty.CERTAIN)
            }
        }
    }

    private fun correctKanjiOne(squareChar: SquareCharOcr) {
        if (mCommonMistakes[squareChar.char] != null) {
            val next = squareChar.next
            if (next?.char?.let { LangUtils.IsKanji(it[0]) || LangUtils.IsHiragana(it[0]) } == true) {
                squareChar.addChoice("一", ChoiceCertainty.CERTAIN)
            }
        }
    }

    private fun getDisplayData(ocrParams: OcrParams, visionText: Text): DisplayDataOcr {
        val bitmap = ocrParams.originalBitmap
        val boxParams = ocrParams.box
        val ocrChars = ArrayList<SquareCharOcr>()
        val displayData = DisplayDataOcr(bitmap, boxParams, ocrParams.instantMode, ocrChars)

        // 1. Sort the BLOCKS, not the individual symbols.
        // This preserves the internal Left-to-Right order of horizontal text,
        // while still ordering the blocks themselves in Japanese/Manga order (Right-to-Left, Top-to-Bottom).
        val sortedBlocks = visionText.textBlocks.sortedWith(Comparator { a, b ->
            val rectA = a.boundingBox ?: return@Comparator 0
            val rectB = b.boundingBox ?: return@Comparator 0

            // If blocks are vertically aligned (similar X coordinates), sort Top-to-Bottom.
            // If they are horizontally separated, sort Right-to-Left (Manga style).
            val threshold = 20 

            if (Math.abs(rectA.left - rectB.left) > threshold) {
                // Right to Left (Manga Columns)
                rectB.left - rectA.left
            } else {
                // Top to Bottom (Standard Rows)
                rectA.top - rectB.top
            }
        })

        // 2. Iterate through hierarchy to collect symbols in the correct order
        for (block in sortedBlocks) {
            for (line in block.lines) {
                for (element in line.elements) {
                    for (symbol in element.symbols) {
                        
                        val choices = ArrayList<Pair<String, Double>>()
                        choices.add(Pair(symbol.text, symbol.confidence.toDouble()))

                        val pos = symbol.boundingBox ?: android.graphics.Rect()

                        // Calculate relative position to the original full-screen bitmap
                        ocrChars.add(SquareCharOcr(
                            displayData,
                            choices,
                            intArrayOf(
                                pos.left + ocrParams.offsetX, 
                                pos.top + ocrParams.offsetY, 
                                pos.right + ocrParams.offsetX, 
                                pos.bottom + ocrParams.offsetY
                            )
                        ))
                    }
                }
            }
        }

        displayData.assignIndicies()
        return displayData
    }

    private fun loadSimilarChars(): Map<String, List<String>> {
        val similarChars = HashMap<String, MutableList<String>>()
        for (list in OcrCorrection.CommonLookalikes) {
            for ((index, kana) in list.withIndex()) {
                if (list.size <= 1) continue

                val others = list.toMutableList().apply { removeAt(index) }
                val existing = similarChars.getOrPut(kana) { mutableListOf() }
                others.forEach {
                    if (!existing.contains(it)) {
                        existing.add(it)
                    }
                }
            }
        }
        return similarChars
    }

    private fun loadCommonMistakes(): HashMap<String, String> {
        val commonMistakes = HashMap<String, String>()
        for (pair in OcrCorrection.CommonMistakes) {
            for (c in pair.first) {
                commonMistakes[c] = pair.second
            }
        }
        return commonMistakes
    }

    private fun sendOcrResultToContext(result: Any) {
        Message.obtain(mContext.handler, 0, result).sendToTarget()
    }

    private fun sendToastToContext(message: String) {
        Message.obtain(mContext.handler, 0, message).sendToTarget()
    }

    @Throws(FileNotFoundException::class)
    private fun saveBitmap(bitmap: Bitmap, name: String = "screen") {
        try {
            val fs = "${mContext.filesDir.absolutePath}/$SCREENSHOT_FOLDER_NAME/${name}_${System.nanoTime()}.png"
            Log.d(TAG, fs)
            FileOutputStream(fs).use {
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, it)
            }
        } catch(e: Exception) {
            Log.e(TAG, "Failed to save bitmap", e)
        }
    }

    companion object {
        private val TAG = OcrRunnable::class.java.name
        const val ACTION_MODEL_READY = "ca.fuwafuwa.gaku.MODEL_READY"
    }
}
</file>

</files>
